[
  {
    "objectID": "tutorials/selections.html",
    "href": "tutorials/selections.html",
    "title": "Selections",
    "section": "",
    "text": "Selections power every part of Molecular Visualisation. You are probably used to using selections via manually pointing and clicking with your mouse, or typing long strings of complex selection algebra.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Selections"
    ]
  },
  {
    "objectID": "tutorials/selections.html#a-simple-example",
    "href": "tutorials/selections.html#a-simple-example",
    "title": "Selections",
    "section": "A Simple Example",
    "text": "A Simple Example\nTo create a selection of residues ALA, CYS and TRP, only inside of chain A, you would use the following code inside of PyMol:\nselect my_selection, chain A and (resn ALA+CYS+TRP)\nInside of Molecular Nodes, you combine different selection nodes. The outputs of these are are a boolean True / False for each atom. The logical test being performed depends on the node. To recreate the selection above, we can use the Select Chain and Select Res Name nodes.\n\n\n\nReplicating the same selection in Molecular Nodes\n\n\nThis might initially seem quite verbose. The good thing however is that these selections can always be updated and tweaked. They can even be created procedurally based on the values of other selections or animations.\nIn the example video below we are using the selection to apply the Atoms style. We can change the residues and chains that are selected by ticking and unticking the boxes. Each of these selections also take a field input, so they can use the output of other selection nodes. The selections from the two nodes are being combined with the Boolean Math node set to And. Other boolean math operations are also available.\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Selections"
    ]
  },
  {
    "objectID": "tutorials/selections.html#different-styles-combined",
    "href": "tutorials/selections.html#different-styles-combined",
    "title": "Selections",
    "section": "Different Styles Combined",
    "text": "Different Styles Combined\nIn this example, we apply the Surface style to one chain, and the Atoms style to another chain. We can join the two styles together with the Join Geometry node.\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Selections"
    ]
  },
  {
    "objectID": "tutorials/selections.html#combining-selections",
    "href": "tutorials/selections.html#combining-selections",
    "title": "Selections",
    "section": "Combining Selections",
    "text": "Combining Selections\nSelections can be combined not just through Boolean Math nodes, but also by connecting the output from one node to the input of another selection. In this example we are selecting two chains for applying the Atoms style to.\nThe selection of Chain A we then control though the Cube selection node. The addition of this node creates a new object called Empty_Cube which we can transform by Grabbing, Rotating and Scaling to change what is inside of the cube. The style is then applied to the updated selection, which varies for Cahin A but not for Chain F.\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Selections"
    ]
  },
  {
    "objectID": "tutorials/selections.html#more-examples",
    "href": "tutorials/selections.html#more-examples",
    "title": "Selections",
    "section": "More Examples",
    "text": "More Examples\nYou can use these dynamic selections for any kind of boolean input. It can be used to select the atoms to apply a style to or even to change different aspects of that style itself. In this example, we first choose the atoms to apply the style to; then instead, we change whether or not we use cylinders for the cartoon style.\nVideo\nSelecting based on the entity_id, to reveal the rotary axel of the protein complex underneath.\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Selections"
    ]
  },
  {
    "objectID": "tutorials/selections.html#open-a-local-file",
    "href": "tutorials/selections.html#open-a-local-file",
    "title": "Selections",
    "section": "Open a Local File",
    "text": "Open a Local File\nTo open a .pdb, .mmCIF, .pdbx or other similar files, use the Local File tab.\nYou can set the name for the molecule, which will become the object’s name once imported. Use the folder icon to select the file you would like to import.\n\n\n\nThe ‘Local File’ tab.\n\n\nThe ‘Default Style’ was changed to ‘Cartoon’, but no other default import options were changed. The Default Cube was deleted with X as the protein was imported inside of the cube.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Selections"
    ]
  },
  {
    "objectID": "tutorials/importing.html",
    "href": "tutorials/importing.html",
    "title": "Fetch from the PDB",
    "section": "",
    "text": "Molecules, simulations and other file formats can all be imported via the Molecular Nodes subpanel. This panel can be found under the Scene Properties panel. This is the small cone and spheres icon on the right. This contains all of the different options for importing molecular data currently available inside of Molecular Nodes.\nYou can download a structure directly from the PDB, just from the accession code. Molecular Nodes will download the file as a .bcif file and cache it locally on your computer, then open the file in to Blender. This is the quickest way to import structures that are already available via the wwPDB. Currently this downloads via the RCSB.\nTo download directly from the PDB, you can use the PDB tab.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Fetch from the PDB"
    ]
  },
  {
    "objectID": "tutorials/importing.html#pdb-tab",
    "href": "tutorials/importing.html#pdb-tab",
    "title": "Fetch from the PDB",
    "section": "PDB Tab",
    "text": "PDB Tab\nIn this tab you can input the PDB ID to be used for downloading the structure. You can also change where Molecular Nodes caches the downloaded structures. By default it will be in a hidden .MolecularNodes folder in your home directory.\n\n\n\nThe PDB import tab.\n\n\nType in the code, choose your import options such as starting style, and click download. The new object will appear in the outliner. It will appear inside of the MolecularNodes collection and should have the name of the PDB ID used to fetch the structure. If an object already exists with that name, it will be appended with a .001 or similar suffix.\nThe molecule may appear inside of the default cube, so you may have to delete it before the protein becomes visible.\n\n\nVideo\nDownloading 4OZS from the PDB",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Fetch from the PDB"
    ]
  },
  {
    "objectID": "tutorials/importing.html#edit-mode",
    "href": "tutorials/importing.html#edit-mode",
    "title": "Fetch from the PDB",
    "section": "Edit Mode",
    "text": "Edit Mode\nThe protein is imported as a 3D mesh, with a vertex for each atom and an edge for each bond. What you are seeing is the result of passing that data through a geometry-processing pipeline. The underlying data is still available, and you can even look at it (and edit it if you wish) by going using edit mode with Tab\nYou are editing the underlying atomic data, not the cartoon itself. The cartoon is rebuilt on top of the edited atomic data, which is why part of it also moves with the atoms when they are moved.\nIt is probably ill-advised to manually edit the atomic data by hand, but it is important to understand the structure of the data inside of Blender & Molecular Nodes.\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Fetch from the PDB"
    ]
  },
  {
    "objectID": "tutorials/importing.html#rendered-views",
    "href": "tutorials/importing.html#rendered-views",
    "title": "Fetch from the PDB",
    "section": "Rendered Views",
    "text": "Rendered Views\nWhile the molecule is imported, we are in 3D view by default. We can change to a rendered view to view the molecule with more accurately calculated lighting effects.\n\n\nVideo\nChanging to rendered views in different rendering engines.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Fetch from the PDB"
    ]
  },
  {
    "objectID": "tutorials/importing.html#changing-styles",
    "href": "tutorials/importing.html#changing-styles",
    "title": "Fetch from the PDB",
    "section": "Changing Styles",
    "text": "Changing Styles\nThe protein is now imported in the scene. To change the way the protein is displayed, we have to use the Geometry Nodes editor. This is where we change the nodes that are use to process the underlying atomic data, resulting in the final 3D object we can see in front of us.\nTo access Geometry Nodes panel, we can either select the Geoemtry Nodes workspace, or split the current viewport and change one of the workspaces into the node editor.\n\n\nVideo\nArranging workspaces.\n\n\nYou can change the workspace through the tabs in the top of Blender. You can split workspaces by hovering over the corner of a workspace, and then clicking and dragging. You can merge to workspaces by clicking and dragging from one into another, while dragging into the same workspace will split it and create two workspaces.\n\n\nVideo\nOpening the Geometry Nodes workspaces.\n\n\nGeometry node trees are explained more in the next section.\nIn short, the atomic data comes through the Group Input on the left, and the final 3D model goes out the Group Output to the right. Each node in between performs some actions on the data. The first node changes the colours of the atoms. The last node applies the given style. When importing we chose the Cartoon style default, so we have a cartoon node.\nWe can add a new node through the Add menu, or we can use Shift + A to add new nodes. We can click and drag on the noodle outputs and inputs to remove and create new connections. Notice how when the complete ‘circuit’ or ‘flow diagram’ goes through the ball and stick node, the style changes to ball and stick. When it flows through the cartoon node, the style changes to cartoon.\n\n\nVideo\nAdding a new node to change the output style.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Fetch from the PDB"
    ]
  },
  {
    "objectID": "tutorials/importing.html#geometry-nodes-editor",
    "href": "tutorials/importing.html#geometry-nodes-editor",
    "title": "Fetch from the PDB",
    "section": "Geometry Nodes Editor",
    "text": "Geometry Nodes Editor\nThis is where we edit the node graph for Molecular Nodes. The node graph is a geometry processing program you create, that is read and executed by Blender from left to right. Each node performs an action on the geometry that is passed into it, and the result of that action is passed out to the right. Think of it as creating a set of rules for the computer to follow. You define the rules, and the computer can follow those same rules, even if you start with a different data set.\nThe data flows like a river, along the green noodles of the node graph. There must be only 1 final output. If you are using the molecular data, then there must also be a single input.\n\n\n\nExample node tree, demonstrating the flow of information through the nodes.\n\n\nThe data flows from left to right, like water through a river.\n\n\n\n\n\nflowchart LR\n  A{Atomic\\nData} --&gt; B[Manipulation]\n  B --&gt; D(Style)\n  D --&gt; G{Geometry\\nOutput}\n\n\n\n\n\n\n\n\n\nScreenshot of the Geometry Nodes workspace.\n\n\nThe starting style MOL_style_atoms_cycles is only visible via inside of the Cycles render engine. You can add other styles manipulate the data through other nodes, by adding them with Shift + A and navigating to the MolecularNodes panel at the bottom. There are several categories of nodes for different animations and styles. You can add the Ribbon Protein node, which will create a ribbon representation based on the alpha carbons in the structure. If there is not colour in the structure, ensure that the node has a material MOL_atomic_material at the bottom of the node.\n\nThe data flows through the node graph from left to right. There should always be one input, which is the atomic data that is stored in the 3D mesh of the atoms and bonds. There should also be only one output, which is the final geometry that has been created throughout the node graph.\n\n\n\n\n\nflowchart LR\n  A{Atomic\\nData} --&gt; B[Manipulation]\n\n  B --&gt; D(Style 1)\n  B --&gt; E(Style 2)\n  B --&gt; S(Style 3)\n\n  sS[Selection] --&gt; S\n\n  E --&gt; F[Join\\nGeometry]\n  D --&gt; F\n  S --&gt; F\n\n  F --&gt; G{Geometry\\nOutput}\n\n\n\n\n\n\nAs demonstrated in the diagram, the flow of the data can split across multiple different branches of the tree, with the result of each parallel computation being combined before being exported.\nEach of these different branches can be a different style, in this example shown two different styles are applied, and the third style has a custom selection. All of the styles are the result of the same data manipulation.\nThe node graph in between can be as complex as you want to make it, as long as there is a continuous connection to the output of the geometry, it should produce a result.\n\n\n\nAn example of a more complex node graph, with multiple branches that diverge and come back together.\n\n\nCombining multiple different nodes you can create protein models and complex 3D scenes. In the example below, there is a node tree which should be present on every new structure imported via MolecularNodes. The atoms and bonds are passed in from the left, the atoms are given a colour based on their element and their chain_id, and then the atoms are styled as atoms, scaling the atom radii to 1.00.\nThe data flows through the node tree from left to right, along the bright green lines. The atomic data comes in, goes through layers of manipulation, a style is applied, and the created geometry is then outputted from the node tree.\n\nEditing the Styles\nTo change how each style looks, you can edit the default values of the nodes. By changing the values, you change the numbers that are used in the creation of the 3D models. The style will only change if it is being output through the node tree. You can click and drag to change the values smoothly. You can hold Shift while dragging the values to change them more accurately.\n\n\nVideo\nTweaking the default values of the styles.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Fetch from the PDB"
    ]
  },
  {
    "objectID": "tutorials/importing.html#combining-styles",
    "href": "tutorials/importing.html#combining-styles",
    "title": "Fetch from the PDB",
    "section": "Combining Styles",
    "text": "Combining Styles\nTo complete this tutorial, we will combine the use of Selection and Join Geometry to create a style which shows the side chains as ball and stick while also showing the cartoon style.\nThe style should usually be the last node that you apply to a model. You can’t apply a style after another style, as the output of a style is 3D geometry and not ‘atom-like’ geometry. Instead, we can combine two styles with a Join Geometry node. That way, we create both styles in parallel and then join them together before outputting them all through the Group Output node.\nThe node can be found under Geometry or by going through the search for Join Geometry\n\n\nVideo\nAdding a Join Geometry node.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Fetch from the PDB"
    ]
  },
  {
    "objectID": "tutorials/importing.html#selections",
    "href": "tutorials/importing.html#selections",
    "title": "Fetch from the PDB",
    "section": "Selections",
    "text": "Selections\nMany nodes will have a Selection input, which you can’t manually edit. This input is a Boolean attribute and says whether or not to apply an operation to atoms based on if the value is True or False.\nYou can use selections via the Molecular Nodes -&gt; Selection menu. In this example we use the Backbone node to select atoms based on if they are part of the backbone, the side chain, or just alpha carbons.\nYou can see as we connect different outputs from the Backbone node, we get different results in the final style.\n\n\nVideo\nChanging selections for the Ball and Stick style.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Fetch from the PDB"
    ]
  },
  {
    "objectID": "tutorials/trajectories.html",
    "href": "tutorials/trajectories.html",
    "title": "Trajectories",
    "section": "",
    "text": "Video\n\n\nFigure 1: The protein adenylate kinase (AdK) undergoes a structural change during its catalytic cycle between a closed and an open state that is captured in enhanced sampling simulations (Seyler et al. 2015). The protein secondary structure is shown as a round ribbon with individual amino acid sidechains as ball-and-sticks. The trajectory was rendered with Blender and the MolecularNodes plugin (Brady Johnston). Trajectory files are available via MDAnalysisData Copyright CC-BY 2023 Brady Johnston.\nAs well as importing static structures, the results from molecular dynamics simulations can be imported as models in to Blender. This is enabled through the excellent package MDAnalysis. The imported structure will have an object created that will act as the topology file, and a connection is maintained the underlying MDAnalysis.Universe object that provides coordinates and allows for dynamic calculations to be performed during playback.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Trajectories"
    ]
  },
  {
    "objectID": "tutorials/trajectories.html#md-trajectory-panel",
    "href": "tutorials/trajectories.html#md-trajectory-panel",
    "title": "Trajectories",
    "section": "MD Trajectory Panel",
    "text": "MD Trajectory Panel\nTo import trajectories, change the import method in the Molecular Nodes panel to the MD method. To import a trajectory, select the topology and trajectory files. You can choose the initial starting style, but this can easily be changed after import.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Trajectories"
    ]
  },
  {
    "objectID": "tutorials/trajectories.html#import-the-trajectory",
    "href": "tutorials/trajectories.html#import-the-trajectory",
    "title": "Trajectories",
    "section": "Import the Trajectory",
    "text": "Import the Trajectory\nClick Load to import the selected trajectory with the chosen options. The model will appear in the scene, and when the Frame changes inside of Blender, the corresponding frame will be displayed from the imported trajectory.\n\nChanging Style\nTo change which style is displayed, you have to interact with the Geometry Nodes,you use the same Geometry Nodes tree that you use for other structures. Adding new style nodes and specifying their selections to limit limit the style to particular selections of atoms.\n\n\nSubframes\nBy default each frame on Blender’s timeline corresponds to the frame in the imported trajectory. You can increase the Subframes number for this trajectory, and the selected number of frames will be created in between the frames of the loaded trajectory. If Interpolate is selected, the positions will be linearly interpolated between the frames of the trajectory. If subframes are used, the frames of the trajectory will no longer directly correspond to the frames inside of Blender. With 2 subframes, frame 9 inside of Blender will correspond frame 3 of the trajectory.\nWhen linearly interpolating through subframes of a trajectory, we can correct for periodic boundary crossing with the Correct option enabled. This is only available if your simulation box is cubic.\n\n\nCustom Selections\nCreating selections through nodes is a very quick and powerful way of working. It can be easier to create selections through text, and some niche selections are currently unable to created through the node system.\nWith Trajectory object selected, in the Object tab in the molecular nodes panel, we can create custom selections using the MDAnalysis selection language. These selections will become available inside of the Geometry Nodes tree as a Named Attribute.\nThere are toggles for these selections to be updating and / or periodic in how they are calculated. These options correspond directly to the options that are possible through the MDAnalysis.Universe.select_atoms() method for creating atom groups.\nUse the Named Attribute or Select Attribute nodes to get access to these selections inside of Geometry Nodes, and use them to selectively apply styles, colors and animations to your trajectory.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Trajectories"
    ]
  },
  {
    "objectID": "tutorials/trajectories.html#creating-the-animation",
    "href": "tutorials/trajectories.html#creating-the-animation",
    "title": "Trajectories",
    "section": "Creating the Animation",
    "text": "Creating the Animation\nTo replicate the animation which we see at the top of the tutorial, we can use some of the example datasets which are provided alongside MDAnalysis with the MDAnalysisData package. To download one of the datasets, use the code below:\n# pip install MDAnalysisData\nfrom MDAnalysisData import datasets\ndatasets.fetch_adk_transitions_FRODA()\n\nLoading the Trajectory\nWe will load the trajectory, and load all of the frame sin to memory to ensure we can make a smoother trajectory.\nIn the video below we have imported the trajectory, and we can adjust the number of frames in the scene, as well as the number of frames the trajectory will play back over. We also enabled EEVEE atoms to display in the EEVEE render engine.\nVideo\n\nChanging Styles\nWe can change the style of the imported trajectory, by adding a new style node. We can combine styles with the Join Geometry. For more details on adding styles, see the importing tutorial.\nVideo\nWe can apply the atoms style, only to the side chains of the protein, by using the Backbone selection node, and using the is_side_chain output. This selectively applies the style to only those atoms in the selection. The combined styles now contain only the atoms for the side chains and a continuous ribbon for the protein.\nVideo\n\n\n\nSetting the Scene\nWe can set up the scene a bit nicer with a backdrop. In this case we create a plane using Shift + A to add a plane, go in to edit mode and extrude the backbdrop up with the E key. We can create a slightly curved corner by bevelling the corner. Select the two vertices of the edge and click Ctrl + B. Move the mouse and use the scroll wheel to adjust the settings, then left click to apply.\nVideo\n\n\nRendering the Animation\nWe can change some final settings of the style, do a test Render Image, change the export settings for where the frames of the animation are going to be saved, then we can click Render Animation to render all of the frames of the animation.\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Trajectories"
    ]
  },
  {
    "objectID": "tutorials/simulation.html",
    "href": "tutorials/simulation.html",
    "title": "Simulation",
    "section": "",
    "text": "Video\n\n\nFigure 1: 9I2R Simulated with the elastic network created from alpha carbons and some gentle brownian motion.\nInside of Geometry Nodes, we can run simulations using the Simulation Zone. In the most simple form, a simulation is just doing something with data from a previous iteration of the data. The easiest example of this is moving the positions of some points, building on top of the previous positions of the point from earlier time points.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Simulation"
    ]
  },
  {
    "objectID": "tutorials/simulation.html#simulate-elastic-network",
    "href": "tutorials/simulation.html#simulate-elastic-network",
    "title": "Simulation",
    "section": "Simulate Elastic Network",
    "text": "Simulate Elastic Network\n\n\n\nVideo\n\n\nFigure 2: With the right settings, we can emulate structural dynamics quite convincingly. 2TPR is an NMR structure with a small ordered and small intrinsically disordered region.\n\n\n\nThis node simulates the edges of a mesh. It’s intended for simulating an elastic network, but any mesh that is passed in will be simulated. By default the starting length of the edges be used as the rest length and the simulation will attempt to keep the edges at that length.\nIn the below examble, we create an elastic network between the alpha carbons of a protein structure, then use the node to simulate the network. This can then be styled using the Style Ribbon node, which only requires the alpha carbons of a structure to work.\nChanging the Alpha Carbon value for the Build Elastic Network node increases the search distance. More edges are created leading to more structural stability, but also more computational cost.\nVideo\n\nAll-atom Simulation\nWe can create an elastic network that includes all atoms by selecting the All Atom enum for the Build Elastic Network node. The Alpha Carbon input will still be used for building a network between the alpha carbons for overall structure stability, but the All Atom input will be used for building a shorter-range network between all atoms.\nWe can’t just use the Style Ball and Stick node because the edges are now between all of the atoms. Instead, we can sample the positions from the resulting simulation using the Sample Position node update the positions of our starting atoms using the Set Position node. Then we can style accordingly.\n\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Simulation"
    ]
  },
  {
    "objectID": "tutorials/simulation.html#simulate-curve",
    "href": "tutorials/simulation.html#simulate-curve",
    "title": "Simulation",
    "section": "Simulate Curve",
    "text": "Simulate Curve\nThis is the simplest simulation nodes, which simulates any Curve geometry that it is given, attempting to maintain the length between points of the curve and also handling point collisions.\nThe simplest inputs for this simulation are Points which indicate how many points on the curve before and after this current point to check when trying to maintain length, and also the Straightness which is a value between 0 and 1 that determines how straight the curve should be.\nVideo\nVideo\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Simulation"
    ]
  },
  {
    "objectID": "tutorials/simulation.html#simulate-on-faces",
    "href": "tutorials/simulation.html#simulate-on-faces",
    "title": "Simulation",
    "section": "Simulate on Faces",
    "text": "Simulate on Faces\nThis node simulates points with collisions, while also ensuring they remain attached to the faces of a mesh. It’s intended for simulating membranes or something similar, where points need to collide side to side, but you can input and shape mesh and it will ensure the points stay attached to it.\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Simulation"
    ]
  },
  {
    "objectID": "tutorials/simulation.html#node-inputs",
    "href": "tutorials/simulation.html#node-inputs",
    "title": "Simulation",
    "section": "Node Inputs",
    "text": "Node Inputs\n\nSubsteps\nThe number of substeps that are simulated for each frame that Blender advances. Usually the higher this number the more accurate the simulation is, but this currently isn’t always the case.\n\n\nSimulation\n\nForce\nForces used inside of the simulation are input here as a field that is evaluated on the Point domain.\n\n\nDrag\nThe drag value is a multiplier for the velocity of the point. The higher the drag value, the more the point will slow down. Useful to take the energy out of an otherwise unstable simulation.\n\n\nAlpha\nA value for how rigid the constraint is. The higher the value, the looser the constraint. 0 will try to perfectly maintain the constraint. Even very small values such as 0.001 will lead to a more relaxed constraint. Relaxing constraints can help with simulation stability.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Simulation"
    ]
  },
  {
    "objectID": "tutorials/simulation.html#forces",
    "href": "tutorials/simulation.html#forces",
    "title": "Simulation",
    "section": "Forces",
    "text": "Forces\nForces inside of the simulation are a Vector field that is evaluated on the Point domain. You can chain multiple forces together by using a Vector Math node to just add the outputs, or by puting the Force output of one node into the Add input of the next node in the chain.\n\n\n\n\n\n\nFigure 3: You can chain multiple force nodes together to build up a more complex simulation.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Simulation"
    ]
  },
  {
    "objectID": "tutorials/simulation.html#hook-pin",
    "href": "tutorials/simulation.html#hook-pin",
    "title": "Simulation",
    "section": "Hook & Pin",
    "text": "Hook & Pin\nSometimes we don’t want points to be simulated, and instead we want to manually specify their positions. This is done via the Hook and Pin inputs. Pin will stop the point from simulating at all and ensure that the points is always exactly at the Target input. This will default to whatever the current position of the point is inside of the simulation when Selection is set to true. To get an updating position, you can use the Sample Position node to sample the position of a point in the simulation and then use that as the Target input.\nFor the Hook inputs, it will move the point to the Target over a certain amount of time, essentially exerting a force but one that is more stable. The higher the Decay value the quicker the rate of movement.\n\n\n\n\n\n\nFigure 4: The inputs for hooking & pinning points in a simulation",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Simulation"
    ]
  },
  {
    "objectID": "tutorials/interface.html",
    "href": "tutorials/interface.html",
    "title": "Blender’s Interface",
    "section": "",
    "text": "Blender has a very overwhelming interface. There is no getting around this. Blender can do practically anything, and it is sometimes hard to do simple things.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Blender's Interface"
    ]
  },
  {
    "objectID": "tutorials/interface.html#transforming-objects",
    "href": "tutorials/interface.html#transforming-objects",
    "title": "Blender’s Interface",
    "section": "Transforming Objects",
    "text": "Transforming Objects\nThe main difference is that you can also manipulate the 3D scene in front of you. You can select objects with a left click of the mouse LMB, and move them around by Grabbing them with the G key.\nThe main actions that you use the 3D Viewport for are:\n\n\nG - Grabbing: Moving an object around in 3D space.\nS - Scaling: Changing the relative size of an object.\nR - Rotating: Rotating the object in 3D space.\n\nVideo\n\nLocking to an Axis\nWhen transforming by grabbing, rotating or scaling, you can lock the transformation to a particular axis. Click X / Y / Z after starting the transformation to lock it to those axes, or Shift + X / Y / Z to lock the transformation to be perpendicular to that axis.\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Blender's Interface"
    ]
  },
  {
    "objectID": "tutorials/interface.html#rendered-view",
    "href": "tutorials/interface.html#rendered-view",
    "title": "Blender’s Interface",
    "section": "Rendered View",
    "text": "Rendered View\nBy default you start in 3D View, which is characterised by everything being gray and not rendered properly.\nYou can change to the different views via the render view buttons, or by holding Z and selecting one of the options.\nEach of the views are useful in their own way. If you have a powerful enough computer, you can spend the majority of your time in either Rendered or Material Preview view which will ensure everything is shaded and lighting is calculated. If a scene is becoming complex and your computer is slow, you can switch back to 3D View which should improve performance.\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Blender's Interface"
    ]
  },
  {
    "objectID": "tutorials/interface.html#rendering-engines",
    "href": "tutorials/interface.html#rendering-engines",
    "title": "Blender’s Interface",
    "section": "Rendering Engines",
    "text": "Rendering Engines\nAlready there are different ways to view the scene, through the ‘rendered view’ and the other methods. Even with the option of rendered view, there are multiple different rendering engines. Two rendering engines come pre-installed with Blender, with the possibility to use more. The two rendering engines that come pre-installed are Eevee and Cycles. By default Eevee is enabled, but you can change to Cycles in the Render Properties tab.\nEevee is much faster and more responsive than Cycles, but a lot of the time doesn’t ‘look as nice’. Eevee is a real-time rendering engine built for performance and interactivity, while Cycles is a path-traced rendering engine built for physically accurate light calculations. This is much slower to calculate but often results in ‘nicer’ lighting. Both rendering engines are excellent and are helpful in different scenarios depending on the desired outcomes.\nThe default style Atoms Cycles inside of Molecular Nodes is only visible inside of Cycles for performance reasons. All other styles are visible inside of both rendering engines. If your atoms seem to be invisible, check the rendering engine and style that you are using.\n\nIf you have the option available, ensure to switch to GPU Compute instead of CPU when using the Cycles render engine. This will usually always be the better option, and the perforamnce will be much better.\n\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Blender's Interface"
    ]
  },
  {
    "objectID": "tutorials/interface.html#adding-objects",
    "href": "tutorials/interface.html#adding-objects",
    "title": "Blender’s Interface",
    "section": "Adding Objects",
    "text": "Adding Objects\nYou can add new objects by Shift + A or by using the Add menu in the top left.\nThere are a number of different object types that can be added. The most common that you will use will be Mesh and Light. Try adding some new objects, Grabbing them to move them around, Rotating them and Scaling them to different sizes. If you have just added a new object and it isn’t immediately visible, it might be inside another object, or it could be too big or too small to be immediately visible. Try moving the camera or the object around to get a better view.\n\n\n\nThe add menu. Also accesible through Shift + A\n\n\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Blender's Interface"
    ]
  },
  {
    "objectID": "tutorials/interface.html#rendering-an-image",
    "href": "tutorials/interface.html#rendering-an-image",
    "title": "Blender’s Interface",
    "section": "Rendering an Image",
    "text": "Rendering an Image\nTo render an image, you can click F12 or use the Render -&gt; Render Image menu. Blender will not render what you are immediately seeing. Instead, it will render whatever the Camera** is seeing. This can be frustrating at first, but it makes sense when you can have multiple cameras in a single scene.\nTo see what the camera sees, you can click the Camera widget in the top right, or click backtick (`) + 1.\n\nThe backtick is directly under the Esc key on most American / Enlgish keyboards. It can vary in other language layouts.\n\nVideo\nOnce you are happy with the camera framing, click render.\n\n\n\nThe render menu.\n\n\nA window should appear, showing the rendered image. Isn’t it magnificent?\nThe rendered image is not saved. You have to manually save the image by clicking Image -&gt; Save As and choose where to save the image.\n\n\n\nThe rendered image window.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Blender's Interface"
    ]
  },
  {
    "objectID": "tutorials/interface.html#add-more-lights",
    "href": "tutorials/interface.html#add-more-lights",
    "title": "Blender’s Interface",
    "section": "Add More Lights",
    "text": "Add More Lights\nWe can make our 3D scene more interesting by adding more lights. When the light object is selected, the green Light Settings tab becomes available, appearing as a small green lightbulb. Under these settings, we can change the colour of our light, along with the Power. Try tweaking these settings to your liking. You can duplicate an object without adding a new one by clicking Shift + D.\n\n\nVideo\nAdding more lights to the scene.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Blender's Interface"
    ]
  },
  {
    "objectID": "tutorials/interface.html#materials",
    "href": "tutorials/interface.html#materials",
    "title": "Blender’s Interface",
    "section": "Materials",
    "text": "Materials\nOne of the hardest things to get used to while working in 3D is the idea of materials. What if we want to make the monkey head Red? In 3D we can’t just make things red. Instead we have to assign it a material. This material can have the property that it is primarily red, but it is also metallic, has a sheen, reflects light, can be partially transparent as well as a whole range of other properties.\nComplex shading is an entire career itself, so we won’t get too much in to it. In this example we will just add a material to the monkey to make it red, and a different material to the cube to make it blue.\n\nIf you can’t see the colors changing, ensure you are in Rendered view.\n\nIn the example below, we create a new material called Material.001 for the monkey which we change to red. The cube already has a material called Material. We change the material being used to the monkey’s material, before changing it back and editing the starting material so that it is blue.\nTry playing around with some of the other material settings, to see what effects you can create.\n\n\nVideo\nAssigning materials to objects.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Blender's Interface"
    ]
  },
  {
    "objectID": "tutorials/interface.html#edit-mode",
    "href": "tutorials/interface.html#edit-mode",
    "title": "Blender’s Interface",
    "section": "Edit Mode",
    "text": "Edit Mode\nThe last thing to be aware of when working inside of a 3D program like Blender, is that you can manually edit the 3D objects that are inside of the scene. In the top left hand corner of the 3D viewport. With an object selected, you can change between the different modes. You can edit the physical shape of a mesh, by moving individual or groups of vertices, by going into Edit Mode. You can also use the keyboard shortcut Tab\n\n\n\nThe different modes are available when an object is selected.\n\n\nWith a mesh object selected, you can change in to edit mode. While in edit mode, different options are available to you, and you can phsyically edit the mesh. Try selecting some vertices of the mesh and moving them around individually.\n\n\nVideo\nExample of entering edit mode.\n\n\nYou now know the very basics of adding new objects, changing the materials, adding some lights and rendering an image. The same principles apply to everything that you you do in Blender, and often all of the different workspaces will contain similar keyboard shortcuts and ways of working. Try playing around some more inside of the 3D scene, rendering some different 3D images, before moving on to the section which includes actual proteins.\nMost things are best learnt by doing, so load some proteins in and try to follow along with the other tutorials.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Blender's Interface"
    ]
  },
  {
    "objectID": "api/reference/StyleCartoon.html",
    "href": "api/reference/StyleCartoon.html",
    "title": "StyleCartoon",
    "section": "",
    "text": "StyleCartoon(\n    quality=2,\n    peptide_dssp=False,\n    peptide_cylinders=False,\n    peptide_arrows=True,\n    peptide_rounded=False,\n    peptide_thickness=0.6,\n    peptide_width=2.2,\n    peptide_loop_radius=0.3,\n    peptide_smoothing=0.5,\n    backbone_shape='Cylinder',\n    nucleic_width=3.0,\n    nucleic_thickness=1.0,\n    nucleic_radius=2.0,\n    base_shape='Rectangle',\n    base_realize=False,\n    color_blur=True,\n    shade_smooth=True,\n)\nStyle class for Style Cartoon\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquality\nint\nA lower value results in less geometry, with a higher value meaning better looking but more dense geometry\n2\n\n\npeptide_dssp\nbool\nUse the DSSP algorithm to compute the sec_struct attribute\nFalse\n\n\npeptide_cylinders\nbool\nUse cylinders for helices instead of ribbons\nFalse\n\n\npeptide_arrows\nbool\nUser arrows for sheets\nTrue\n\n\npeptide_rounded\nbool\nCreate rounded sheets and helices\nFalse\n\n\npeptide_thickness\nfloat\nThickness for the sheets and helices\n0.6\n\n\npeptide_width\nfloat\nWidth for the sheets and helices\n2.2\n\n\npeptide_loop_radius\nfloat\nRadius of the loops for unstructure regions\n0.3\n\n\npeptide_smoothing\nfloat\nSmoothing to apply to sheets\n0.5\n\n\nbackbone_shape\nAny\nValue for Backbone Shape\n'Cylinder'\n\n\nnucleic_width\nfloat\nValue for Nucleic Width\n3.0\n\n\nnucleic_thickness\nfloat\nValue for Nucleic Thickness\n1.0\n\n\nnucleic_radius\nfloat\nValue for Nucleic Radius\n2.0\n\n\nbase_shape\nAny\nValue for Base Shape\n'Rectangle'\n\n\nbase_realize\nbool\nValue for Base Realize\nFalse\n\n\ncolor_blur\nbool\nInterpolate between colors when enabled. When disabled the faces will take their color from their corresponding atom without interpolating\nTrue\n\n\nshade_smooth\nbool\nApply smooth shading to the created geometry\nTrue\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nupdate_style_node\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nStyleCartoon.update_style_node(node_style)\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnode_style\nGeometryNodeGroup\nThe Blender GeometryNodeGroup to update\nrequired",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleCartoon"
    ]
  },
  {
    "objectID": "api/reference/StyleCartoon.html#parameters",
    "href": "api/reference/StyleCartoon.html#parameters",
    "title": "StyleCartoon",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nquality\nint\nA lower value results in less geometry, with a higher value meaning better looking but more dense geometry\n2\n\n\npeptide_dssp\nbool\nUse the DSSP algorithm to compute the sec_struct attribute\nFalse\n\n\npeptide_cylinders\nbool\nUse cylinders for helices instead of ribbons\nFalse\n\n\npeptide_arrows\nbool\nUser arrows for sheets\nTrue\n\n\npeptide_rounded\nbool\nCreate rounded sheets and helices\nFalse\n\n\npeptide_thickness\nfloat\nThickness for the sheets and helices\n0.6\n\n\npeptide_width\nfloat\nWidth for the sheets and helices\n2.2\n\n\npeptide_loop_radius\nfloat\nRadius of the loops for unstructure regions\n0.3\n\n\npeptide_smoothing\nfloat\nSmoothing to apply to sheets\n0.5\n\n\nbackbone_shape\nAny\nValue for Backbone Shape\n'Cylinder'\n\n\nnucleic_width\nfloat\nValue for Nucleic Width\n3.0\n\n\nnucleic_thickness\nfloat\nValue for Nucleic Thickness\n1.0\n\n\nnucleic_radius\nfloat\nValue for Nucleic Radius\n2.0\n\n\nbase_shape\nAny\nValue for Base Shape\n'Rectangle'\n\n\nbase_realize\nbool\nValue for Base Realize\nFalse\n\n\ncolor_blur\nbool\nInterpolate between colors when enabled. When disabled the faces will take their color from their corresponding atom without interpolating\nTrue\n\n\nshade_smooth\nbool\nApply smooth shading to the created geometry\nTrue",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleCartoon"
    ]
  },
  {
    "objectID": "api/reference/StyleCartoon.html#methods",
    "href": "api/reference/StyleCartoon.html#methods",
    "title": "StyleCartoon",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nupdate_style_node\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nStyleCartoon.update_style_node(node_style)\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnode_style\nGeometryNodeGroup\nThe Blender GeometryNodeGroup to update\nrequired",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleCartoon"
    ]
  },
  {
    "objectID": "api/reference/material.Default.html",
    "href": "api/reference/material.Default.html",
    "title": "material.Default",
    "section": "",
    "text": "material.Default\nmaterial.Default(**kwargs)",
    "crumbs": [
      "Reference",
      "Materials",
      "material.Default"
    ]
  },
  {
    "objectID": "api/reference/entities.OXDNA.html",
    "href": "api/reference/entities.OXDNA.html",
    "title": "entities.OXDNA",
    "section": "",
    "text": "entities.OXDNA(\n    universe,\n    name='NewOXDNAObject',\n    world_scale=0.01,\n    create_object=True,\n)\nA class to handle oxDNA trajectory data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuniverse\nMDAnalysis.Universe\nThe MDAnalysis Universe object containing the trajectory data\nrequired\n\n\nworld_scale\nfloat\nScaling factor for the world coordinates, by default 0.01\n0.01\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n_entity_type\nEntityType\nType of the molecular entity\n\n\n_att_names\ntuple\nNames of the attributes to track\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_style\nAdd a visual style to the trajectory.\n\n\ncreate_object\nCreate and initialize Blender object for trajectory.\n\n\nget_view\nGet the 3D bounding box of a selection within the trajectory\n\n\nreset_playback\nSet the playback settings to their default values\n\n\n\n\n\nentities.OXDNA.add_style(\n    style='spheres',\n    color='common',\n    selection=None,\n    material=None,\n    name=None,\n)\nAdd a visual style to the trajectory.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstyle\nbpy.types.GeometryNodeTree | str\nThe style to apply to the trajectory. Can be a GeometryNodeTree or a string identifying a predefined style (e.g., “spheres”, “sticks”, “ball_stick”). Default is “spheres”.\n'spheres'\n\n\ncolor\nstr | None\nThe coloring scheme to apply. Can be “common” (element-based coloring), “chain”, “residue”, or other supported schemes. If None, no coloring is applied. Default is “common”.\n'common'\n\n\nselection\nstr | AtomGroup | None\nApply the style only to atoms matching this selection. Can be: - A string referring to an existing boolean attribute on the trajectory - A AtomGroup object defining a selection criteria - None to apply to all atoms (default)\nNone\n\n\nmaterial\nbpy.types.Material | str | None\nThe material to apply to the styled atoms. Can be a Blender Material object, a string with a material name, or None to use default materials. Default is None.\nNone\n\n\nname\nstr | None\nThe label for this style\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectory\nReturns self for method chaining.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an unsupported style string is passed\n\n\n\n\n\n\nIf a selection is provided, it will be evaluated and stored as a new named attribute on the trajectory with an automatically generated name (sel_N).\n\n\n\n\nentities.OXDNA.create_object(name='NewUniverseObject')\nCreate and initialize Blender object for trajectory.\nCreates mesh, computes attributes, sets up modifiers, registers with MolecularNodes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName for the Blender object\n\"NewUniverseObject\"\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Object\nCreated Blender object\n\n\n\n\n\n\n\nentities.OXDNA.get_view(selection=None, frame=None)\nGet the 3D bounding box of a selection within the trajectory\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselection\nstr | AtomGroup\nA selection phrase or AtomGroup When not specified, the whole entity is considered\nNone\n\n\nframe\nint | None\nFrame number of trajectory to use for calculating bounds. When not specified, current trajectory frame is used\nNone\n\n\n\n\n\n\n\nentities.OXDNA.reset_playback()\nSet the playback settings to their default values",
    "crumbs": [
      "Reference",
      "Entity",
      "entities.OXDNA"
    ]
  },
  {
    "objectID": "api/reference/entities.OXDNA.html#parameters",
    "href": "api/reference/entities.OXDNA.html#parameters",
    "title": "entities.OXDNA",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nuniverse\nMDAnalysis.Universe\nThe MDAnalysis Universe object containing the trajectory data\nrequired\n\n\nworld_scale\nfloat\nScaling factor for the world coordinates, by default 0.01\n0.01",
    "crumbs": [
      "Reference",
      "Entity",
      "entities.OXDNA"
    ]
  },
  {
    "objectID": "api/reference/entities.OXDNA.html#attributes",
    "href": "api/reference/entities.OXDNA.html#attributes",
    "title": "entities.OXDNA",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n_entity_type\nEntityType\nType of the molecular entity\n\n\n_att_names\ntuple\nNames of the attributes to track",
    "crumbs": [
      "Reference",
      "Entity",
      "entities.OXDNA"
    ]
  },
  {
    "objectID": "api/reference/entities.OXDNA.html#methods",
    "href": "api/reference/entities.OXDNA.html#methods",
    "title": "entities.OXDNA",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_style\nAdd a visual style to the trajectory.\n\n\ncreate_object\nCreate and initialize Blender object for trajectory.\n\n\nget_view\nGet the 3D bounding box of a selection within the trajectory\n\n\nreset_playback\nSet the playback settings to their default values\n\n\n\n\n\nentities.OXDNA.add_style(\n    style='spheres',\n    color='common',\n    selection=None,\n    material=None,\n    name=None,\n)\nAdd a visual style to the trajectory.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstyle\nbpy.types.GeometryNodeTree | str\nThe style to apply to the trajectory. Can be a GeometryNodeTree or a string identifying a predefined style (e.g., “spheres”, “sticks”, “ball_stick”). Default is “spheres”.\n'spheres'\n\n\ncolor\nstr | None\nThe coloring scheme to apply. Can be “common” (element-based coloring), “chain”, “residue”, or other supported schemes. If None, no coloring is applied. Default is “common”.\n'common'\n\n\nselection\nstr | AtomGroup | None\nApply the style only to atoms matching this selection. Can be: - A string referring to an existing boolean attribute on the trajectory - A AtomGroup object defining a selection criteria - None to apply to all atoms (default)\nNone\n\n\nmaterial\nbpy.types.Material | str | None\nThe material to apply to the styled atoms. Can be a Blender Material object, a string with a material name, or None to use default materials. Default is None.\nNone\n\n\nname\nstr | None\nThe label for this style\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectory\nReturns self for method chaining.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an unsupported style string is passed\n\n\n\n\n\n\nIf a selection is provided, it will be evaluated and stored as a new named attribute on the trajectory with an automatically generated name (sel_N).\n\n\n\n\nentities.OXDNA.create_object(name='NewUniverseObject')\nCreate and initialize Blender object for trajectory.\nCreates mesh, computes attributes, sets up modifiers, registers with MolecularNodes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName for the Blender object\n\"NewUniverseObject\"\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Object\nCreated Blender object\n\n\n\n\n\n\n\nentities.OXDNA.get_view(selection=None, frame=None)\nGet the 3D bounding box of a selection within the trajectory\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselection\nstr | AtomGroup\nA selection phrase or AtomGroup When not specified, the whole entity is considered\nNone\n\n\nframe\nint | None\nFrame number of trajectory to use for calculating bounds. When not specified, current trajectory frame is used\nNone\n\n\n\n\n\n\n\nentities.OXDNA.reset_playback()\nSet the playback settings to their default values",
    "crumbs": [
      "Reference",
      "Entity",
      "entities.OXDNA"
    ]
  },
  {
    "objectID": "api/reference/material.Squishy.html",
    "href": "api/reference/material.Squishy.html",
    "title": "material.Squishy",
    "section": "",
    "text": "material.Squishy\nmaterial.Squishy(**kwargs)",
    "crumbs": [
      "Reference",
      "Materials",
      "material.Squishy"
    ]
  },
  {
    "objectID": "api/reference/entities.StreamingTrajectory.html",
    "href": "api/reference/entities.StreamingTrajectory.html",
    "title": "entities.StreamingTrajectory",
    "section": "",
    "text": "entities.StreamingTrajectory(\n    universe,\n    name='StreamingTrajectory',\n    create_object=True,\n)\nTrajectory subclass for IMD streaming connections.\nHandles real-time molecular dynamics trajectories streamed via the IMD protocol. Unlike regular trajectories with random frame access, streaming trajectories read frames sequentially as they become available.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuniverse\nMDAnalysis.Universe\nMDAnalysis Universe with IMD reader\nrequired\n\n\nname\nstr\nName for the trajectory object, by default “StreamingTrajectory”\n'StreamingTrajectory'\n\n\ncreate_object\n\nCreate the mesh object to be linked to this trajectory\nTrue\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\natoms\nAll atoms as MDAnalysis AtomGroup.\n\n\nn_frames\nReturn None for streaming trajectories (unknown frame count).\n\n\nstyles\nGet the styles in the tree.\n\n\nuframe\nCurrent frame number in MDAnalysis Universe.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_style\nAdd a visual style to the trajectory.\n\n\ncreate_object\nCreate and initialize Blender object for trajectory.\n\n\nget_view\nGet the 3D bounding box of a selection within the trajectory\n\n\nreset_playback\nSet the playback settings to their default values\n\n\nset_frame\nUpdate trajectory state for scene frame.\n\n\n\n\n\nentities.StreamingTrajectory.add_style(\n    style='spheres',\n    color='common',\n    selection=None,\n    material=None,\n    name=None,\n)\nAdd a visual style to the trajectory.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstyle\nbpy.types.GeometryNodeTree | str\nThe style to apply to the trajectory. Can be a GeometryNodeTree or a string identifying a predefined style (e.g., “spheres”, “sticks”, “ball_stick”). Default is “spheres”.\n'spheres'\n\n\ncolor\nstr | None\nThe coloring scheme to apply. Can be “common” (element-based coloring), “chain”, “residue”, or other supported schemes. If None, no coloring is applied. Default is “common”.\n'common'\n\n\nselection\nstr | AtomGroup | None\nApply the style only to atoms matching this selection. Can be: - A string referring to an existing boolean attribute on the trajectory - A AtomGroup object defining a selection criteria - None to apply to all atoms (default)\nNone\n\n\nmaterial\nbpy.types.Material | str | None\nThe material to apply to the styled atoms. Can be a Blender Material object, a string with a material name, or None to use default materials. Default is None.\nNone\n\n\nname\nstr | None\nThe label for this style\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectory\nReturns self for method chaining.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an unsupported style string is passed\n\n\n\n\n\n\nIf a selection is provided, it will be evaluated and stored as a new named attribute on the trajectory with an automatically generated name (sel_N).\n\n\n\n\nentities.StreamingTrajectory.create_object(name='NewUniverseObject')\nCreate and initialize Blender object for trajectory.\nCreates mesh, computes attributes, sets up modifiers, registers with MolecularNodes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName for the Blender object\n\"NewUniverseObject\"\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Object\nCreated Blender object\n\n\n\n\n\n\n\nentities.StreamingTrajectory.get_view(selection=None, frame=None)\nGet the 3D bounding box of a selection within the trajectory\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselection\nstr | AtomGroup\nA selection phrase or AtomGroup When not specified, the whole entity is considered\nNone\n\n\nframe\nint | None\nFrame number of trajectory to use for calculating bounds. When not specified, current trajectory frame is used\nNone\n\n\n\n\n\n\n\nentities.StreamingTrajectory.reset_playback()\nSet the playback settings to their default values\n\n\n\nentities.StreamingTrajectory.set_frame(frame)\nUpdate trajectory state for scene frame.\nMain entry point called by Blender’s animation system. Updates positions, selections, and calculations with recursion prevention.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nframe\nint\nScene frame number (mapping applied to get Universe frame)\nrequired\n\n\n\n\n\n\nTypically called automatically by frame change handlers, not user code.",
    "crumbs": [
      "Reference",
      "Trajectory",
      "entities.StreamingTrajectory"
    ]
  },
  {
    "objectID": "api/reference/entities.StreamingTrajectory.html#parameters",
    "href": "api/reference/entities.StreamingTrajectory.html#parameters",
    "title": "entities.StreamingTrajectory",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nuniverse\nMDAnalysis.Universe\nMDAnalysis Universe with IMD reader\nrequired\n\n\nname\nstr\nName for the trajectory object, by default “StreamingTrajectory”\n'StreamingTrajectory'\n\n\ncreate_object\n\nCreate the mesh object to be linked to this trajectory\nTrue",
    "crumbs": [
      "Reference",
      "Trajectory",
      "entities.StreamingTrajectory"
    ]
  },
  {
    "objectID": "api/reference/entities.StreamingTrajectory.html#attributes",
    "href": "api/reference/entities.StreamingTrajectory.html#attributes",
    "title": "entities.StreamingTrajectory",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\natoms\nAll atoms as MDAnalysis AtomGroup.\n\n\nn_frames\nReturn None for streaming trajectories (unknown frame count).\n\n\nstyles\nGet the styles in the tree.\n\n\nuframe\nCurrent frame number in MDAnalysis Universe.",
    "crumbs": [
      "Reference",
      "Trajectory",
      "entities.StreamingTrajectory"
    ]
  },
  {
    "objectID": "api/reference/entities.StreamingTrajectory.html#methods",
    "href": "api/reference/entities.StreamingTrajectory.html#methods",
    "title": "entities.StreamingTrajectory",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_style\nAdd a visual style to the trajectory.\n\n\ncreate_object\nCreate and initialize Blender object for trajectory.\n\n\nget_view\nGet the 3D bounding box of a selection within the trajectory\n\n\nreset_playback\nSet the playback settings to their default values\n\n\nset_frame\nUpdate trajectory state for scene frame.\n\n\n\n\n\nentities.StreamingTrajectory.add_style(\n    style='spheres',\n    color='common',\n    selection=None,\n    material=None,\n    name=None,\n)\nAdd a visual style to the trajectory.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstyle\nbpy.types.GeometryNodeTree | str\nThe style to apply to the trajectory. Can be a GeometryNodeTree or a string identifying a predefined style (e.g., “spheres”, “sticks”, “ball_stick”). Default is “spheres”.\n'spheres'\n\n\ncolor\nstr | None\nThe coloring scheme to apply. Can be “common” (element-based coloring), “chain”, “residue”, or other supported schemes. If None, no coloring is applied. Default is “common”.\n'common'\n\n\nselection\nstr | AtomGroup | None\nApply the style only to atoms matching this selection. Can be: - A string referring to an existing boolean attribute on the trajectory - A AtomGroup object defining a selection criteria - None to apply to all atoms (default)\nNone\n\n\nmaterial\nbpy.types.Material | str | None\nThe material to apply to the styled atoms. Can be a Blender Material object, a string with a material name, or None to use default materials. Default is None.\nNone\n\n\nname\nstr | None\nThe label for this style\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectory\nReturns self for method chaining.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an unsupported style string is passed\n\n\n\n\n\n\nIf a selection is provided, it will be evaluated and stored as a new named attribute on the trajectory with an automatically generated name (sel_N).\n\n\n\n\nentities.StreamingTrajectory.create_object(name='NewUniverseObject')\nCreate and initialize Blender object for trajectory.\nCreates mesh, computes attributes, sets up modifiers, registers with MolecularNodes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName for the Blender object\n\"NewUniverseObject\"\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Object\nCreated Blender object\n\n\n\n\n\n\n\nentities.StreamingTrajectory.get_view(selection=None, frame=None)\nGet the 3D bounding box of a selection within the trajectory\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselection\nstr | AtomGroup\nA selection phrase or AtomGroup When not specified, the whole entity is considered\nNone\n\n\nframe\nint | None\nFrame number of trajectory to use for calculating bounds. When not specified, current trajectory frame is used\nNone\n\n\n\n\n\n\n\nentities.StreamingTrajectory.reset_playback()\nSet the playback settings to their default values\n\n\n\nentities.StreamingTrajectory.set_frame(frame)\nUpdate trajectory state for scene frame.\nMain entry point called by Blender’s animation system. Updates positions, selections, and calculations with recursion prevention.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nframe\nint\nScene frame number (mapping applied to get Universe frame)\nrequired\n\n\n\n\n\n\nTypically called automatically by frame change handlers, not user code.",
    "crumbs": [
      "Reference",
      "Trajectory",
      "entities.StreamingTrajectory"
    ]
  },
  {
    "objectID": "api/reference/entities.trajectory.SelectionManager.html",
    "href": "api/reference/entities.trajectory.SelectionManager.html",
    "title": "entities.trajectory.SelectionManager",
    "section": "",
    "text": "entities.trajectory.SelectionManager(trajectory)\nManages atom selections for a trajectory.\nCoordinates between MDAnalysis AtomGroup objects, Blender UI properties, and geometry node attributes. Selections are stored as boolean attributes on the trajectory object for use in geometry nodes.\nThe CollectionProperty is the ‘source of truth’ for managing selections for the trajectory. If an AtomGroup doesn’t have a matching UI Item in the collection property, it will be discarded. New AtomGroup objects are created for new UI Items.\nThe collection is registered and available under mn_trajectory_selections on an object inside of Blender. It can be accessed on this class via :attr:ui_items and individual items via self.ui_items.get('name').\nbpy.types.Object.mn_trajectory_selections = CollectionProperty(\n    type=props.TrajectorySelectionItem\n)\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntrajectory\nTrajectory\nParent trajectory object.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\natomgroups\ndict[str, AtomGroup]\nCached AtomGroup objects keyed by selection name.\n\n\nui_index\nIntObjectMNProperty\nProperty descriptor for current UI selection index.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nag_is_updating\nCheck if an AtomGroup is an UpdatingAtomGroup.\n\n\nag_to_attribute\nConvert and store an AtomGroup as a boolean attribute.\n\n\nfrom_atomgroup\nCreate a selection from an existing MDAnalysis AtomGroup.\n\n\nfrom_string\nCreate a selection from an MDAnalysis selection string.\n\n\nget\nTry and get a selection UI Item by name.\n\n\nremove\nRemove a selection by name or index.\n\n\nui_item_to_ag\nGenerate an AtomGroup from a TrajectorySelectionItem.\n\n\nupdate_attributes\nSynchronize UI items, AtomGroups, and named attributes.\n\n\n\n\n\nentities.trajectory.SelectionManager.ag_is_updating(atomgroup)\nCheck if an AtomGroup is an UpdatingAtomGroup.\nUpdatingAtomGroup objects recalculate their members each frame based on geometric criteria (e.g., distance-based selections).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomgroup\nAtomGroup\nThe atom group to check.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the AtomGroup updates dynamically, False if static.\n\n\n\n\n\n\nUses class name comparison since UpdatingAtomGroup is a subclass of AtomGroup.\n\n\n\n\nentities.trajectory.SelectionManager.ag_to_attribute(ag, name)\nConvert and store an AtomGroup as a boolean attribute.\nConverts an AtomGroup to a boolean mask into the original Universe that would return the selected atoms in the AtomGroup. This array is then stored as a boolean attribute on the mesh that represents the Universe inside of Blender.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nag\nAtomGroup\nThe atom group to convert.\nrequired\n\n\nname\nstr\nName for the attribute.\nrequired\n\n\n\n\n\n\n_ag_to_bool : Helper function that performs the AtomGroup to boolean conversion. update_attributes : Calls this method to sync selections to geometry attributes.\n\n\n\n\nentities.trajectory.SelectionManager.from_atomgroup(atomgroup, *, name=None)\nCreate a selection from an existing MDAnalysis AtomGroup.\nCreate a selection on the Trajectory from an already created AtomGroup rather than just using a string selection input. The selection string displayed is non-editable in the GUI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomgroup\nAtomGroup\nPre-existing AtomGroup (static or updating).\nrequired\n\n\nname\nstr\nName for the selection. Auto-generated if not provided via :meth:_unique_selection_name.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectorySelectionItem\nThe created UI item for the selection with item.from_atomgroup = True.\n\n\n\n\n\n\nSets item.from_atomgroup = True to prevent string editing in UI. The string representation is stored for display purposes only.\n\n\n\nfrom_string : Create selection from MDAnalysis selection string. ag_to_attribute : Called to immediately store the selection as an attribute.\n\n\n\n\nentities.trajectory.SelectionManager.from_string(\n    string,\n    *,\n    updating=True,\n    periodic=True,\n    name=None,\n)\nCreate a selection from an MDAnalysis selection string.\nThis uses the MDAnalysis selection language to create an AtomGroup and stores the selection of which atoms are in the AtomGroup as a boolean attribute on the mesh inside of Blender.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstring\nstr\nMDAnalysis selection string (e.g., \"protein\", \"resid 1-10\").\nrequired\n\n\nupdating\nbool\nIf True, selection potentially updates each frame if required (e.g., distance-based selections). If False, creates a static selection.\nTrue\n\n\nperiodic\nbool\nConsider periodic boundary conditions for geometric selections (e.g., \"around\").\nTrue\n\n\nname\nstr\nName for the selection, used as the attribute name when storing on the mesh. Auto-generated if not provided via :meth:_unique_selection_name.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectorySelectionItem\nThe created UI item for the selection.\n\n\n\n\n\n\nfrom_atomgroup : Create selection from pre-existing AtomGroup. update_attributes : Called after item creation to generate the AtomGroup. _unique_selection_name : Generates unique names when not provided.\n\n\n\n\nentities.trajectory.SelectionManager.get(name)\nTry and get a selection UI Item by name.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName of the UI item to retrieve.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectorySelectionItem or None\nThe matching UI item, or None if no match was found.\n\n\n\n\n\n\n\nentities.trajectory.SelectionManager.remove(value)\nRemove a selection by name or index.\nCleans up the UI item, cached AtomGroup, and geometry attribute. Silently handles cases where attribute or AtomGroup don’t exist.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\nint or str\nSelection name (str) or index (int) in ui_items collection.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf name not found in ui_items or value is neither int nor str.\n\n\n\n\n\n\nupdate_attributes : Automatically removes orphaned AtomGroups.\n\n\n\n\nentities.trajectory.SelectionManager.ui_item_to_ag(item)\nGenerate an AtomGroup from a TrajectorySelectionItem.\nUses the item’s string, updating, and periodic properties to create the corresponding AtomGroup from the trajectory’s Universe.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nitem\nTrajectorySelectionItem\nThe UI item containing selection parameters (string, updating, periodic).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAtomGroup\nAtomGroup (or UpdatingAtomGroup) created from the item’s parameters.\n\n\n\n\n\n\nupdate_attributes : Calls this method to create missing AtomGroups.\n\n\n\n\nentities.trajectory.SelectionManager.update_attributes()\nSynchronize UI items, AtomGroups, and named attributes.\nThis is the core update method called when selections change. The following steps are carried out:\n\nCreates missing AtomGroup objects for UI items\nRemoves orphaned AtomGroup objects with no matching UI item\nCreate new AtomGroup objects when selection strings change on the UI item\nUpdate the named attributes on the mesh for updating or new selections\n\nAny errors in creation are stored as item.message which will be reflected in the UI with a warning and the error message.\n\n\nSkipped when manager is frozen via :class:FrozenUpdates context when creating new UI items.\n\n\n\nui_item_to_ag : Creates AtomGroups from UI items. ag_to_attribute : Stores AtomGroups as geometry attributes. from_string : Calls this after creating UI item.",
    "crumbs": [
      "Reference",
      "Trajectory",
      "entities.trajectory.SelectionManager"
    ]
  },
  {
    "objectID": "api/reference/entities.trajectory.SelectionManager.html#parameters",
    "href": "api/reference/entities.trajectory.SelectionManager.html#parameters",
    "title": "entities.trajectory.SelectionManager",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ntrajectory\nTrajectory\nParent trajectory object.\nrequired",
    "crumbs": [
      "Reference",
      "Trajectory",
      "entities.trajectory.SelectionManager"
    ]
  },
  {
    "objectID": "api/reference/entities.trajectory.SelectionManager.html#attributes",
    "href": "api/reference/entities.trajectory.SelectionManager.html#attributes",
    "title": "entities.trajectory.SelectionManager",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\natomgroups\ndict[str, AtomGroup]\nCached AtomGroup objects keyed by selection name.\n\n\nui_index\nIntObjectMNProperty\nProperty descriptor for current UI selection index.",
    "crumbs": [
      "Reference",
      "Trajectory",
      "entities.trajectory.SelectionManager"
    ]
  },
  {
    "objectID": "api/reference/entities.trajectory.SelectionManager.html#methods",
    "href": "api/reference/entities.trajectory.SelectionManager.html#methods",
    "title": "entities.trajectory.SelectionManager",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nag_is_updating\nCheck if an AtomGroup is an UpdatingAtomGroup.\n\n\nag_to_attribute\nConvert and store an AtomGroup as a boolean attribute.\n\n\nfrom_atomgroup\nCreate a selection from an existing MDAnalysis AtomGroup.\n\n\nfrom_string\nCreate a selection from an MDAnalysis selection string.\n\n\nget\nTry and get a selection UI Item by name.\n\n\nremove\nRemove a selection by name or index.\n\n\nui_item_to_ag\nGenerate an AtomGroup from a TrajectorySelectionItem.\n\n\nupdate_attributes\nSynchronize UI items, AtomGroups, and named attributes.\n\n\n\n\n\nentities.trajectory.SelectionManager.ag_is_updating(atomgroup)\nCheck if an AtomGroup is an UpdatingAtomGroup.\nUpdatingAtomGroup objects recalculate their members each frame based on geometric criteria (e.g., distance-based selections).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomgroup\nAtomGroup\nThe atom group to check.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the AtomGroup updates dynamically, False if static.\n\n\n\n\n\n\nUses class name comparison since UpdatingAtomGroup is a subclass of AtomGroup.\n\n\n\n\nentities.trajectory.SelectionManager.ag_to_attribute(ag, name)\nConvert and store an AtomGroup as a boolean attribute.\nConverts an AtomGroup to a boolean mask into the original Universe that would return the selected atoms in the AtomGroup. This array is then stored as a boolean attribute on the mesh that represents the Universe inside of Blender.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nag\nAtomGroup\nThe atom group to convert.\nrequired\n\n\nname\nstr\nName for the attribute.\nrequired\n\n\n\n\n\n\n_ag_to_bool : Helper function that performs the AtomGroup to boolean conversion. update_attributes : Calls this method to sync selections to geometry attributes.\n\n\n\n\nentities.trajectory.SelectionManager.from_atomgroup(atomgroup, *, name=None)\nCreate a selection from an existing MDAnalysis AtomGroup.\nCreate a selection on the Trajectory from an already created AtomGroup rather than just using a string selection input. The selection string displayed is non-editable in the GUI.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomgroup\nAtomGroup\nPre-existing AtomGroup (static or updating).\nrequired\n\n\nname\nstr\nName for the selection. Auto-generated if not provided via :meth:_unique_selection_name.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectorySelectionItem\nThe created UI item for the selection with item.from_atomgroup = True.\n\n\n\n\n\n\nSets item.from_atomgroup = True to prevent string editing in UI. The string representation is stored for display purposes only.\n\n\n\nfrom_string : Create selection from MDAnalysis selection string. ag_to_attribute : Called to immediately store the selection as an attribute.\n\n\n\n\nentities.trajectory.SelectionManager.from_string(\n    string,\n    *,\n    updating=True,\n    periodic=True,\n    name=None,\n)\nCreate a selection from an MDAnalysis selection string.\nThis uses the MDAnalysis selection language to create an AtomGroup and stores the selection of which atoms are in the AtomGroup as a boolean attribute on the mesh inside of Blender.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstring\nstr\nMDAnalysis selection string (e.g., \"protein\", \"resid 1-10\").\nrequired\n\n\nupdating\nbool\nIf True, selection potentially updates each frame if required (e.g., distance-based selections). If False, creates a static selection.\nTrue\n\n\nperiodic\nbool\nConsider periodic boundary conditions for geometric selections (e.g., \"around\").\nTrue\n\n\nname\nstr\nName for the selection, used as the attribute name when storing on the mesh. Auto-generated if not provided via :meth:_unique_selection_name.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectorySelectionItem\nThe created UI item for the selection.\n\n\n\n\n\n\nfrom_atomgroup : Create selection from pre-existing AtomGroup. update_attributes : Called after item creation to generate the AtomGroup. _unique_selection_name : Generates unique names when not provided.\n\n\n\n\nentities.trajectory.SelectionManager.get(name)\nTry and get a selection UI Item by name.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName of the UI item to retrieve.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectorySelectionItem or None\nThe matching UI item, or None if no match was found.\n\n\n\n\n\n\n\nentities.trajectory.SelectionManager.remove(value)\nRemove a selection by name or index.\nCleans up the UI item, cached AtomGroup, and geometry attribute. Silently handles cases where attribute or AtomGroup don’t exist.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\nint or str\nSelection name (str) or index (int) in ui_items collection.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf name not found in ui_items or value is neither int nor str.\n\n\n\n\n\n\nupdate_attributes : Automatically removes orphaned AtomGroups.\n\n\n\n\nentities.trajectory.SelectionManager.ui_item_to_ag(item)\nGenerate an AtomGroup from a TrajectorySelectionItem.\nUses the item’s string, updating, and periodic properties to create the corresponding AtomGroup from the trajectory’s Universe.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nitem\nTrajectorySelectionItem\nThe UI item containing selection parameters (string, updating, periodic).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAtomGroup\nAtomGroup (or UpdatingAtomGroup) created from the item’s parameters.\n\n\n\n\n\n\nupdate_attributes : Calls this method to create missing AtomGroups.\n\n\n\n\nentities.trajectory.SelectionManager.update_attributes()\nSynchronize UI items, AtomGroups, and named attributes.\nThis is the core update method called when selections change. The following steps are carried out:\n\nCreates missing AtomGroup objects for UI items\nRemoves orphaned AtomGroup objects with no matching UI item\nCreate new AtomGroup objects when selection strings change on the UI item\nUpdate the named attributes on the mesh for updating or new selections\n\nAny errors in creation are stored as item.message which will be reflected in the UI with a warning and the error message.\n\n\nSkipped when manager is frozen via :class:FrozenUpdates context when creating new UI items.\n\n\n\nui_item_to_ag : Creates AtomGroups from UI items. ag_to_attribute : Stores AtomGroups as geometry attributes. from_string : Calls this after creating UI item.",
    "crumbs": [
      "Reference",
      "Trajectory",
      "entities.trajectory.SelectionManager"
    ]
  },
  {
    "objectID": "api/reference/Molecule.html",
    "href": "api/reference/Molecule.html",
    "title": "Molecule",
    "section": "",
    "text": "Molecule(array, reader=None)\nPrimary Molecular Nodes class that coordinates the conversion of structural bioinformatic data into raw Blender data. Most notable the conversion of atoms and bonds into a collection of vertices and lines.\nIt associates the atomic data (the array) with the created 3D model inside of Blender (the object). If multiple conformations are imported, then a frames collection is also instantiated.\nThe named_attribute() and store_named_attribute() methods access and set attributes on object that is in the Blender scene.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nobject\nbpy.types.Object\nThe Blender object representing the molecule.\n\n\nframes\nbpy.types.Collection\nThe Blender collection which holds the objects making up the frames to animate.\n\n\narray\nAtomArray | AtomArrayStack:\nThe numpy array which stores the atomic coordinates and associated attributes.\n\n\nselect\nMoleculeSelector\nA selector object that provides methods for creating atom selections based on various criteria such as atom name, residue type, chain ID, etc. These selections can be used with the add_style method to apply visual styles to specific parts of the molecule.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_style\nAdd a visual style to the molecule.\n\n\nassemblies\nGet the biological assemblies of the molecule.\n\n\ncentre_molecule\nOffset positions to centre the atoms and vertices over either the geometric centroid\n\n\ncreate_object\nCreate a 3D model of the molecule, with one vertex for each atom.\n\n\nfetch\nFetch a molecule from the RCSB database.\n\n\nget_view\nGet the 3D bounding box of the entity object\n\n\nload\nLoad a molecule from a file.\n\n\nset_frame\nUpdate the underlying data to correspond to changes in the scene frame.\n\n\n\n\n\nMolecule.add_style(\n    style='spheres',\n    color='common',\n    selection=None,\n    assembly=False,\n    material=None,\n    name=None,\n)\nAdd a visual style to the molecule.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstyle\nbpy.types.GeometryNodeTree | str\nThe style to apply to the molecule. Can be a GeometryNodeTree or a string identifying a predefined style (e.g., “spheres”, “sticks”, “ball_stick”). Default is “spheres”.\n'spheres'\n\n\ncolor\nstr | None\nThe coloring scheme to apply. Can be “common” (element-based coloring), “chain”, “residue”, or other supported schemes. If None, no coloring is applied. Default is “common”.\n'common'\n\n\nselection\nstr | MoleculeSelector | None\nApply the style only to atoms matching this selection. Can be: - A string referring to an existing boolean attribute on the molecule - A MoleculeSelector object defining a selection criteria - None to apply to all atoms (default)\nNone\n\n\nassembly\nbool\nIf True, set up the style to work with biological assemblies. Default is False.\nFalse\n\n\nmaterial\nbpy.types.Material | str | None\nThe material to apply to the styled atoms. Can be a Blender Material object, a string with a material name, or None to use default materials. Default is None.\nNone\n\n\nname\nstr | None\nThe label for this style\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nMolecule\nReturns self for method chaining.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an unsupported style string is passed\n\n\n\n\n\n\nIf a MoleculeSelector is provided, it will be evaluated and stored as a new named attribute on the molecule with an automatically generated name (sel_N).\n\n\n\n\nMolecule.assemblies(as_array=False)\nGet the biological assemblies of the molecule.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nas_array\nbool\nWhether to return the assemblies as an array of quaternions. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict or None\nThe biological assemblies of the molecule, as a dictionary of transformation matrices, or None if no assemblies are available.\n\n\n\n\n\n\n\nMolecule.centre_molecule(method='centroid')\nOffset positions to centre the atoms and vertices over either the geometric centroid or the centre of mass.\n\n\n\nMolecule.create_object(name='NewObject')\nCreate a 3D model of the molecule, with one vertex for each atom.\n\n\n\nMolecule.fetch(\n    code,\n    format='.bcif',\n    centre=None,\n    remove_solvent=True,\n    cache=download.CACHE_DIR,\n    database='rcsb',\n)\nFetch a molecule from the RCSB database.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncode\nstr\nThe PDB ID code of the molecule to fetch.\nrequired\n\n\nformat\nstr\nThe file format to download. Default is “.bcif”.\n'.bcif'\n\n\ncentre\nstr | None\nMethod to use for centering the molecule. Options are “centroid” (geometric center) or “mass” (center of mass). If None, no centering is performed. Default is None.\nNone\n\n\ncache\nstr\nPath to cache directory. If None, no caching is performed.\ndownload.CACHE_DIR\n\n\nremove_solvent\nbool\nWhether to remove solvent from the molecule. Default is True.\nTrue\n\n\ndatabase\nstr\nThe database to fetch from. Default is “rcsb”.\n'rcsb'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nMolecule\nA new Molecule instance created from the downloaded data.\n\n\n\n\n\n\n\nMolecule.get_view()\nGet the 3D bounding box of the entity object\n\n\n\nMolecule.load(file_path, name=None, remove_solvent=True)\nLoad a molecule from a file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile_path\nstr or Path\nThe path to the file containing molecular data\nrequired\n\n\nname\nstr or None\nThe name to give the molecule object. If None, uses the filename stem\nNone\n\n\nremove_solvent\nbool\nWhether to remove solvent molecules from the structure, default True\nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmol\nMolecule\nThe loaded molecule object with associated data and 3D representation\n\n\n\n\n\n\nSupports various file formats including .cif, .bcif, .pdb, .sdf, and .mol\n\n\n\n\nMolecule.set_frame(frame)\nUpdate the underlying data to correspond to changes in the scene frame.\nThis method should be implemented by subclasses to update the entity’s data based on the given frame number. This can include updating positions and performing other necessary calculations.\nArgs: frame (int): The frame number to update the entity’s data to.\nRaises: NotImplementedError: If the method is not implemented by a subclass.",
    "crumbs": [
      "Reference",
      "Entity",
      "Molecule"
    ]
  },
  {
    "objectID": "api/reference/Molecule.html#attributes",
    "href": "api/reference/Molecule.html#attributes",
    "title": "Molecule",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nobject\nbpy.types.Object\nThe Blender object representing the molecule.\n\n\nframes\nbpy.types.Collection\nThe Blender collection which holds the objects making up the frames to animate.\n\n\narray\nAtomArray | AtomArrayStack:\nThe numpy array which stores the atomic coordinates and associated attributes.\n\n\nselect\nMoleculeSelector\nA selector object that provides methods for creating atom selections based on various criteria such as atom name, residue type, chain ID, etc. These selections can be used with the add_style method to apply visual styles to specific parts of the molecule.",
    "crumbs": [
      "Reference",
      "Entity",
      "Molecule"
    ]
  },
  {
    "objectID": "api/reference/Molecule.html#methods",
    "href": "api/reference/Molecule.html#methods",
    "title": "Molecule",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_style\nAdd a visual style to the molecule.\n\n\nassemblies\nGet the biological assemblies of the molecule.\n\n\ncentre_molecule\nOffset positions to centre the atoms and vertices over either the geometric centroid\n\n\ncreate_object\nCreate a 3D model of the molecule, with one vertex for each atom.\n\n\nfetch\nFetch a molecule from the RCSB database.\n\n\nget_view\nGet the 3D bounding box of the entity object\n\n\nload\nLoad a molecule from a file.\n\n\nset_frame\nUpdate the underlying data to correspond to changes in the scene frame.\n\n\n\n\n\nMolecule.add_style(\n    style='spheres',\n    color='common',\n    selection=None,\n    assembly=False,\n    material=None,\n    name=None,\n)\nAdd a visual style to the molecule.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstyle\nbpy.types.GeometryNodeTree | str\nThe style to apply to the molecule. Can be a GeometryNodeTree or a string identifying a predefined style (e.g., “spheres”, “sticks”, “ball_stick”). Default is “spheres”.\n'spheres'\n\n\ncolor\nstr | None\nThe coloring scheme to apply. Can be “common” (element-based coloring), “chain”, “residue”, or other supported schemes. If None, no coloring is applied. Default is “common”.\n'common'\n\n\nselection\nstr | MoleculeSelector | None\nApply the style only to atoms matching this selection. Can be: - A string referring to an existing boolean attribute on the molecule - A MoleculeSelector object defining a selection criteria - None to apply to all atoms (default)\nNone\n\n\nassembly\nbool\nIf True, set up the style to work with biological assemblies. Default is False.\nFalse\n\n\nmaterial\nbpy.types.Material | str | None\nThe material to apply to the styled atoms. Can be a Blender Material object, a string with a material name, or None to use default materials. Default is None.\nNone\n\n\nname\nstr | None\nThe label for this style\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nMolecule\nReturns self for method chaining.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an unsupported style string is passed\n\n\n\n\n\n\nIf a MoleculeSelector is provided, it will be evaluated and stored as a new named attribute on the molecule with an automatically generated name (sel_N).\n\n\n\n\nMolecule.assemblies(as_array=False)\nGet the biological assemblies of the molecule.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nas_array\nbool\nWhether to return the assemblies as an array of quaternions. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict or None\nThe biological assemblies of the molecule, as a dictionary of transformation matrices, or None if no assemblies are available.\n\n\n\n\n\n\n\nMolecule.centre_molecule(method='centroid')\nOffset positions to centre the atoms and vertices over either the geometric centroid or the centre of mass.\n\n\n\nMolecule.create_object(name='NewObject')\nCreate a 3D model of the molecule, with one vertex for each atom.\n\n\n\nMolecule.fetch(\n    code,\n    format='.bcif',\n    centre=None,\n    remove_solvent=True,\n    cache=download.CACHE_DIR,\n    database='rcsb',\n)\nFetch a molecule from the RCSB database.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncode\nstr\nThe PDB ID code of the molecule to fetch.\nrequired\n\n\nformat\nstr\nThe file format to download. Default is “.bcif”.\n'.bcif'\n\n\ncentre\nstr | None\nMethod to use for centering the molecule. Options are “centroid” (geometric center) or “mass” (center of mass). If None, no centering is performed. Default is None.\nNone\n\n\ncache\nstr\nPath to cache directory. If None, no caching is performed.\ndownload.CACHE_DIR\n\n\nremove_solvent\nbool\nWhether to remove solvent from the molecule. Default is True.\nTrue\n\n\ndatabase\nstr\nThe database to fetch from. Default is “rcsb”.\n'rcsb'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nMolecule\nA new Molecule instance created from the downloaded data.\n\n\n\n\n\n\n\nMolecule.get_view()\nGet the 3D bounding box of the entity object\n\n\n\nMolecule.load(file_path, name=None, remove_solvent=True)\nLoad a molecule from a file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile_path\nstr or Path\nThe path to the file containing molecular data\nrequired\n\n\nname\nstr or None\nThe name to give the molecule object. If None, uses the filename stem\nNone\n\n\nremove_solvent\nbool\nWhether to remove solvent molecules from the structure, default True\nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmol\nMolecule\nThe loaded molecule object with associated data and 3D representation\n\n\n\n\n\n\nSupports various file formats including .cif, .bcif, .pdb, .sdf, and .mol\n\n\n\n\nMolecule.set_frame(frame)\nUpdate the underlying data to correspond to changes in the scene frame.\nThis method should be implemented by subclasses to update the entity’s data based on the given frame number. This can include updating positions and performing other necessary calculations.\nArgs: frame (int): The frame number to update the entity’s data to.\nRaises: NotImplementedError: If the method is not implemented by a subclass.",
    "crumbs": [
      "Reference",
      "Entity",
      "Molecule"
    ]
  },
  {
    "objectID": "api/reference/StyleRibbon.html",
    "href": "api/reference/StyleRibbon.html",
    "title": "StyleRibbon",
    "section": "",
    "text": "StyleRibbon(\n    quality=3,\n    backbone_smoothing=0.5,\n    backbone_threshold=4.5,\n    backbone_radius=1.6,\n    nucleic_backbone_shape='Cylinder',\n    nucleic_backbone_radius=1.6,\n    backbone_width=3.0,\n    backbone_thickness=1.0,\n    base_scale=(2.5, 0.5, 7.0),\n    base_resolution=4,\n    base_realize=False,\n    uv_map=False,\n    u_component='Factor',\n    color_blur=False,\n    shade_smooth=True,\n)\nStyle class for Style Ribbon\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquality\nint\nA lower value results in less geometry, with a higher value meaning better looking but more dense geometry\n3\n\n\nbackbone_smoothing\nfloat\nSmoothen the sheet ribbons such as beta-sheets\n0.5\n\n\nbackbone_threshold\nfloat\nDistance (Angstroms) over which subsequent CA points are treated as a new chain\n4.5\n\n\nbackbone_radius\nfloat\nValue for Backbone Radius\n1.6\n\n\nnucleic_backbone_shape\nAny\nValue for Nucleic Backbone Shape\n'Cylinder'\n\n\nnucleic_backbone_radius\nfloat\nValue for Nucleic Backbone Radius\n1.6\n\n\nbackbone_width\nfloat\nValue for Backbone Width\n3.0\n\n\nbackbone_thickness\nfloat\nValue for Backbone Thickness\n1.0\n\n\nbase_scale\nTuple[float, float, float]\nValue for Base Scale\n(2.5, 0.5, 7.0)\n\n\nbase_resolution\nint\nValue for Base Resolution\n4\n\n\nbase_realize\nbool\nValue for Base Realize\nFalse\n\n\nuv_map\nbool\nCompute and store the uv_map for the final protein ribbon geometry\nFalse\n\n\nu_component\nAny\nValue for U Component\n'Factor'\n\n\ncolor_blur\nbool\nInterpolate between colors when enabled. When disabled the faces will take their color from their corresponding atom without interpolating\nFalse\n\n\nshade_smooth\nbool\nApply smooth shading to the created geometry\nTrue\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nupdate_style_node\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nStyleRibbon.update_style_node(node_style)\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnode_style\nGeometryNodeGroup\nThe Blender GeometryNodeGroup to update\nrequired",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleRibbon"
    ]
  },
  {
    "objectID": "api/reference/StyleRibbon.html#parameters",
    "href": "api/reference/StyleRibbon.html#parameters",
    "title": "StyleRibbon",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nquality\nint\nA lower value results in less geometry, with a higher value meaning better looking but more dense geometry\n3\n\n\nbackbone_smoothing\nfloat\nSmoothen the sheet ribbons such as beta-sheets\n0.5\n\n\nbackbone_threshold\nfloat\nDistance (Angstroms) over which subsequent CA points are treated as a new chain\n4.5\n\n\nbackbone_radius\nfloat\nValue for Backbone Radius\n1.6\n\n\nnucleic_backbone_shape\nAny\nValue for Nucleic Backbone Shape\n'Cylinder'\n\n\nnucleic_backbone_radius\nfloat\nValue for Nucleic Backbone Radius\n1.6\n\n\nbackbone_width\nfloat\nValue for Backbone Width\n3.0\n\n\nbackbone_thickness\nfloat\nValue for Backbone Thickness\n1.0\n\n\nbase_scale\nTuple[float, float, float]\nValue for Base Scale\n(2.5, 0.5, 7.0)\n\n\nbase_resolution\nint\nValue for Base Resolution\n4\n\n\nbase_realize\nbool\nValue for Base Realize\nFalse\n\n\nuv_map\nbool\nCompute and store the uv_map for the final protein ribbon geometry\nFalse\n\n\nu_component\nAny\nValue for U Component\n'Factor'\n\n\ncolor_blur\nbool\nInterpolate between colors when enabled. When disabled the faces will take their color from their corresponding atom without interpolating\nFalse\n\n\nshade_smooth\nbool\nApply smooth shading to the created geometry\nTrue",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleRibbon"
    ]
  },
  {
    "objectID": "api/reference/StyleRibbon.html#methods",
    "href": "api/reference/StyleRibbon.html#methods",
    "title": "StyleRibbon",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nupdate_style_node\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nStyleRibbon.update_style_node(node_style)\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnode_style\nGeometryNodeGroup\nThe Blender GeometryNodeGroup to update\nrequired",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleRibbon"
    ]
  },
  {
    "objectID": "api/reference/material.TransparentOutline.html",
    "href": "api/reference/material.TransparentOutline.html",
    "title": "material.TransparentOutline",
    "section": "",
    "text": "material.TransparentOutline\nmaterial.TransparentOutline(**kwargs)",
    "crumbs": [
      "Reference",
      "Materials",
      "material.TransparentOutline"
    ]
  },
  {
    "objectID": "api/reference/StyleSticks.html",
    "href": "api/reference/StyleSticks.html",
    "title": "StyleSticks",
    "section": "",
    "text": "StyleSticks(quality=3, radius=0.2, color_blur=False, shade_smooth=True)\nStyle class for Style Sticks\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquality\nint\nA lower value results in less geometry, with a higher value meaning better looking but more dense geometry\n3\n\n\nradius\nfloat\nRadius of the sticks in Angstroms\n0.2\n\n\ncolor_blur\nbool\nInterpolate between colors when enabled. When disabled the faces will take their color from their corresponding atom without interpolating\nFalse\n\n\nshade_smooth\nbool\nApply smooth shading to the created geometry\nTrue\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nupdate_style_node\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nStyleSticks.update_style_node(node_style)\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnode_style\nGeometryNodeGroup\nThe Blender GeometryNodeGroup to update\nrequired",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleSticks"
    ]
  },
  {
    "objectID": "api/reference/StyleSticks.html#parameters",
    "href": "api/reference/StyleSticks.html#parameters",
    "title": "StyleSticks",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nquality\nint\nA lower value results in less geometry, with a higher value meaning better looking but more dense geometry\n3\n\n\nradius\nfloat\nRadius of the sticks in Angstroms\n0.2\n\n\ncolor_blur\nbool\nInterpolate between colors when enabled. When disabled the faces will take their color from their corresponding atom without interpolating\nFalse\n\n\nshade_smooth\nbool\nApply smooth shading to the created geometry\nTrue",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleSticks"
    ]
  },
  {
    "objectID": "api/reference/StyleSticks.html#methods",
    "href": "api/reference/StyleSticks.html#methods",
    "title": "StyleSticks",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nupdate_style_node\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nStyleSticks.update_style_node(node_style)\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnode_style\nGeometryNodeGroup\nThe Blender GeometryNodeGroup to update\nrequired",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleSticks"
    ]
  },
  {
    "objectID": "api/reference/StyleSurface.html",
    "href": "api/reference/StyleSurface.html",
    "title": "StyleSurface",
    "section": "",
    "text": "StyleSurface(\n    quality=3,\n    scale_radius=1.5,\n    probe_size=1.0,\n    relaxation_steps=10,\n    separate_by='chain_id',\n    group_id=0,\n    color_source='Alpha Carbon',\n    color_blur=2,\n    shade_smooth=True,\n)\nStyle class for Style Surface\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquality\nint\nA lower value results in less geometry, with a higher value meaning better looking but more dense geometry\n3\n\n\nscale_radius\nfloat\nScale the VDW radii of the atoms when creating the surface\n1.5\n\n\nprobe_size\nfloat\nSize of the probe that is used to check for solvent accessibility (Angstroms)\n1.0\n\n\nrelaxation_steps\nint\nNumber of times smoothening is applied to the generate surface stretched between the atoms\n10\n\n\nseparate_by\nAny\nValue for Separate By\n'chain_id'\n\n\ngroup_id\nint\nValue for Group ID\n0\n\n\ncolor_source\nAny\nValue for Color Source\n'Alpha Carbon'\n\n\ncolor_blur\nint\nInterpolate between colors when enabled. When disabled the faces will take their color from their corresponding atom without interpolating\n2\n\n\nshade_smooth\nbool\nApply smooth shading to the created geometry\nTrue\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nupdate_style_node\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nStyleSurface.update_style_node(node_style)\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnode_style\nGeometryNodeGroup\nThe Blender GeometryNodeGroup to update\nrequired",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleSurface"
    ]
  },
  {
    "objectID": "api/reference/StyleSurface.html#parameters",
    "href": "api/reference/StyleSurface.html#parameters",
    "title": "StyleSurface",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nquality\nint\nA lower value results in less geometry, with a higher value meaning better looking but more dense geometry\n3\n\n\nscale_radius\nfloat\nScale the VDW radii of the atoms when creating the surface\n1.5\n\n\nprobe_size\nfloat\nSize of the probe that is used to check for solvent accessibility (Angstroms)\n1.0\n\n\nrelaxation_steps\nint\nNumber of times smoothening is applied to the generate surface stretched between the atoms\n10\n\n\nseparate_by\nAny\nValue for Separate By\n'chain_id'\n\n\ngroup_id\nint\nValue for Group ID\n0\n\n\ncolor_source\nAny\nValue for Color Source\n'Alpha Carbon'\n\n\ncolor_blur\nint\nInterpolate between colors when enabled. When disabled the faces will take their color from their corresponding atom without interpolating\n2\n\n\nshade_smooth\nbool\nApply smooth shading to the created geometry\nTrue",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleSurface"
    ]
  },
  {
    "objectID": "api/reference/StyleSurface.html#methods",
    "href": "api/reference/StyleSurface.html#methods",
    "title": "StyleSurface",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nupdate_style_node\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nStyleSurface.update_style_node(node_style)\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnode_style\nGeometryNodeGroup\nThe Blender GeometryNodeGroup to update\nrequired",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleSurface"
    ]
  },
  {
    "objectID": "api/reference/entities.trajectory.DSSPManager.html",
    "href": "api/reference/entities.trajectory.DSSPManager.html",
    "title": "entities.trajectory.DSSPManager",
    "section": "",
    "text": "entities.trajectory.DSSPManager(entity)\nDSSP Manager for trajectories\nShow secondary structures computed using MDAnalysis.analysis.dssp\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit\nInitialize DSSP\n\n\nshow_none\nDo not show secondary structures\n\n\nshow_per_frame\nShow secondary structures calculated per frame\n\n\nshow_sliding_window_average\nShow average secondary structures of a sliding window of frames\n\n\nshow_trajectory_average\nShow average secondary structures across all frames\n\n\n\n\n\nentities.trajectory.DSSPManager.init()\nInitialize DSSP\n\n\n\nentities.trajectory.DSSPManager.show_none()\nDo not show secondary structures\n\n\n\nentities.trajectory.DSSPManager.show_per_frame()\nShow secondary structures calculated per frame\n\n\n\nentities.trajectory.DSSPManager.show_sliding_window_average(\n    window_size=5,\n    threshold=None,\n)\nShow average secondary structures of a sliding window of frames\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwindow_size\nint\nSize of the sliding window, default is 5 frames\n5\n\n\nthreshold\nfloat | None\nThreshold to compare the mean against [0.0 - 1.0]. When None, no threshold comparison is made\nNone\n\n\n\n\n\n\n\nentities.trajectory.DSSPManager.show_trajectory_average(threshold=None)\nShow average secondary structures across all frames\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nthreshold\nfloat | None\nThreshold to compare the mean against [0.0 - 1.0]. When None, no threshold comparison is made\nNone",
    "crumbs": [
      "Reference",
      "Trajectory",
      "entities.trajectory.DSSPManager"
    ]
  },
  {
    "objectID": "api/reference/entities.trajectory.DSSPManager.html#methods",
    "href": "api/reference/entities.trajectory.DSSPManager.html#methods",
    "title": "entities.trajectory.DSSPManager",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ninit\nInitialize DSSP\n\n\nshow_none\nDo not show secondary structures\n\n\nshow_per_frame\nShow secondary structures calculated per frame\n\n\nshow_sliding_window_average\nShow average secondary structures of a sliding window of frames\n\n\nshow_trajectory_average\nShow average secondary structures across all frames\n\n\n\n\n\nentities.trajectory.DSSPManager.init()\nInitialize DSSP\n\n\n\nentities.trajectory.DSSPManager.show_none()\nDo not show secondary structures\n\n\n\nentities.trajectory.DSSPManager.show_per_frame()\nShow secondary structures calculated per frame\n\n\n\nentities.trajectory.DSSPManager.show_sliding_window_average(\n    window_size=5,\n    threshold=None,\n)\nShow average secondary structures of a sliding window of frames\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwindow_size\nint\nSize of the sliding window, default is 5 frames\n5\n\n\nthreshold\nfloat | None\nThreshold to compare the mean against [0.0 - 1.0]. When None, no threshold comparison is made\nNone\n\n\n\n\n\n\n\nentities.trajectory.DSSPManager.show_trajectory_average(threshold=None)\nShow average secondary structures across all frames\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nthreshold\nfloat | None\nThreshold to compare the mean against [0.0 - 1.0]. When None, no threshold comparison is made\nNone",
    "crumbs": [
      "Reference",
      "Trajectory",
      "entities.trajectory.DSSPManager"
    ]
  },
  {
    "objectID": "api/reference/entities.density.annotations.html",
    "href": "api/reference/entities.density.annotations.html",
    "title": "entities.density.annotations",
    "section": "",
    "text": "entities.density.annotations\n\n\n\n\n\nName\nDescription\n\n\n\n\nDensityAnnotation\nBase class for a Density Annotation\n\n\nDensityAnnotationManager\nAnnotation Manager for Density Entity\n\n\nDensityGridAxes\nDensity Grid Axes Annotation\n\n\nDensityGridAxes3D\nDensity Grid Axes 3D Annotation\n\n\nDensityInfo\nDensity Info Annotation\n\n\nLabel2D\nCommon Label2D Annotation for all entities\n\n\nLabel3D\nCommon Label3D Annotation for all entities\n\n\n\n\n\nentities.density.annotations.DensityAnnotation(density)\nBase class for a Density Annotation\nAll density annotations should derive from this base class and implement the ‘draw’ method. All derived classes will have access to the density instance (self.density) and all the annotation inputs and common params via self.interface.\nAn optional ‘defaults’ method can be provided to set default values to the annotation.\n\n\n\n\n\nName\nDescription\n\n\n\n\nviewport_height\nGet the viewport region height in pixels\n\n\nviewport_width\nGet the viewport region width in pixels\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndefaults\nOptional method to set default annotation params\n\n\ndistance\nDistance between two vectors\n\n\ndraw\nThe main draw method for an annotation\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\nvalidate\nOptional method to validate annotation inputs\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.defaults()\nOptional method to set default annotation params This is called only once when the annotation instance is created\n\n\n\nentities.density.annotations.DensityAnnotation.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw()\nThe main draw method for an annotation This is called multiple times in the 3D viewport draw handler\n\n\n\nentities.density.annotations.DensityAnnotation.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.validate(input_name=None)\nOptional method to validate annotation inputs This is called during annotation creation and any time the inputs change either through the API or GUI. Can return False or raise an exception when validation fails. Returns True when all validations succeed.\nNote: This method gets called when any inputs change, so updating values in here will lead to a recursive loop and should not be done.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_name\nstr\nThe input name update that trigged this validation callback. When no specific input name is available, None is passed.\nNone\n\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotationManager(entity)\nAnnotation Manager for Density Entity\n\n\n\n\n\nName\nDescription\n\n\n\n\nvisible\nVisibility of all annotations - getter\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nclear\nRemove all annotations\n\n\nget\nGet an annotation by name\n\n\nregister_class\nRegister an annotation class\n\n\nremove\nRemove an annotation by name or instance\n\n\nunregister_type\nUnregister a registered annotation type\n\n\n\n\n\nentities.density.annotations.DensityAnnotationManager.clear()\nRemove all annotations\n\n\n\nentities.density.annotations.DensityAnnotationManager.get(name)\nGet an annotation by name\n\n\n\nentities.density.annotations.DensityAnnotationManager.register_class(\n    annotation_class,\n)\nRegister an annotation class\nThis method adds the annotation class to the entity specific class registry (classes) and adds a new method (add) to the manager with a signature that matches the annotation inputs.\n\n\n\nentities.density.annotations.DensityAnnotationManager.remove(annotation)\nRemove an annotation by name or instance\nWhen a name is used, all annotations that match the name will be removed\n\n\n\nentities.density.annotations.DensityAnnotationManager.unregister_type(\n    annotation_type,\n)\nUnregister a registered annotation type\nThis method removes the annotation type from the entity speicific class registry and removes the ‘add_&lt;&gt;’ method from the manager\n\n\n\n\n\nentities.density.annotations.DensityGridAxes(density)\nDensity Grid Axes Annotation\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nshow_length\nbool\nWhether or not to show the length of the grid axes\n\n\nunits\nstr\nUnits to use for length. Default: Å\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\nvalidate\nOptional method to validate annotation inputs\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.validate(input_name=None)\nOptional method to validate annotation inputs This is called during annotation creation and any time the inputs change either through the API or GUI. Can return False or raise an exception when validation fails. Returns True when all validations succeed.\nNote: This method gets called when any inputs change, so updating values in here will lead to a recursive loop and should not be done.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_name\nstr\nThe input name update that trigged this validation callback. When no specific input name is available, None is passed.\nNone\n\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D(density)\nDensity Grid Axes 3D Annotation\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nshow_length\nbool\nWhether or not to show the length of the grid axes\n\n\nunits\nstr\nUnits to use for length. Default: Å\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\nvalidate\nOptional method to validate annotation inputs\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.validate(input_name=None)\nOptional method to validate annotation inputs This is called during annotation creation and any time the inputs change either through the API or GUI. Can return False or raise an exception when validation fails. Returns True when all validations succeed.\nNote: This method gets called when any inputs change, so updating values in here will lead to a recursive loop and should not be done.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_name\nstr\nThe input name update that trigged this validation callback. When no specific input name is available, None is passed.\nNone\n\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo(density)\nDensity Info Annotation\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlocation\ntuple[float, float]\nNormalized coordinates (0.0 - 1.0) of the postion in viewport / render\n\n\nshow_filename\nbool\nWhether or not to show the grid filename\n\n\nshow_threshold\nbool\nWhether or not to show the current threshold value\n\n\nshow_origin\nbool\nWhether or not to show the grid origin\n\n\nshow_delta\nbool\nWhether or not to show the grid delta\n\n\nshow_shape\nbool\nWhether or not to show the grid shape\n\n\ncustom_text\nstr\nAny custom text to add at the end of the annotation\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.density.annotations.DensityInfo.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\n\n\nentities.density.annotations.Label2D()\nCommon Label2D Annotation for all entities\n\n\n\nentities.density.annotations.Label3D()\nCommon Label3D Annotation for all entities",
    "crumbs": [
      "Reference",
      "Annotations",
      "entities.density.annotations"
    ]
  },
  {
    "objectID": "api/reference/entities.density.annotations.html#classes",
    "href": "api/reference/entities.density.annotations.html#classes",
    "title": "entities.density.annotations",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nDensityAnnotation\nBase class for a Density Annotation\n\n\nDensityAnnotationManager\nAnnotation Manager for Density Entity\n\n\nDensityGridAxes\nDensity Grid Axes Annotation\n\n\nDensityGridAxes3D\nDensity Grid Axes 3D Annotation\n\n\nDensityInfo\nDensity Info Annotation\n\n\nLabel2D\nCommon Label2D Annotation for all entities\n\n\nLabel3D\nCommon Label3D Annotation for all entities\n\n\n\n\n\nentities.density.annotations.DensityAnnotation(density)\nBase class for a Density Annotation\nAll density annotations should derive from this base class and implement the ‘draw’ method. All derived classes will have access to the density instance (self.density) and all the annotation inputs and common params via self.interface.\nAn optional ‘defaults’ method can be provided to set default values to the annotation.\n\n\n\n\n\nName\nDescription\n\n\n\n\nviewport_height\nGet the viewport region height in pixels\n\n\nviewport_width\nGet the viewport region width in pixels\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndefaults\nOptional method to set default annotation params\n\n\ndistance\nDistance between two vectors\n\n\ndraw\nThe main draw method for an annotation\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\nvalidate\nOptional method to validate annotation inputs\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.defaults()\nOptional method to set default annotation params This is called only once when the annotation instance is created\n\n\n\nentities.density.annotations.DensityAnnotation.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw()\nThe main draw method for an annotation This is called multiple times in the 3D viewport draw handler\n\n\n\nentities.density.annotations.DensityAnnotation.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotation.validate(input_name=None)\nOptional method to validate annotation inputs This is called during annotation creation and any time the inputs change either through the API or GUI. Can return False or raise an exception when validation fails. Returns True when all validations succeed.\nNote: This method gets called when any inputs change, so updating values in here will lead to a recursive loop and should not be done.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_name\nstr\nThe input name update that trigged this validation callback. When no specific input name is available, None is passed.\nNone\n\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityAnnotationManager(entity)\nAnnotation Manager for Density Entity\n\n\n\n\n\nName\nDescription\n\n\n\n\nvisible\nVisibility of all annotations - getter\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nclear\nRemove all annotations\n\n\nget\nGet an annotation by name\n\n\nregister_class\nRegister an annotation class\n\n\nremove\nRemove an annotation by name or instance\n\n\nunregister_type\nUnregister a registered annotation type\n\n\n\n\n\nentities.density.annotations.DensityAnnotationManager.clear()\nRemove all annotations\n\n\n\nentities.density.annotations.DensityAnnotationManager.get(name)\nGet an annotation by name\n\n\n\nentities.density.annotations.DensityAnnotationManager.register_class(\n    annotation_class,\n)\nRegister an annotation class\nThis method adds the annotation class to the entity specific class registry (classes) and adds a new method (add) to the manager with a signature that matches the annotation inputs.\n\n\n\nentities.density.annotations.DensityAnnotationManager.remove(annotation)\nRemove an annotation by name or instance\nWhen a name is used, all annotations that match the name will be removed\n\n\n\nentities.density.annotations.DensityAnnotationManager.unregister_type(\n    annotation_type,\n)\nUnregister a registered annotation type\nThis method removes the annotation type from the entity speicific class registry and removes the ‘add_&lt;&gt;’ method from the manager\n\n\n\n\n\nentities.density.annotations.DensityGridAxes(density)\nDensity Grid Axes Annotation\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nshow_length\nbool\nWhether or not to show the length of the grid axes\n\n\nunits\nstr\nUnits to use for length. Default: Å\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\nvalidate\nOptional method to validate annotation inputs\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes.validate(input_name=None)\nOptional method to validate annotation inputs This is called during annotation creation and any time the inputs change either through the API or GUI. Can return False or raise an exception when validation fails. Returns True when all validations succeed.\nNote: This method gets called when any inputs change, so updating values in here will lead to a recursive loop and should not be done.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_name\nstr\nThe input name update that trigged this validation callback. When no specific input name is available, None is passed.\nNone\n\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D(density)\nDensity Grid Axes 3D Annotation\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nshow_length\nbool\nWhether or not to show the length of the grid axes\n\n\nunits\nstr\nUnits to use for length. Default: Å\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\nvalidate\nOptional method to validate annotation inputs\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityGridAxes3D.validate(input_name=None)\nOptional method to validate annotation inputs This is called during annotation creation and any time the inputs change either through the API or GUI. Can return False or raise an exception when validation fails. Returns True when all validations succeed.\nNote: This method gets called when any inputs change, so updating values in here will lead to a recursive loop and should not be done.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_name\nstr\nThe input name update that trigged this validation callback. When no specific input name is available, None is passed.\nNone\n\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo(density)\nDensity Info Annotation\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlocation\ntuple[float, float]\nNormalized coordinates (0.0 - 1.0) of the postion in viewport / render\n\n\nshow_filename\nbool\nWhether or not to show the grid filename\n\n\nshow_threshold\nbool\nWhether or not to show the current threshold value\n\n\nshow_origin\nbool\nWhether or not to show the grid origin\n\n\nshow_delta\nbool\nWhether or not to show the grid delta\n\n\nshow_shape\nbool\nWhether or not to show the grid shape\n\n\ncustom_text\nstr\nAny custom text to add at the end of the annotation\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.density.annotations.DensityInfo.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.density.annotations.DensityInfo.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\n\n\nentities.density.annotations.Label2D()\nCommon Label2D Annotation for all entities\n\n\n\nentities.density.annotations.Label3D()\nCommon Label3D Annotation for all entities",
    "crumbs": [
      "Reference",
      "Annotations",
      "entities.density.annotations"
    ]
  },
  {
    "objectID": "api/reference/StyleSpheres.html",
    "href": "api/reference/StyleSpheres.html",
    "title": "StyleSpheres",
    "section": "",
    "text": "StyleSpheres(geometry='Point', radius=0.8, subdivisions=2, shade_smooth=True)\nStyle class for Style Spheres\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ngeometry\nAny\nShow spheres as a Point Cloud, Instances of a mesh Icosphere, or realised Mesh instances of an Icosphere. Point cloud is best for performance and should definitely be used if rendering in Cycles.\n'Point'\n\n\nradius\nfloat\nScale the vdw_radii of the atom when setting the radius of the spheres\n0.8\n\n\nsubdivisions\nint\nNumber of subdicisions when using Instances or Mesh to represent atoms\n2\n\n\nshade_smooth\nbool\nApply smooth shading when using Instances or Mesh\nTrue\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nupdate_style_node\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nStyleSpheres.update_style_node(node_style)\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnode_style\nGeometryNodeGroup\nThe Blender GeometryNodeGroup to update\nrequired",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleSpheres"
    ]
  },
  {
    "objectID": "api/reference/StyleSpheres.html#parameters",
    "href": "api/reference/StyleSpheres.html#parameters",
    "title": "StyleSpheres",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ngeometry\nAny\nShow spheres as a Point Cloud, Instances of a mesh Icosphere, or realised Mesh instances of an Icosphere. Point cloud is best for performance and should definitely be used if rendering in Cycles.\n'Point'\n\n\nradius\nfloat\nScale the vdw_radii of the atom when setting the radius of the spheres\n0.8\n\n\nsubdivisions\nint\nNumber of subdicisions when using Instances or Mesh to represent atoms\n2\n\n\nshade_smooth\nbool\nApply smooth shading when using Instances or Mesh\nTrue",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleSpheres"
    ]
  },
  {
    "objectID": "api/reference/StyleSpheres.html#methods",
    "href": "api/reference/StyleSpheres.html#methods",
    "title": "StyleSpheres",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nupdate_style_node\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nStyleSpheres.update_style_node(node_style)\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnode_style\nGeometryNodeGroup\nThe Blender GeometryNodeGroup to update\nrequired",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleSpheres"
    ]
  },
  {
    "objectID": "api/canvas.html",
    "href": "api/canvas.html",
    "title": "Canvas",
    "section": "",
    "text": "The Canvas object can be used to configure different render settings, camera, frame objects and views to render images and animations. The snapshot and animation methods can be used to render images and animations respectively.",
    "crumbs": [
      "Canvas"
    ]
  },
  {
    "objectID": "api/canvas.html#setup-molecular-nodes",
    "href": "api/canvas.html#setup-molecular-nodes",
    "title": "Canvas",
    "section": "Setup Molecular Nodes",
    "text": "Setup Molecular Nodes\n\nimport molecularnodes as mn\nimport MDAnalysis as mda\nfrom MDAnalysis.tests.datafiles import DCD, PSF, TPR, XTC\n\n# create a canvas object\ncanvas = mn.Canvas()",
    "crumbs": [
      "Canvas"
    ]
  },
  {
    "objectID": "api/canvas.html#add-trajectories",
    "href": "api/canvas.html#add-trajectories",
    "title": "Canvas",
    "section": "Add Trajectories",
    "text": "Add Trajectories\n\nu1 = mda.Universe(PSF, DCD)\nu2 = mda.Universe(TPR, XTC)\n\n# add universes to Blender\nt1 = mn.Trajectory(u1).add_style(\"cartoon\")\nt2 = mn.Trajectory(u2)",
    "crumbs": [
      "Canvas"
    ]
  },
  {
    "objectID": "api/canvas.html#add-styles-and-annotations-to-trajectories",
    "href": "api/canvas.html#add-styles-and-annotations-to-trajectories",
    "title": "Canvas",
    "section": "Add Styles and Annotations to Trajectories",
    "text": "Add Styles and Annotations to Trajectories\n\n# styles\n# trajectory 1\n\nt1.add_style(style=mn.StyleBallAndStick(quality=4), selection=\"resid 184\")\nt1.add_style(\n    style=mn.StyleSpheres(subdivisions=4, geometry=\"Instance\"),\n    selection=\"resid 1 129\",\n)\n\n# trajectory 2\nt2.add_style(style=\"ribbon\", color=(0.162, 0.624, 0.196, 0.5))\nt2.add_style(selection=\"resid 141\", style=\"ball_and_stick\")\n\n# annotations\n# trajectory 1\nt1.annotations.add_com_distance(\n    selection1=\"resid 1\", selection2=\"resid 129\", text1=\"resid 1\", text2=\"resid 129\"\n)\nt1.annotations.add_atom_info(selection=\"name CA and resid 184\", show_resid=True)\n# trajectory 2\nt2.annotations.add_atom_info(selection=\"name CA and resid 141\", show_resid=True)\n\n&lt;molecularnodes.annotations.manager.AtomInfo_interface at 0x365bc3d90&gt;",
    "crumbs": [
      "Canvas"
    ]
  },
  {
    "objectID": "api/canvas.html#add-density-component",
    "href": "api/canvas.html#add-density-component",
    "title": "Canvas",
    "section": "Add Density component",
    "text": "Add Density component\n\nfrom pathlib import Path\n\nd1_path = Path(\"../../\") / \"tests/data/emd_24805.map.gz\"\n\n# load density file\nd1 = mn.entities.density.io.load(\n    file_path=d1_path,\n    style=\"density_iso_surface\",\n    overwrite=True,\n)",
    "crumbs": [
      "Canvas"
    ]
  },
  {
    "objectID": "api/canvas.html#frame-objects",
    "href": "api/canvas.html#frame-objects",
    "title": "Canvas",
    "section": "Frame Objects",
    "text": "Frame Objects\nThe frame_object method can be used to frame entity objects. By default, the current camera viewpoint is used to frame objects. An optional viewpoint param can be used to set the viewpoint to one of [default, front, back, left, right, top, bottom].\n\n# frame trajectory 1 from front and render\ncanvas.frame_object(t1, viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# frame trajectory 2 from front and render\ncanvas.frame_object(t2, viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# frame density object from right and render\ncanvas.frame_object(d1, viewpoint=\"right\")\ncanvas.snapshot()",
    "crumbs": [
      "Canvas"
    ]
  },
  {
    "objectID": "api/canvas.html#frame-views",
    "href": "api/canvas.html#frame-views",
    "title": "Canvas",
    "section": "Frame Views",
    "text": "Frame Views\nThe frame_view method can be used to frame one or more views. Views can be specific selections within entities or across entities. Multiple views can be combined with a + sign before passing to the frame_view method. An optional viewpoint param can be passed to specify the viewpoint like before.\nAll entities have a get_view method that returns the entity object by default. The get_view method of trajectories can return views based on one or more selection strings or AtomGroups and also take the specific trajectory frame into consideration.\n\n# frame resid 184 in trajectory 1 from the front\nv184 = t1.get_view(selection=\"resid 184\")\ncanvas.frame_view(v184, viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# frame resid 1 and 129 in trajectory 1 at frame 97 from the front\ncanvas.frame_view(t1.get_view(\"resid 1 129\", frame=97), viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# frame resid 184 from trajectory 1 and resid 141 from trajectory 2\ncanvas.frame_view(\n    t1.get_view(\"resid 184\") + t2.get_view(\"resid 141\"), viewpoint=\"front\"\n)\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# frame trajectory 2 and density component from left\ncanvas.frame_view(t2.get_view() + d1.get_view(), viewpoint=\"left\")\ncanvas.snapshot()",
    "crumbs": [
      "Canvas"
    ]
  },
  {
    "objectID": "api/canvas.html#camera-zoom-in-or-out",
    "href": "api/canvas.html#camera-zoom-in-or-out",
    "title": "Canvas",
    "section": "Camera Zoom in or out",
    "text": "Camera Zoom in or out\nCamera can be zoomed in our out using the camera lens settings of the Canvas camera object once framed.\n\n# frame density object from front and render - default\ncanvas.frame_object(d1, viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# zoom in\ncanvas.camera.lens = 150\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# zoom out\ncanvas.camera.lens = 35\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# reset camera lens to default (50mm)\ncanvas.camera.lens = 50",
    "crumbs": [
      "Canvas"
    ]
  },
  {
    "objectID": "api/canvas.html#camera-rotation",
    "href": "api/canvas.html#camera-rotation",
    "title": "Canvas",
    "section": "Camera Rotation",
    "text": "Camera Rotation\nCamera can be rotated to an arbitrary angle using the camera rotation method of the Canvas camera object before framing the object or view. Blender uses a default XYZ Euler for rotations along the X, Y and Z axes. The rotation method takes angles in degrees.\n\n# print current rotation\ncanvas.camera.rotation\n\n(89.999995674289, -0.0, 0.0)\n\n\n\n# rotate 45 degrees to left from the front view\n# frame density object - note that viewpoint is not specified\ncanvas.frame_view(d1, (90, 0, -45))\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# frame density object and render\ncanvas.frame_view(d1, (90, 0, 45))\ncanvas.snapshot()",
    "crumbs": [
      "Canvas"
    ]
  },
  {
    "objectID": "api/canvas.html#animations",
    "href": "api/canvas.html#animations",
    "title": "Canvas",
    "section": "Animations",
    "text": "Animations\nThe animation method can be used to render animations. An optional frame_start and frame_end can be specified to limit animations to a custom range. The render_scale parameter can be used to scale the renders as a percentage of the render resolution.\n\n# frame resid 1 and 129 in trajectory 1 at frame 97 from the front\ncanvas.frame_view(t1.get_view(\"resid 1 129\", frame=97), viewpoint=\"front\")\n# add a universe info annotation to trajectory 1\nt1.annotations.add_universe_info()\n\n&lt;molecularnodes.annotations.manager.UniverseInfo_interface at 0x364a14390&gt;\n\n\n\n# render animation of scene from frame 10 to 50 at 50% sccale\ncanvas.animation(frame_start=10, frame_end=50, render_scale=50)\n\n\n\n\n\n\n\n\n \n Your browser does not support the video tag.",
    "crumbs": [
      "Canvas"
    ]
  },
  {
    "objectID": "api/trajectory/rendering.html",
    "href": "api/trajectory/rendering.html",
    "title": "Rendering",
    "section": "",
    "text": "Here is an example that uses Canvas to render images and animations of MDAnalysis Universes.\nimport molecularnodes as mn\nimport MDAnalysis as mda\nfrom MDAnalysis.tests.datafiles import PSF, DCD\n\ncanvas = mn.Canvas()",
    "crumbs": [
      "Trajectory",
      "Rendering"
    ]
  },
  {
    "objectID": "api/trajectory/rendering.html#add-universe-to-blender",
    "href": "api/trajectory/rendering.html#add-universe-to-blender",
    "title": "Rendering",
    "section": "Add Universe to Blender",
    "text": "Add Universe to Blender\n\nu = mda.Universe(PSF, DCD)\nt = mn.Trajectory(u).add_style(\"cartoon\")\n\n# add resid 1 and 129 with spheres style\nt.add_style('spheres', selection=\"resid 1 129\")\n# set the sphere geometry to mesh\nt.styles[1].geometry = \"mesh\"",
    "crumbs": [
      "Trajectory",
      "Rendering"
    ]
  },
  {
    "objectID": "api/trajectory/rendering.html#add-annotations-to-universe",
    "href": "api/trajectory/rendering.html#add-annotations-to-universe",
    "title": "Rendering",
    "section": "Add annotations to Universe",
    "text": "Add annotations to Universe\n\n# add universe info annotation\nt.annotations.add_universe_info()\n\n# add COM distance between resid 1 and 129 annotation\nt.annotations.add_com_distance(\n    selection1=\"resid 1\", selection2=\"resid 129\", text1=\"r1\", text2=\"r129\"\n)\n\n&lt;molecularnodes.annotations.manager.COMDistance_interface at 0x35f4a6e50&gt;",
    "crumbs": [
      "Trajectory",
      "Rendering"
    ]
  },
  {
    "objectID": "api/trajectory/rendering.html#render-image",
    "href": "api/trajectory/rendering.html#render-image",
    "title": "Rendering",
    "section": "Render Image",
    "text": "Render Image\n\n# frame the trajectory\ncanvas.frame_object(t)\n\n# render image of scene at frame 75\ncanvas.snapshot(frame=75)",
    "crumbs": [
      "Trajectory",
      "Rendering"
    ]
  },
  {
    "objectID": "api/trajectory/rendering.html#render-animation",
    "href": "api/trajectory/rendering.html#render-animation",
    "title": "Rendering",
    "section": "Render Animation",
    "text": "Render Animation\n\n# render animation of scene from frame 10 to 50 at 50% sccale\ncanvas.animation(frame_start=10, frame_end=50, render_scale=50)\n\n\n\n\n\n\n\n\n \n Your browser does not support the video tag.",
    "crumbs": [
      "Trajectory",
      "Rendering"
    ]
  },
  {
    "objectID": "api/materials.html",
    "href": "api/materials.html",
    "title": "Materials",
    "section": "",
    "text": "We can progrommatically access the properties of the materials like this:\nimport molecularnodes as mn\ncv = mn.Canvas(engine=\"EEVEE\", resolution=(800, 800), transparent=True)\nPropeties for the material interface are based on the inputs of the nodes in the material.\n[x for x in dir(mn.material.AmbientOcclusion()) if not x.startswith(\"_\")]\n\n['ambient_occlusion_color',\n 'ambient_occlusion_distance',\n 'ambient_occlusion_normal',\n 'emission_color',\n 'emission_strength',\n 'material',\n 'math_value',\n 'mix_a',\n 'mix_b',\n 'mix_factor',\n 'tree']",
    "crumbs": [
      "Materials"
    ]
  },
  {
    "objectID": "api/materials.html#render-engines-and-materials",
    "href": "api/materials.html#render-engines-and-materials",
    "title": "Materials",
    "section": "Render Engines and Materials",
    "text": "Render Engines and Materials\nThe different render engines handle materials diferently.\n\nimport MDAnalysis as mda\nimport itertools\nfrom MDAnalysis.tests.datafiles import PSF, DCD\n\ncv = mn.Canvas(resolution=(800, 800), transparent=True)\n\nu = mda.Universe(PSF, DCD)\ntraj = mn.Trajectory(u)\ntraj.add_style(mn.StyleSpheres(geometry=\"Mesh\", subdivisions=4))\n\ncv.frame_view(traj)\nengines = [mn.scene.Cycles(samples=32), mn.scene.EEVEE()]\nmaterials = [\n    mn.material.Default(),\n    mn.material.AmbientOcclusion(),\n    mn.material.FlatOutline(),\n    mn.material.Squishy(),\n]\nfor mat, eng in itertools.product(materials, engines):\n    cv.engine = eng\n    traj.styles[0].material = mat\n    cv.snapshot()\n\n\n\n\n\n\n\n\n\n\n\n(a) Cycles + Default\n\n\n\n\n\n\n\n\n\n\n\n(b) EEVEE + Default\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) Cycles + Ambient Occlusion\n\n\n\n\n\n\n\n\n\n\n\n(d) EEVEE + Ambient Occlusion\n\n\n\n\n\n\n\n\n\n\n\n\n\n(e) Cycles + Flat Outline\n\n\n\n\n\n\n\n\n\n\n\n(f) EEVEE + Flat Outline\n\n\n\n\n\n\n\n\n\n\n\n\n\n(g) Cycles + Squishy\n\n\n\n\n\n\n\n\n\n\n\n(h) EEVEE + Squishy\n\n\n\n\n\n\n\nFigure 3: How different materials behave in each render engine",
    "crumbs": [
      "Materials"
    ]
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "Python API",
    "section": "",
    "text": "The API is Experimental\n\n\n\nMolecular Nodes was first built as an add-on for Blender, intended to be used through the GUI.\nA lot of improvements have been made to now allow a scriptable interface, but a lot of these changes should still be considered experimental and may change in future versions. The version is pinned to the versions of Blender it is intended for, so while MN is currently version 4.5, it should not be considered that stable.\nThe quirks of progamming within Blender are numerous and will likely remain regardless of version.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "api/index.html#working-in-blender",
    "href": "api/index.html#working-in-blender",
    "title": "Python API",
    "section": "Working in Blender",
    "text": "Working in Blender\nWhen scripting with Molecular Nodes, it’s important to remember that everything we do doesn’t work in isolation. All of the objects we add & changes we make happen within a “3D scene” inside of Blender, so deleting one thing or another doesn’t always clean up and reset everything you might expect.\nBlender itself has a very extensive python API, accessible through the bpy module. Molecular Nodes is designed so that for most general usage you shouldn’t have to ever directly use bpy, but all of the complex settings and controls are still always accessible through that module.\nBlender does release the bpy module on pypi, which let’s us",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "api/index.html#installation",
    "href": "api/index.html#installation",
    "title": "Python API",
    "section": "Installation",
    "text": "Installation\nIf installed inside of Blender as an add-on, you can script using MN in the python console or when running scripts through Blender.\nYou can also install and use inside of your own python projects.\n\n\n\n\n\n\nPython Versions\n\n\n\nmolecularnodes is only compatible with python==3.11\nBlender is very particular about python versions (and especially numpy versions). Blender adheres to the VFX Reference platform which determines python and common package versions to be used across multiple VFX software for consistency.\nBecause of this, the bpy package upon which molecularnodes is build is locked to python==3.11 and in particular numpy==1.26. Going outside of these very particular versions is recipe for distaster. The first Blender release of 2026 will increase to 3.13 and 2.3 repsectively.\n\n\nBlender (bpy) is listed as an optional dependency for MN so that when installing inside of Blender there isn’t a double up with the bunlded bpy. This means you’ll need to always manually request it when installing or add it as a requirement to your own project.\npip install molecularnodes[bpy]",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "api/index.html#getting-started",
    "href": "api/index.html#getting-started",
    "title": "Python API",
    "section": "Getting Started",
    "text": "Getting Started\nThere are two main classes you will interact with, the Molecule and the Trajectory.\n\nMolecule\n\nIntended for static structures, downloaded from the PDB or loaded locally\nUses biotite as the backend for parsing files and storing data as a biotite.structure.AtomArray\ndoesn’t support selection strings\n\nTrajectory\n\nFor MD simulation data\nUses MDAnalysis as the backend, keeping a MDAnalysis.Universe updating in the background to update positions\nsupports selection strings and transformations\n\n\nHow you script with each is unfortunately slightly different when it comes to selections, but will hopefully in the future be unified.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "api/index.html#molecules",
    "href": "api/index.html#molecules",
    "title": "Python API",
    "section": "Molecules",
    "text": "Molecules\nTo get started, with import the module start a new scene be creating out Canvas object. This object is how we change settings for how the scene will render and other related settings sich as resolution.\n\nimport molecularnodes as mn\n\ncanvas = mn.Canvas(mn.scene.Cycles(samples=32), resolution=(720, 480))\n\n\nAdd a Molecule\nThe mn.Molecule can take a AtomArray from the biotite package directly, or it has the mn.Molecule.fetch and mn.Molecule.load class methods to download directly from the PDB or load a local file.\nAfter loading the molecule, to be able to see anything we must first add a style. Then we can frame the camera on the object and take a snapshot.\n\nmol = mn.Molecule.fetch(\"4ozs\")\nmol.add_style(mn.StyleCartoon())\ncanvas.frame_object(mol)\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\ncanvas.clear()\ncanvas.background = (0, 0.5, 0.5, 1.0)\ncanvas.camera.lens = 130\nmol = mn.Molecule.fetch(\"9MD2\")\nmol.add_style(\n    mn.StyleCartoon(peptide_loop_radius=0.4), material=mn.material.AmbientOcclusion()\n)\ncanvas.frame_object(mol)\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\ncanvas.frame_view(mol, (-3.14, 0, 0))\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\ncanvas.clear()\ncanvas.engine = \"eevee\"\ncanvas.resolution = (800, 800)\ncanvas.transparent = True\n\nmol = mn.Molecule.fetch(\"Q8W3K0\", database=\"alphafold\")\nmol.add_style(mn.StyleCartoon(), color=\"pLDDT\", material=mn.material.AmbientOcclusion())\ncanvas.frame_view(mol)\ncanvas.snapshot()",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "api/index.html#trajectories",
    "href": "api/index.html#trajectories",
    "title": "Python API",
    "section": "Trajectories",
    "text": "Trajectories\n\nimport MDAnalysis as mda\nfrom MDAnalysis.tests.datafiles import PSF, DCD\nfrom MDAnalysisData import datasets\nfrom MDAnalysis import transformations\nfrom MDAnalysis.analysis import rms, align\nimport numpy as np\nimport matplotlib.cm as cm\n\ncanvas = mn.Canvas(mn.scene.Cycles(samples=16), (800, 800), transparent=True)\n\n\nInitial snapshot of the Universe\nThe simplest rendering is just loading in the Trajectory, adding a style and then rendering an image. The style can be specified as a string, or using mn.StyleSpheres() to also specify values for the style rather than updating them later.\n\nu = mda.Universe(PSF, DCD)\ntraj = mn.Trajectory(u)\ntraj.add_style(\"vdw\")\ncanvas.frame_view(traj)\ncanvas.snapshot()\n\n\n\n\n\n\n\nFigure 1: A simple render of the atoms in the mda.Universe.\n\n\n\n\n\n\n\nAdd styles to the universe based on some MDA selectrion string\nWe can clear all existing styles on the Trajectory, and selectively add them based on some selection. The selections can be AtomGroup or strings. If a string, first the existence of a Named Attribute is checked and if it exists that is uses as a boolean to apply the selection. If the attribute doesn’t exist, the string is used as an MDAnalysis selection string. This is equivalent to doing u.select_atoms() and passing that atom group as a selection.\n\nmedian = np.median(traj.atoms.positions, axis=0)\ntraj.styles.clear()\n(\n    traj\n    .add_style(mn.StyleSpheres(), selection = f\"prop x &gt; {median[0]}\")\n    .add_style(mn.StyleSpheres(), selection=f\"prop x &lt;= {median[0]}\", color=(0,0,0,1))\n)\ncanvas.frame_view(traj)\ncanvas.snapshot()\n\n\n\n\n\n\n\nFigure 2: Selectively apply the style using an MDAnalysis selection string.\n\n\n\n\n\n\ncanvas.clear()\n\nrot = [transformations.rotate.rotateby(90,direction=[0,1,0],point=np.zeros(3))]\nu = mda.Universe(PSF, DCD, transformations=rot)\n\ng2 = mn.Trajectory(u).add_style(mn.StyleSpheres())\ncanvas.frame_view(g2)\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n\nColoring Atoms Based on Computed Values\nRun analysis and compute values.\n\nadk = datasets.fetch_adk_equilibrium()\nu = mda.Universe(adk.topology, adk.trajectory)\n\naverage = align.AverageStructure(u, u, select=\"protein and name CA\", ref_frame=0).run()\nref = average.results.universe\naligner = align.AlignTraj(u, ref, select=\"protein and name CA\", in_memory=True).run()\n\nc_alphas = u.select_atoms(\"protein and name CA\")\nR = rms.RMSF(c_alphas).run()\nu.add_TopologyAttr(\"tempfactors\")\nprotein = u.select_atoms(\"protein\")\n\nfor residue, r_value in zip(protein.residues, R.results.rmsf):\n    residue.atoms.tempfactors = r_value\n\nCompute a numpy array of color values (Red, Green, Blue, Alpha) that we can then store on the mesh object inside of Blender that will be used for coloring in the final render.\n\nviridis = cm.get_cmap('inferno')\ncol_array = u.atoms.tempfactors\ncol_array /= col_array.max()\ncol_array = viridis(col_array)\ncol_array\n\n/var/folders/r4/ym_ncgbd3qddtxqvrmhps8q80000gn/T/ipykernel_71640/3304747087.py:1: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n  viridis = cm.get_cmap('inferno')\n\n\narray([[0.453651, 0.103848, 0.430498, 1.      ],\n       [0.453651, 0.103848, 0.430498, 1.      ],\n       [0.453651, 0.103848, 0.430498, 1.      ],\n       ...,\n       [0.832299, 0.283913, 0.257383, 1.      ],\n       [0.832299, 0.283913, 0.257383, 1.      ],\n       [0.832299, 0.283913, 0.257383, 1.      ]])\n\n\nCreate the Trajectory object that will be visualised inside of Blender. After initialising it, we store the computed colors as a Named Attribute on the mesh with the store_named_attribute() function. These values can now be accessed in the rendering pipeline.\nWhen we add our style, we given it the name of our Named Attribute which will be used for coloring the final mesh. In this example I render both as spheres and also as ribbon backbone - both of which use the colors we computed. The ribbon backbone takes whatever color value is stored on the alpha carbon.\ncanvas.clear()\ntraj = mn.Trajectory(u)\ntraj.store_named_attribute(col_array, \"custom_color\")\n\ntraj.add_style(mn.StyleSpheres(radius=0.8), color=\"custom_color\")\ncanvas.frame_view(traj)\ncanvas.snapshot()\n\ntraj.styles.clear()\ntraj.add_style(mn.StyleRibbon(quality=6, backbone_radius=1.5), color=\"custom_color\")\ncanvas.frame_view(traj)\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n\n\n(a) Spheres each use the atom’s color.\n\n\n\n\n\n\n\n\n\n\n\n(b) Ribbon and cartoon use the color from the alpha carbon.\n\n\n\n\n\n\n\nFigure 3: We can compute custom color values and then use those in the final render.\n\n\n\n\n\nA sub-selection of atoms\nWhen adding a style, we can ensure it is only applied to some selection of atoms. The selection can be an AtomGroup or a string. In this case we pass an AtomGroup and the selection is only applied to those atoms from the group.\n\ncanvas.clear()\nadk = datasets.fetch_adk_equilibrium()\nu = mda.Universe(adk.topology, adk.trajectory)\ntraj = mn.Trajectory(u)\ntraj.add_style(mn.StyleSpheres(), selection=u.atoms[u.atoms.names == \"CA\"])\ncanvas.frame_view(traj.get_view())\ncanvas.snapshot()",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "api/annotations.html",
    "href": "api/annotations.html",
    "title": "Annotations",
    "section": "",
    "text": "Annotations API allows adding annotations to molecular entities. Molecular Nodes comes with a few bundled annotations for trajectories, but new ones can be dynamically added as well.",
    "crumbs": [
      "Annotations"
    ]
  },
  {
    "objectID": "api/annotations.html#setup-molecular-nodes",
    "href": "api/annotations.html#setup-molecular-nodes",
    "title": "Annotations",
    "section": "Setup Molecular Nodes",
    "text": "Setup Molecular Nodes\n\nimport molecularnodes as mn\nimport MDAnalysis as mda\nfrom MDAnalysis.tests.datafiles import DCD, PSF, TPR, XTC\n\n# create a canvas object\ncanvas = mn.Canvas()",
    "crumbs": [
      "Annotations"
    ]
  },
  {
    "objectID": "api/annotations.html#add-a-trajectory-entity",
    "href": "api/annotations.html#add-a-trajectory-entity",
    "title": "Annotations",
    "section": "Add a Trajectory Entity",
    "text": "Add a Trajectory Entity\n\nu = mda.Universe(PSF, DCD)\nt = mn.Trajectory(u).add_style(\"cartoon\")",
    "crumbs": [
      "Annotations"
    ]
  },
  {
    "objectID": "api/annotations.html#adding-annotations",
    "href": "api/annotations.html#adding-annotations",
    "title": "Annotations",
    "section": "Adding Annotations",
    "text": "Adding Annotations\nAnnotations can be added using the add_&lt;annotation_type&gt; method of the annotations manager of an entity. Each entity can have different annotation types supported.\nThe bundled annotation types for Trajectories are:\n\nadd_atom_info() - For some basic atom info\nadd_com() - For center-of-mass of a selection\nadd_com_distance() - For distance between two center-of-masses\nadd_canonical_dihedrals() - For canonical dihedrals of a residue\nadd_universe_info() - For universe info\nadd_label_2d() - For adding a generic 2d label in viewport / render\nadd_label_3d() - For adding a generic 3d label\n\nAll selections used in the annotation APIs can be either MDAnalysis selection phrases (strings) or instances of AtomGroups.\nHere is how to access the annotations manager of an entity:\n\n# annotations manager\nt.annotations\n\n&lt;molecularnodes.entities.trajectory.annotations.TrajectoryAnnotationManager at 0x364f9fe10&gt;\n\n\nAvailable annotation types can be seen as follows:\n\n# available annotation types\n[a for a in t.annotations.__dir__() if a.startswith(\"add_\")]\n\n['add_atom_info',\n 'add_com',\n 'add_com_distance',\n 'add_canonical_dihedrals',\n 'add_universe_info',\n 'add_simulation_box',\n 'add_label_2d',\n 'add_label_3d']\n\n\nEach annotation type can have different input parameters. A common parameter name can be passed to name the annotation for easier name based lookups later. All the parameters to the add_&lt;annotation_type&gt; method have to be keyword params.\nAnnotations can be added using the add_&lt;annotation_type&gt; method, which returns an instance that can be used to further customize the annotation. Annotation specific inputs as well as common annotation parameters can be customized.\nThe function signature for adding an annotation type can be seen as follows:\n\nt.annotations.add_atom_info.func.__signature__\n\n&lt;Signature (self, annotation_class, /, *, selection: str | MDAnalysis.core.groups.AtomGroup = 'name CA', show_resid: bool = False, show_segid: bool = False, name: str = None) -&gt; molecularnodes.annotations.interface.AnnotationInterface&gt;",
    "crumbs": [
      "Annotations"
    ]
  },
  {
    "objectID": "api/annotations.html#annotation-examples",
    "href": "api/annotations.html#annotation-examples",
    "title": "Annotations",
    "section": "Annotation Examples",
    "text": "Annotation Examples\n\natom_info\nDisplay the atom info of a selection.\nThe input parameters for this annotation are:\n\nselection - An MDAnalysis selection phrase or AtomGroup\nshow_resid - Whether to show the resid\nshow_segid - Whether to show the segid\n\n\n# add a style to display all the alpha carbons as spheres\nt.add_style(\n    selection=\"name CA\", style=\"ball_and_stick\", color=(0.162, 0.624, 0.196, 1.0)\n)\n# add the atom_info annotation\na1 = t.annotations.add_atom_info(\n    selection=\"resid 73:78 and name CA\",\n    show_resid=True,\n    show_segid=True,\n    name=\"r1 atom info\"\n)\n# set the font size to 12\na1.text_size = 12\n\n\n# frame the view and render\ncanvas.frame_view(t.get_view(\"resid 73:78\"), viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# hide the annotation and remove the added style\na1.visible = False\nt.styles[1].remove()\n\n\n\ncom\nDisplay the center-of-mass of a selection.\nThe input parameters for this annotation are:\n\nselection - An MDAnalysis selection phrase or AtomGroup\ntext - Text to be displayed at the center-of-mass of selection\n\n\n# show com of the whole protein\na2 = t.annotations.add_com(selection=\"protein\", text=\"Protein|COM\", name=\"Protein COM\")\n# show com of residues 150 through 170\na3 = t.annotations.add_com(selection=\"resid 150:170\", text=\"resid 150:170|COM\")\n\n\n# frame the view and render\ncanvas.frame_view(t.get_view(), viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# hide the added annotations\na2.visible = False\na3.visible = False\n\n\n\ncom_distance\nDisplay the distance between center-of-masses of two selections.\nThe input parameters for this annotation are:\n\nselection1 - An MDAnalysis selection phrase or AtomGroup of first selection\nselection2 - An MDAnalysis selection phrase or AtomGroup of second selection\ntext1 - Text to display at com of first selection\ntext2 - Text to display at com of second selection\n\n\n# add com_distance between resid 1 and 129\na4 = t.annotations.add_com_distance(\n    selection1=\"resid 1\",\n    selection2=u.select_atoms(\"resid 129\"),\n    text1=\"resid 1|COM\",\n    text2=\"resid 129|COM\",\n    name=\"r1-129 distance\",\n)\n# display the distance line as a 3d mesh\n# with the 2d line overlay and a specific color\na4.line_mode = \"mesh_and_overlay\"\na4.mesh_color = (0, 1, 0, 1)  # (r, g, b, a)\n\n\n# frame the view and render\ncanvas.frame_view(t.get_view(\"resid 1 129\"), viewpoint=\"bottom\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# hide the added annotation\na4.visible = False\n\n\n\ncanonical_dihedrals\nDisplay the canonical dihedrals of a residue\nThe input parameters for this annotation are:\n\nresid - The residue id\nshow_atom_names - Whether to show the atom names in the residue\nshow_direction - Whether to show the direction arcs of the dihedral angles\n\n\n# show canonical dihedrals of residue 200\na5 = t.annotations.add_canonical_dihedrals(resid=200)\n\n\n# frame the view and render\ncanvas.frame_view(t.get_view(\"resid 200\"), viewpoint=\"back\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# hide the added annotation\na5.visible = False\n\n\n\nuniverse_info\nDisplay the universe info of the trajectory.\nThe input parameters for this annotation are:\n\nlocation - Normalized 2d location (0.0 - 1.0) to show the info wrt viewport / render\nshow_frame - Whether or not to show the frame number of the trajectory\nshow_time - Whether or not to show the timestep time\nshow_step - Whether or not to show the timestep step\nshow_topology - Whether or not to show the topology filename\nshow_trajectory - Whether or not to show the trajectory filename\nshow_atoms - Whether or not to show the number of atoms in the universe\n\n\n# add universe_info annotation\na6 = t.annotations.add_universe_info()\n\n\n# frame the view and render\ncanvas.frame_view(t.get_view(), viewpoint=\"top\")\ncanvas.snapshot(frame=50)\n\n\n\n\n\n\n\n\n\n# hide the added annotation\na6.visible = False\n\n\n\nsimulation_box\nDisplay the simulation box of the trajectory if box dimensions are present.\nThe input parameters for this annotation are:\n\ncenter_to_origin - Whether to move the center of the box to Origin (0, 0, 0)\ncompact - Whether to create a compact Wigner-Seitz cell. Note that the trajectory needs to have been wrapped with the compact option to see it within the box\nshow_lattice - Whether to show a 3x3x3 lattice of the box\n\n\n# add simulation box annotation\nt.annotations.add_simulation_box()\n\n&lt;molecularnodes.annotations.manager.SimulationBox_interface at 0x365209d50&gt;\n\n\n\n\nlabel_2d\nDisplay a generic 2d label in the viewport / render.\nThe input parameters for this annotation are:\n\ntext - Text to display\nlocation - Normalized location (0.0 - 1.0) to show the text wrt viewport / render\n\n\n# show a 2d label at the top left\na7 = t.annotations.add_label_2d(text=\"Any|2D Label\", location=(0.1, 0.8))\n\n\n# frame the view and render\ncanvas.frame_view(t.get_view(), viewpoint=\"left\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# hide the added annotation\na7.visible = False\n\n\n\nlabel_3d\nDisplay a generic 3d label on the universe.\nThe input parameters for this annotation are:\n\ntext - Text to display\nlocation - 3d coordinates in universe to display text\n\n\n# show the alpha carbon of resid 1 as a sphere\nt.add_style(\n    selection=\"resid 1 and name CA\",\n    style=\"ball_and_stick\",\n    color=(0.162, 0.624, 0.196, 1.0),\n)\n# select the alpha carbon of resid 1\nr1 = t.universe.select_atoms(\"resid 1 and name CA\")\natom = r1.atoms[0]\n# add a 3d label to display text at this atom's location\na8 = t.annotations.add_label_3d(text=f\"CA|resid 1|{atom.segid}\", location=atom.position)\n# add a pointer to point at the location\na8.line_pointer_length = 2\na8.line_width = 2\n\n\n# frame the view and render\ncanvas.frame_view(t.get_view(\"resid 1\"), viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# hide the added annotation\na8.visible = False\n# remove the added style\nt.styles[1].remove()",
    "crumbs": [
      "Annotations"
    ]
  },
  {
    "objectID": "api/annotations.html#accessing-annotations",
    "href": "api/annotations.html#accessing-annotations",
    "title": "Annotations",
    "section": "Accessing Annotations",
    "text": "Accessing Annotations\nAnnotations added to an entity can be accessed in several different ways.\n\nName based access\n\n# get the resid 1 atom info annotation by name - subscriptable\na = t.annotations[\"r1 atom info\"]\nprint(a)\n# get the resid 1 atom info annotation by name - get method\na = t.annotations.get(\"r1 atom info\")\nprint(a)\n\n&lt;molecularnodes.annotations.manager.AtomInfo_interface object at 0x365209310&gt;\n&lt;molecularnodes.annotations.manager.AtomInfo_interface object at 0x365209310&gt;\n\n\n\n\nIndex based access\n\nprint(\"# annotations = \", len(t.annotations))\n# get the protein COM annotation by index\na = t.annotations[1]\na\n\n# annotations =  9\n\n\n&lt;molecularnodes.annotations.manager.COM_interface at 0x364fa3090&gt;\n\n\n\n\nIterable access\n\n# access all annotations by iteration\nfor a in t.annotations:\n    print(a.name)\n\nr1 atom info\nProtein COM\nAnnotation\nr1-129 distance\nAnnotation.001\nAnnotation.002\nAnnotation.003\nAnnotation.004\nAnnotation.005",
    "crumbs": [
      "Annotations"
    ]
  },
  {
    "objectID": "api/annotations.html#controlling-visiblity",
    "href": "api/annotations.html#controlling-visiblity",
    "title": "Annotations",
    "section": "Controlling Visiblity",
    "text": "Controlling Visiblity\nAll annotations of an entity can be collectively hidden or displayed using the visible attribute of the annotations manager.\n\n# get current annotations visibility\nt.annotations.visible\n\nTrue\n\n\n\n# hide all annotations\nt.annotations.visible = False\nt.annotations.visible\n\nFalse\n\n\n\n# show all annotations\nt.annotations.visible = True\nt.annotations.visible\n\nTrue",
    "crumbs": [
      "Annotations"
    ]
  },
  {
    "objectID": "api/annotations.html#common-annotation-params",
    "href": "api/annotations.html#common-annotation-params",
    "title": "Annotations",
    "section": "Common Annotation Params",
    "text": "Common Annotation Params\nAll annotations have common params that control the display properties. These params are in addition to the annotation specific inputs.\nThe common annotation params are:\n\nname - Name of the annotation\nvisible - Whether or not the annotation is visible\ntext_font - Filename of the custom font to use for text\ntext_color - Text color - rgba tuple like (1.0, 0.0, 1.0, 1.0)\ntext_size - Size of the text displayed\ntext_alignment - Alignment of the text (center, left, right)\ntext_rotation - Angle by which to rotate text when left aligned\ntext_vspacing - Vertical spacing between lines in multi line text\ntext_depth - Whether to enable showing text size based on depth (default: True)\ntext_falloff - A normalized value (0.0 - 1.0) of how the text size falls off with distance from the viewport / camera\ntext_offset_x - Text offset along the x direction (in pixels)\ntext_offset_y - Text offset along the y direction (in pixels)\nline_arrow_size - Size of the arrow displayed (for lines with arrow ends)\nline_pointer_length - Length of a pointer line to draw (defaults to 0, which is no pointer)\nline_mode - Display mode of line (overlay, mesh, mesh_and_overlay)\nmesh_wireframe - Whether to show 3d meshes as wireframes\nmesh_thickness - Thickness of the edges in wireframe mode\nmesh_color - Color of the 3d meshes\nmesh_material - Material to use for 3d meshes\nmesh_shade_smooth - Whether to use shade smooth for 3d meshes\n\n\n# common annotation params for a1\n[(p, getattr(a1, p)) for p in a1.__dir__() if not p.startswith(\"_\")]\n\n[('selection', 'resid 73:78 and name CA'),\n ('show_resid', True),\n ('show_segid', True),\n ('name', 'r1 atom info'),\n ('visible', False),\n ('text_font', ''),\n ('text_color',\n  bpy.data.objects['NewUniverseObject'].mn_annotations[0].text_color),\n ('text_size', 12),\n ('text_align', 'center'),\n ('text_rotation', 0.0),\n ('text_vspacing', 1.350000023841858),\n ('text_depth', True),\n ('text_falloff', 1.0),\n ('text_offset_x', 0),\n ('text_offset_y', 0),\n ('line_mode', 'overlay'),\n ('line_color',\n  bpy.data.objects['NewUniverseObject'].mn_annotations[0].line_color),\n ('line_width', 1.0),\n ('line_arrow_size', 0.25),\n ('line_pointer_length', 0.0),\n ('mesh_wireframe', False),\n ('mesh_thickness', 1.0),\n ('mesh_color',\n  bpy.data.objects['NewUniverseObject'].mn_annotations[0].mesh_color),\n ('mesh_material', bpy.data.materials['MN Default']),\n ('mesh_shade_smooth', True)]",
    "crumbs": [
      "Annotations"
    ]
  },
  {
    "objectID": "api/annotations.html#removing-annotations",
    "href": "api/annotations.html#removing-annotations",
    "title": "Annotations",
    "section": "Removing Annotations",
    "text": "Removing Annotations\nIndividual annotaitons can be removed using the annotation name or annotation instance.\n\nRemove by name\n\n# remove by an annotation name\nt.annotations.remove(\"r1 atom info\")\n\n\n\nRemove by instance\n\n# remove by an annotation instance\nt.annotations.remove(a4)\n\n\n\nRemove all annoations\n\n# remove all annotations\nt.annotations.clear()",
    "crumbs": [
      "Annotations"
    ]
  },
  {
    "objectID": "api/annotations.html#custom-annotations",
    "href": "api/annotations.html#custom-annotations",
    "title": "Annotations",
    "section": "Custom Annotations",
    "text": "Custom Annotations\nIn addition to the above bundled annotations for Trajectories, custom annotation types can be created by extending the TrajectoryAnnotation class. These custom annotation types will be automatically registered and can be added using the same add_&lt;annotation_type&gt; method of a trajectory instance. The GUI to add and configure the annotation will also be automatically available.\n\nCreate a custom annotation\nA custom trajectory annotation class has to extend TrajectoryAnnotation and implement the draw method. Optional defaults method can be used to set defaults for the annotation and a validate method that can validate inputs when they change can be implemented. The custom class will have access to the trajectory entity via self.trajectory, universe via self.trajectory.universe and the annotation params via self.interface. Please see the drawing utilities section for all the methods available to draw onto the viewport / renders from the draw code.\n\n# Add a CutomAnnotation class\n# This class will auto-register with the Trajectory entities\nclass CustomAnnotation(mn.entities.trajectory.TrajectoryAnnotation):\n    annotation_type = \"custom_annotation\"\n\n    selection: str  # required param\n    bool_param: bool = False  # optional bool param\n\n    # optional defaults method\n    def defaults(self) -&gt; None:\n        # any default settings for this annotation go here\n        params = self.interface\n        # set text size to 24\n        params.text_size = 20\n\n    # optional validate method\n    def validate(self, input_name: str = None) -&gt; bool:\n        # validate any input params that change (either through API or GUI)\n        # return True if validation succeeds else False or raise an Exception\n        params = self.interface\n        universe = self.trajectory.universe\n        # validate and save the selection atom group\n        if isinstance(params.selection, str):\n            # check if selection phrase is valid\n            # mda throws exception if invalid\n            self.atom_group = universe.select_atoms(params.selection)\n        elif isinstance(params.selection, AtomGroup):\n            self.atom_group = params.selection\n        else:\n            raise ValueError(f\"Need str or AtomGroup. Got {type(params.selection)}\")\n        return True\n\n    # required draw method\n    def draw(self) -&gt; None:\n        # the draw code for this annotation\n        # self.trajectory points to the trajectory instance\n        # self.interface points to the interface that provides\n        #     the annotation inputs and common annotation parameters\n        # show the atom names of the selection\n        for atom in self.atom_group:\n            self.draw_text_3d(atom.position, atom.name)\n\n\nThe defaults method\nThis method is called only once when the annotation instance is created. Common annotation param defaults and other initializations that need to be done once can be setup in this method.\n\n\nThe validate method\nThis method is called during annotation creation and every time an annotation input changes (both through the API and GUI). This method can raise and exception or return False when validation fails. On successful validations, this method should return True. In addition to validations, any values that require resetting due to input changes can be done in this method.\n\n\nThe draw method\nThis is the main draw method of the annotation that gets called multiple times as part of Blender’s 3D viewport draw handler and during rendering. It is important to only do the minimum required drawing stuff in this method to avoid viewport lag. The defaults and validate methods above can be used to setup all the required analysis classes and results that can be displayed in this method.\n\n\n\nAdd the custom annotation\n\nt.add_style(selection=\"resid 75\", style=\"ball_and_stick\")\n# add the custom annotation and pass the required selection parameter\nca = t.annotations.add_custom_annotation(selection=\"resid 75\")\nca\n\n&lt;molecularnodes.annotations.manager.CustomAnnotation_interface at 0x36520a990&gt;\n\n\n\n# frame the view and render\ncanvas.frame_view(t.get_view(\"resid 75\"), viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# hide the added annotation\nca.visible = False\n\n\n\nUnregister a custom annotation\nCustom annotations get automatically registered with the TrajectoryAnnotationManager. They can be manually unregistered and re-registered using the unregister_type and register_class methods if required.\n\n# unregister the annotation\nmanager = mn.entities.trajectory.TrajectoryAnnotationManager\nmanager.unregister_type(\"custom_annotation\")\n\n\n\nInput types\nCustom annotations can specify inputs that become automatically available to both the API and the GUI. For example, selection and bool_param are inputs for the custom annotation example above. Inputs are specified as class attributes with a Python annotation that specifies its type. In the example above, selection is of type str and bool_param is of type bool.\nHere are the supported types and their representation in Blender GUI:\n\n\n\n\n\n\n\nType\nRepresentation in Blender GUI\n\n\n\n\nstr\nString input\n\n\nbool\nBoolean checkbox\n\n\nint\nInteger input\n\n\nfloat\nFloat input\n\n\ntuple[float, float]\nA vector input in 2 dimensions\n\n\ntuple[float, float, float]\nA vector input in 3 dimensions\n\n\ntuple[float, float, float, float]\nA vector input in 4 dimensions. Input names that contain the word “color” will become Color selections\n\n\nlist[str]\nAn Enumeration drowpdown\n\n\n\n\n\nParam overrides\nText, lines and meshes drawn in custom annotations can be controlled by the same params as described in the Common Annotations Params section above. Custom annotations can also override these parameters to either hardcode specific values or allow additional customization though separate inputs. This can be done by passing the overrides keyword param to any of the drawing utilities and specify a dictionary of the parameters to override along with their values.\nHere is an example within a custom annotation that draws two 3D circles, the first with a hardcoded color value and the second with a custom input color:\n    ...\n    # custom line color input\n    line_color_input: tuple[float, float, float, float] = (1, 1, 1, 1)\n    ...\n    self.draw_circle_3d(\n        center,\n        radius,\n        normal_vector,\n        overrides={\"line_color\": (1.0, 0.498, 0.055, 1)},\n    )\n    self.draw_circle_3d(\n        center,\n        radius * 2,\n        normal_vector,\n        overrides={\"line_color\": self.interface.line_color_input},\n    )\n    ...\n\n\nDrawing utilities\nCustom annotations can use the drawing utilities available from the base annotation class to display text or drawings in the viewport / renders.\nThe following utility methods are currently available:\n\ndistance - Distance between two vectors\ndraw_text_2d - Draw text at a given 2D position (normalized co-ordinates) of Viewport.\ndraw_text_3d - Draw text at a given 3D position\ndraw_line_2d - Draw a line between two points (normalized co-ordinates) in 2D viewport space\ndraw_line_3d - Draw a line between two points in 3D space\ndraw_circle_2d - Draw a circle around a 2D point (normalized coordinate) in the viewport space\ndraw_circle_3d - Draw a circle around a 3D point in the plane perpendicular to the given normal\ndraw_sphere - Draw a sphere object at a 3D point\ndraw_cone - Draw a cone object along an axis\ndraw_cylinder - Draw a cylinder object along an axis\ndraw_n_sided_cylinder - Draw an n sided cylinder\ndraw_n_sided_pyramid - Draw an n sided pyramid\ndraw_triclinic_cell - Draw a triclinic cell\ndraw_wigner_seitz_cell - Draw a compact Wigner-Seitz cell\ndraw_bmesh - Draw a generic Blender BMesh\ndraw_bpy_image - Draw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\nbpy_image_to_pil_image - Convert Blender image to PIL image\npil_image_to_bpy_image - Convert PIL image to Blender image\n\nThese methods can be used within the draw method of a custom annotation. Please see the API reference for mn.annotations.base for details about these methods.",
    "crumbs": [
      "Annotations"
    ]
  },
  {
    "objectID": "citations/index.html",
    "href": "citations/index.html",
    "title": "Citing Molecular Nodes",
    "section": "",
    "text": "A paper for Molecular Nodes has not yet been published, but you can cite the Zenodo entry for the GitHub repo here: \nA selection of academic works that use Molecular Nodes in producing some of their figures or supplimentary movies.\n\n\n\n\n\n\n\n\n\n\nRecent Advances in the Development and Use of Silk-Based Biomaterials\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1146/annurev-matsci-080423-114451\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn Search of Empty Spheres: 3D Apollonius Diagrams on GPU\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1145/3730868\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAntimicrobial peptides: structure, functions and translational applications\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1038/s41579-025-01200-y\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn-Situ High-Resolution Cryo-EM Reconstructions from CEMOVIS\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1101/2025.03.29.646093\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStructural biology meets typography: using protein structures to inspire creative expression and connect diverse audiences\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.3389/fbinf.2025.1589122\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSingle-Shot Design of a Cyclic Peptide Inhibitor of HIV-1 Membrane Fusion with EvoBind\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1101/2025.04.30.651413\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSelf-assembled cell-scale containers made from DNA origami membranes\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1101/2024.02.09.579479\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNanoplasmonics for Enhanced Fluorescence Detection of Nucleic Acids: From Fundamentals to Boosting Cancer Management\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1002/anbr.202400088\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeling membranes in situ\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1016/j.sbi.2024.102837\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nElectrophysical cardiac remodeling at the molecular level: Insights into ryanodine receptor activationand calcium-induced calcium release from stochastic explicit-particle model\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1016/j.bpj.2024.09.029\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNonuniversal impact of cholesterol on membranes mobility, curvature sensing and elasticity\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1038/s41467-023-43892-x\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArchaeal GPN-loop GTPases involve a lock-switch-rock mechanism for GTP hydrolysis\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1128/mbio.00859-23\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRecent advances in interpretable machine learning using structure-based protein representations\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.48550/arXiv.2409.17726\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Role of Protein-Lipid Interactions in Priming the Bacterial Translocon\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.3390/membranes14120249\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCoarse-grained modeling of annexin A2-induced microdomain formation on a vesicle\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1016/j.bpj.2024.06.006\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnravelling the Maturation Pathway of a Eukaryotic Virus through Cryo-EM\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1101/2024.08.31.610394\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRibosomes hibernate on mitochondria during cellular stress\n\n\n\n\n\ndoi\n\n\nhttps://doi.org/10.1038/s41467-024-52911-4\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "examples/index.html",
    "href": "examples/index.html",
    "title": "Examples",
    "section": "",
    "text": "Some examples of projects that have used Molecular Nodes in their production.\n\n\n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nEvolutionaryScale.ai\n\n\nImages and videos created for the EvolutionScale.ai landing page\n\n\n\n\n\n\n\n\n\n\n\n\nYour Operating System ｜Eukaryotic Transcription\n\n\n🧬How does your DNA actually become who you are? Let’s go on the incredible journey it takes to transcribe your DNA into mRNA.\n\n\n\nClockwork\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat if all the world’s biggest problems have the same solution?\n\n\nA veritasium video about using AI for protein folding, highlighting the work of AlphaFold and RFDiffusion.\n\n\n\nVeritasium\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducing RFpeptides\n\n\nA press release for the Institute for Protein Design, introducing the new RFpeptides software\n\n\n\nInstitute for Protein Design\n\n\n\n\n\n\n\n\n\n\n\n\n\nYour Unstoppable Copy Machine\n\n\nClockwork is a YouTube channel about some of the really nitty-gritty biochemistry with great visuals and writing. They recently started posting videos again, having made the…\n\n\n\nClockwork\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhy do we have to learn about the Krebs cycle?\n\n\nA video about the Krebs cycle, a cycle of reactions that are essential for life.\n\n\n\nNanorooms\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow do cells come up with their programming langauge?\n\n\n\nNanorooms\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow our cells (nearly) perfected making nanobots\n\n\n\nNanorooms\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhere the Light Touches Your Eyes\n\n\n👀 Your visual system is astounding down at the molecular level-because the photoreceptor cells in your retina maintain an incredible balance of proteins that allows for an…\n\n\n\nClockwork\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Increible Biology Powering Autumn Colors\n\n\n🍂 You’ve probably learned why leaves change color and drop from trees in the fall. But what actually causes these color changes?\n\n\n\nClockwork\n\n\n\n\n\n\n\n\n\n\n\n\n\nBiologia Molecular\n\n\nA TikTok channel making molecular movies with #MolecularNodes\n\n\n\n\n\n\n\n\n\n\n\n\nKnot Theory\n\n\nA popular YouTube science channel, discussing DNA topoisomerases.\n\n\n\nVeritasium\n\n\n\n\n\n\n\n\n\n\n\n\n\nMicrotubules\n\n\nAn animation from St Jude Children’s Hospital, created by Zhaowen Luo. It was shown at the Association of Medical Illustrators annual conference in 2023, and won the…\n\n\n\nZhaowen Luo, St Jude Children’s Hospital\n\n\n\n\n\n\n\n\n\n\n\n\n\nNano Rooms\n\n\nNano rooms is a YouTube channel explaining the beautilful mathematical underpinnings of biology, and many of their animations of protein structures are using Molecular Nodes…\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "attributes.html",
    "href": "attributes.html",
    "title": "Attribute",
    "section": "",
    "text": "Below are the attributes which are potentially created when a structure is imported. Explanations of type and domain conversions can be found in the Blender documentation here\n\n\nIn Molecular Nodes, the world scale determines how real-world measurements are translated into the 3D environment of Blender which uses metres. Currently, 1 angstrom (Å) is equivalent to 1 centimeter (cm). Scaling structural coodinates by 0.01 correctly converts them and 0.01 is referred to as the world scale.\nThis scale will change in Blender 5.0 to be 0.1 so 1 nm will equal 1 m.\nWhen an attribute is going to be read from the geometry, it is colored red like so: Index, chain_id, while when a specific data type is refernce it will be colored accoring to the data type like so: Int, Float, Vector, etc.\n\n\n\n\n\nAttributes are always associated with Geometry. They will be stored on one of the domains of the geometry. The type of the attribute is determined by the type of the data it contains. The following types are supported by Geometry Nodes.\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nInt\n32-bit integers\n\n\nFloat\n32-bit floating point numbers\n\n\nBool\nA simple True or False value\n\n\nVector\n3D vectors\n\n\nMatrix\n4x4 matrices, also references as Transform inside of Geometry Nodes\n\n\nColor\nRGBA colors, stored as 0..1 values\n\n\nRotation\nA rotation that internally is represented as a quaternion, but can implicitly be converted to an Euler vector.\n\n\n\n\n\n\nAdditional data types which are not supported as Attributes but can be used in the node tree are:\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nString\nString support in Geometry Nodes is limited at the moment and you cannot store strings as attributes\n\n\nObject\nAccess to objects in the 3D scene and their associated data\n\n\nCollection\nAccess a collection of objects from the scene. Objects are returned as instances\n\n\nMaterial\nMaterial to be applied to the created geometry\n\n\nMenu\nA menu for selecting a value from a list of options\n\n\n\n\n\n\n\nAll of the molecular attributes which are defined as strings such as chain_id, res_name, etc. are stored as integers in the geometry because Geometry Nodes does not support string attributes.\nFor chain_id, entity_id and other dynamic attributes, the unique values are first sorted alphabetically and then assigned an integer value based on their order.\nFor other attributes such as res_name, they are looked up from the dictionary and assigned an integer value.\n\n\n\n\n\n\n\n\n\n\nPosition\nVector\nCoordinates in 3D space of the points, read from the molecular data file. They are scaled by the world scale 0.01 on import so that 1 Å == 1 cm.\n\n\nb_factor\nFloat\nThe temperature factor for the atom on import. If importing an AlphaFold structure this corresponds to the pLDDT value.\n\n\nvdw_radii\nFloat\nThe radii of the atom, stored in world space (~0.015). Values sourced from Wikipedia.\n\n\nsec_struct\nInt\nDefines secondary structure for the residue the atom is part of. 0 for not a protein. 1 for helices, 2 for sheets, 3 for coils / unstructured.\n\n\nmass\nFloat\nMass of the element\n\n\nchain_id\nInt\nThe integer representation of the chain ID, for it’s position in the sorted list of chain IDs in the structure.\n\n\nentity_id\nInt\nMultiple chains can be the same entity, if they are copies of the same protein that appear multiple times in the structure. Also sorted and assigned integers on import.\n\n\nres_name\nInt\nResidues are mapped to integer values based on the lookup table.\n\n\nres_id\nInt\nThe residue number, which starts at 1 for the first residue in each chain. If a structure is truncated it might not start at 1.\n\n\nures_id\nInt\nThe ures_id starts at 0 and increases by 1 for each residue across the whole structure, compared to the res_id which starts at 1 and restarts at 1 for each chain.\n\n\natomic_number\nInt\nStores the atomic number of the atom for it’s position on the periodic table, instead of the element’s name.\n\n\natom_name\nInt\nAtom names are mapped to integer values based on the lookup table.\n\n\nColor\nColor\nColor of the atom, assigned on import but often changed in node trees.\n\n\natom_id\nInt\nUnique ascending value for each atom in the file, starting at 1\n\n\nis_alpha_carbon\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_side_chain\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_backbone\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_solvent\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_nucleic\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_peptide\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_hetero\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_carb\nBool\nComputed on import or from the atom_name attribute.\n\n\n\n\n\n\nBonds between atoms are represented as edges in the geometry, and only the bond type is stored on the edge domain.\n\n\n\nAttribute\nType\nDescription\n\n\n\n\nbond_type\nInt\nThe type of bond between the atoms.\n\n\n\nBond types are currently the values used by biotite\n\n\n\n\n\n\n\n\nBond Type\nInteger Value\nDescription\n\n\n\n\nANY\n0\nUsed if the actual type is unknown\n\n\nSINGLE\n1\nSingle bond\n\n\nDOUBLE\n2\nDouble bond\n\n\nTRIPLE\n3\nTriple bond\n\n\nQUADRUPLE\n4\nA quadruple bond\n\n\nAROMATIC_SINGLE\n5\nAromatic bond with a single formal bond\n\n\nAROMATIC_DOUBLE\n6\nAromatic bond with a double formal bond\n\n\nAROMATIC_TRIPLE\n7\nAromatic bond with a triple formal bond\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDomain\nDescription\n\n\n\n\nPoint\nIndividual points of geometry. These can be the vertices in a mesh, the points in a point cloud, or the control points of a curve.\n\n\nEdge\nThe edges of a mesh, defined as the indices between two points.\n\n\nFace\nA face of a mesh, defined as a collection of edges.\n\n\nCorner\nCorners of a face, where two edges meet.\n\n\nCurve\nA curve object, which contains multiple control points, but can itself store attributes.\n\n\nInstance\nInstances are references to other geometry. Instancing is useful for making lots of copies of some geometry for performance.\n\n\nLayer\nLayers are for Grease Pencil, and contain a collection of curves.",
    "crumbs": [
      "Documentation",
      "Reference",
      "Attributes"
    ]
  },
  {
    "objectID": "attributes.html#world-scale",
    "href": "attributes.html#world-scale",
    "title": "Attribute",
    "section": "",
    "text": "In Molecular Nodes, the world scale determines how real-world measurements are translated into the 3D environment of Blender which uses metres. Currently, 1 angstrom (Å) is equivalent to 1 centimeter (cm). Scaling structural coodinates by 0.01 correctly converts them and 0.01 is referred to as the world scale.\nThis scale will change in Blender 5.0 to be 0.1 so 1 nm will equal 1 m.\nWhen an attribute is going to be read from the geometry, it is colored red like so: Index, chain_id, while when a specific data type is refernce it will be colored accoring to the data type like so: Int, Float, Vector, etc.",
    "crumbs": [
      "Documentation",
      "Reference",
      "Attributes"
    ]
  },
  {
    "objectID": "attributes.html#data-types",
    "href": "attributes.html#data-types",
    "title": "Attribute",
    "section": "",
    "text": "Attributes are always associated with Geometry. They will be stored on one of the domains of the geometry. The type of the attribute is determined by the type of the data it contains. The following types are supported by Geometry Nodes.\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nInt\n32-bit integers\n\n\nFloat\n32-bit floating point numbers\n\n\nBool\nA simple True or False value\n\n\nVector\n3D vectors\n\n\nMatrix\n4x4 matrices, also references as Transform inside of Geometry Nodes\n\n\nColor\nRGBA colors, stored as 0..1 values\n\n\nRotation\nA rotation that internally is represented as a quaternion, but can implicitly be converted to an Euler vector.\n\n\n\n\n\n\nAdditional data types which are not supported as Attributes but can be used in the node tree are:\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nString\nString support in Geometry Nodes is limited at the moment and you cannot store strings as attributes\n\n\nObject\nAccess to objects in the 3D scene and their associated data\n\n\nCollection\nAccess a collection of objects from the scene. Objects are returned as instances\n\n\nMaterial\nMaterial to be applied to the created geometry\n\n\nMenu\nA menu for selecting a value from a list of options",
    "crumbs": [
      "Documentation",
      "Reference",
      "Attributes"
    ]
  },
  {
    "objectID": "attributes.html#attributes-1",
    "href": "attributes.html#attributes-1",
    "title": "Attribute",
    "section": "",
    "text": "All of the molecular attributes which are defined as strings such as chain_id, res_name, etc. are stored as integers in the geometry because Geometry Nodes does not support string attributes.\nFor chain_id, entity_id and other dynamic attributes, the unique values are first sorted alphabetically and then assigned an integer value based on their order.\nFor other attributes such as res_name, they are looked up from the dictionary and assigned an integer value.\n\n\n\n\n\n\n\n\n\n\nPosition\nVector\nCoordinates in 3D space of the points, read from the molecular data file. They are scaled by the world scale 0.01 on import so that 1 Å == 1 cm.\n\n\nb_factor\nFloat\nThe temperature factor for the atom on import. If importing an AlphaFold structure this corresponds to the pLDDT value.\n\n\nvdw_radii\nFloat\nThe radii of the atom, stored in world space (~0.015). Values sourced from Wikipedia.\n\n\nsec_struct\nInt\nDefines secondary structure for the residue the atom is part of. 0 for not a protein. 1 for helices, 2 for sheets, 3 for coils / unstructured.\n\n\nmass\nFloat\nMass of the element\n\n\nchain_id\nInt\nThe integer representation of the chain ID, for it’s position in the sorted list of chain IDs in the structure.\n\n\nentity_id\nInt\nMultiple chains can be the same entity, if they are copies of the same protein that appear multiple times in the structure. Also sorted and assigned integers on import.\n\n\nres_name\nInt\nResidues are mapped to integer values based on the lookup table.\n\n\nres_id\nInt\nThe residue number, which starts at 1 for the first residue in each chain. If a structure is truncated it might not start at 1.\n\n\nures_id\nInt\nThe ures_id starts at 0 and increases by 1 for each residue across the whole structure, compared to the res_id which starts at 1 and restarts at 1 for each chain.\n\n\natomic_number\nInt\nStores the atomic number of the atom for it’s position on the periodic table, instead of the element’s name.\n\n\natom_name\nInt\nAtom names are mapped to integer values based on the lookup table.\n\n\nColor\nColor\nColor of the atom, assigned on import but often changed in node trees.\n\n\natom_id\nInt\nUnique ascending value for each atom in the file, starting at 1\n\n\nis_alpha_carbon\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_side_chain\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_backbone\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_solvent\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_nucleic\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_peptide\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_hetero\nBool\nComputed on import or from the atom_name attribute.\n\n\nis_carb\nBool\nComputed on import or from the atom_name attribute.\n\n\n\n\n\n\nBonds between atoms are represented as edges in the geometry, and only the bond type is stored on the edge domain.\n\n\n\nAttribute\nType\nDescription\n\n\n\n\nbond_type\nInt\nThe type of bond between the atoms.\n\n\n\nBond types are currently the values used by biotite\n\n\n\n\n\n\n\n\nBond Type\nInteger Value\nDescription\n\n\n\n\nANY\n0\nUsed if the actual type is unknown\n\n\nSINGLE\n1\nSingle bond\n\n\nDOUBLE\n2\nDouble bond\n\n\nTRIPLE\n3\nTriple bond\n\n\nQUADRUPLE\n4\nA quadruple bond\n\n\nAROMATIC_SINGLE\n5\nAromatic bond with a single formal bond\n\n\nAROMATIC_DOUBLE\n6\nAromatic bond with a double formal bond\n\n\nAROMATIC_TRIPLE\n7\nAromatic bond with a triple formal bond",
    "crumbs": [
      "Documentation",
      "Reference",
      "Attributes"
    ]
  },
  {
    "objectID": "attributes.html#domains",
    "href": "attributes.html#domains",
    "title": "Attribute",
    "section": "",
    "text": "Domain\nDescription\n\n\n\n\nPoint\nIndividual points of geometry. These can be the vertices in a mesh, the points in a point cloud, or the control points of a curve.\n\n\nEdge\nThe edges of a mesh, defined as the indices between two points.\n\n\nFace\nA face of a mesh, defined as a collection of edges.\n\n\nCorner\nCorners of a face, where two edges meet.\n\n\nCurve\nA curve object, which contains multiple control points, but can itself store attributes.\n\n\nInstance\nInstances are references to other geometry. Instancing is useful for making lots of copies of some geometry for performance.\n\n\nLayer\nLayers are for Grease Pencil, and contain a collection of curves.",
    "crumbs": [
      "Documentation",
      "Reference",
      "Attributes"
    ]
  },
  {
    "objectID": "nodes/index.html",
    "href": "nodes/index.html",
    "title": "Nodes",
    "section": "",
    "text": "The nodes that are included with Molecular Nodes, are all pre-built and included with the add-on. They work the same as any of the other nodes inside of Geometry Nodes, and can, if used, also process the data from 3D models like a cube or a monkey. They are designed with molecular data & use cases in mind, but they are not limited to usage with molecular data.\nAll of the nodes that are included are documented here, with descriptions, extra info about inputs and outputs, sometimes small demo videos showing the intended use cases of the nodes.\nExperimentation is highly encouraged, combining these nodes with others to see what kind of results you can get. Molecular Nodes came about through experimentation with nodes, and there is no better way to learn the systems then to keep plugging and unplugging different sockets, changing values and tinkering.\nAt any point you can view the internals of the node groups that are included with Molecular Nodes. With a node selected, you can Tab to enter a selected node, and use Ctrl + Tab to exit the node group. You can also do the same by right clicking. Feel free to tweak the internals of node groups, but beware that changing one node group will change that node group for all othe uses of it. Starting a new Blender session will ensure that the node groups are fresh and ‘factor reset’.",
    "crumbs": [
      "Documentation",
      "Nodes"
    ]
  },
  {
    "objectID": "data_table.html",
    "href": "data_table.html",
    "title": "Data Tables",
    "section": "",
    "text": "Data Tables\nThe different lookup tables that are used to conver strings to integers in Molecular Nodes.\nCode for this can be found on the GitHub Page\n\nResidue Names\n\n\n\nName\nInteger\n\n\n\n\nUNK\n-1\n\n\nALA\n0\n\n\nARG\n1\n\n\nASN\n2\n\n\nASP\n3\n\n\nCYS\n4\n\n\nGLU\n5\n\n\nGLN\n6\n\n\nGLY\n7\n\n\nHIS\n8\n\n\nILE\n9\n\n\nLEU\n10\n\n\nLYS\n11\n\n\nMET\n12\n\n\nPHE\n13\n\n\nPRO\n14\n\n\nSER\n15\n\n\nTHR\n16\n\n\nTRP\n17\n\n\nTYR\n18\n\n\nVAL\n19\n\n\nSNC\n15\n\n\nMSE\n12\n\n\nASH\n3\n\n\nCYM\n4\n\n\nCYX\n4\n\n\nGLH\n5\n\n\nHID\n8\n\n\nHIE\n8\n\n\nHIP\n8\n\n\nHYP\n8\n\n\nLYN\n11\n\n\nDA\n30\n\n\nDC\n31\n\n\nDG\n32\n\n\nDT\n33\n\n\nPST\n33\n\n\nA\n40\n\n\nC\n41\n\n\nG\n42\n\n\nU\n43\n\n\nT\n43\n\n\n\n\n\nAtom Names\n\n\n\nName\nInteger\n\n\n\n\nN\n1\n\n\nCA\n2\n\n\nC\n3\n\n\nO\n4\n\n\nCB\n5\n\n\nCG\n6\n\n\nCG1\n7\n\n\nCG2\n8\n\n\nOG\n9\n\n\nOG1\n10\n\n\nSG\n11\n\n\nCD\n12\n\n\nCD1\n13\n\n\nCD2\n14\n\n\nND1\n15\n\n\nND2\n16\n\n\nOD1\n17\n\n\nOD2\n18\n\n\nSD\n19\n\n\nCE\n20\n\n\nCE1\n21\n\n\nCE2\n23\n\n\nCE3\n24\n\n\nNE\n25\n\n\nNE1\n26\n\n\nNE2\n27\n\n\nOE1\n28\n\n\nOE2\n29\n\n\nCH2\n30\n\n\nNH1\n31\n\n\nNH2\n32\n\n\nOH\n33\n\n\nCZ\n34\n\n\nCZ2\n35\n\n\nCZ3\n36\n\n\nNZ\n37\n\n\nOXT\n38\n\n\nP\n50\n\n\nO1P\n51\n\n\nOP1\n51\n\n\nOP2\n52\n\n\nO2P\n52\n\n\nO5’\n53\n\n\nC5’\n54\n\n\nC4’\n55\n\n\nO4’\n56\n\n\nC3’\n57\n\n\nO3’\n58\n\n\nC2’\n59\n\n\nO2’\n60\n\n\nC1’\n61\n\n\nN1\n62\n\n\nN9\n63\n\n\nN3\n64\n\n\nC8\n65\n\n\nN7\n66\n\n\nC5\n67\n\n\nC6\n68\n\n\nN6\n69\n\n\nC2\n70\n\n\nC4\n71\n\n\nO6\n72\n\n\nN2\n73\n\n\nN4\n74\n\n\nO2\n75\n\n\nO4\n76\n\n\nC7\n77",
    "crumbs": [
      "Documentation",
      "Reference",
      "Data Tables"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About",
    "section": "",
    "text": "Molecular Nodes (MN) is an addon for the 3D modelling & animation program Blender. MN enables easy import of molecular data such as .pdb & .mmCIF, along with a variety of molecular dynamics trajectories and topologies from a variety of simulation sources. Other data formats including electron microscopy (EM) .map, EM tomography files such as .map and .star, with the potential to support more data formats as well.\nSee the talk below at the 2022 Blender conference for an overview of the add-on it’s capabilities.\nMolecular Nodes provides the translation layer that allows importing of molecular data formats, while Blender provides the industry-leading animation and rendering tools to create visually stunning molecular graphics with ease.\nThe add-on runs on the Geometry Nodes procedural modelling and animation system inside of Blender, which gives the add-on speed and robustness with minimal user input required."
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "About",
    "section": "Getting Started",
    "text": "Getting Started\nTo get started, checkout the installation page for detailed instructions on how to install the add-on. Next check out some of the tutorials, such as intro to blender, basics of downloading from the PDB or how to customise selections.\nThere are some outdated tutorials on YouTube about how to use the add-on also. MN has been developed further and improved since these videos, but the general workflow remains the same."
  },
  {
    "objectID": "example_animations.html",
    "href": "example_animations.html",
    "title": "Examples",
    "section": "",
    "text": "To create the animation of ATP synthase you can morph between separate states of ATP synthase and export them from your favourite molecular graphics program. In this example, we will use ChimeraX.\nUse the following code in ChimeraX’s console to import and create a morph between the 3 different protein conformations that will create the animation:\nopen 6n2y 6n2z 6n30\nmorph #1,2,3 wrap true\nYou can now play back the animation inside of ChimeraX.\nTo save the animation as a multi-pdb file, use the following code to save the .pdb file:\nsave atp-frames.pdb #4 allCoordsets true\nYou can now open the multi-frame pdb file inside of Molecular Nodes using the ‘Open Local File’ tab.\n\nThis example is taken directly from the ChimeraX twitter account:\n\n\nTo morph between 3 conformations of ATP synthase use ChimeraX commands “open 6n2y 6n2z 6n30” and “morph #1,2,3 wrap true”. #ChimeraXHowTo pic.twitter.com/2u4Au6Tvpf\n\n— ChimeraX (@UCSFChimeraX) May 8, 2020"
  },
  {
    "objectID": "example_animations.html#animating-atp-synthase",
    "href": "example_animations.html#animating-atp-synthase",
    "title": "Examples",
    "section": "",
    "text": "To create the animation of ATP synthase you can morph between separate states of ATP synthase and export them from your favourite molecular graphics program. In this example, we will use ChimeraX.\nUse the following code in ChimeraX’s console to import and create a morph between the 3 different protein conformations that will create the animation:\nopen 6n2y 6n2z 6n30\nmorph #1,2,3 wrap true\nYou can now play back the animation inside of ChimeraX.\nTo save the animation as a multi-pdb file, use the following code to save the .pdb file:\nsave atp-frames.pdb #4 allCoordsets true\nYou can now open the multi-frame pdb file inside of Molecular Nodes using the ‘Open Local File’ tab.\n\nThis example is taken directly from the ChimeraX twitter account:\n\n\nTo morph between 3 conformations of ATP synthase use ChimeraX commands “open 6n2y 6n2z 6n30” and “morph #1,2,3 wrap true”. #ChimeraXHowTo pic.twitter.com/2u4Au6Tvpf\n\n— ChimeraX (@UCSFChimeraX) May 8, 2020"
  },
  {
    "objectID": "example_animations.html#animating-covid-spike-protein",
    "href": "example_animations.html#animating-covid-spike-protein",
    "title": "Examples",
    "section": "2 Animating COVID Spike Protein",
    "text": "2 Animating COVID Spike Protein\n\n\n\n\n\n\nRequires MDAnalysis Installed\n\n\n\nTo follow this particular tutorial, ensure you have first installed Molecular Nodes properly, including the optional MDAnalysis python package.\n\n\nDownload the trajectory files from the the CHARMM-GUI website:\nYou will want to download the .xtc files for the spike protein in membrane.\n\n\n\n\n\n\nCaution\n\n\n\nThe .xtc file will be large, ~2GB so the download may take a while.\n\n\n\nUnzip the files (you may need to unzip the unzipped file) and then inside of Molecular Nodes, in the MD Trajectory tab, select the tpology file (last_frame_nos.pdb) and the trajectory file (trj_nos.xtc).\n\nGive the molecule a name, and your panel should look like this:\n\n\n2.1 Frames to Import\nIn the frame import options, we can choose which frames from the trajectory to import. Importing every frame (interval = 1 ) will take long time to load, and balloon-out the save-file size of the .blend file. It’s best to work with some subset of the trajectory frames, and interpolate between them with Molecular Nodes.\n\n\n\n\n\n\n\nNote\n\n\n\nMolecular nodes is still surprisingly performant with thousands of frames loaded, but the .blend file takes a long time to save and load due to several GBs worth of data being save and loaded each time.\n\n\nFor this example we are going to import every 10th frame.\n\n\n2.2 Click ‘Import Frames’ and Wait\nMolecular Nodes is working through a lot of data, so this load step can take a few minutes - be patient. Once it’s all loaded, the structure along with the atomic properties are available for use inside of Geometry Nodes!\n\n\n2.3 Click space to play the animation.\nEnsure to change over to Cycles & rendered view to view the coloured atoms, but otherwise the animation should be playing if press space!\nJust Points\nVideo\nRendered View In this scene I additionally added a Sun light.\nVideo\n\n\n2.4 Geometry Nodes\nNow that the animation is imported into geometry nodes, you can work with the points as you would otherwise.\nTry applying some noise, or in this example, scaling the points to 0 based on the proximity to an empty.\nVideo"
  },
  {
    "objectID": "api/styles.html",
    "href": "api/styles.html",
    "title": "Styles",
    "section": "",
    "text": "This is how we can add styles or representations of our molecular data, so we can actually see something.\n\nimport molecularnodes as mn\n\ncv = mn.Canvas(resolution=(860, 540), transparent=True)\n\n\ncodes = [\"4ozs\", \"8H1B\", \"8U8W\"]\nstyles = [\n    mn.StyleCartoon(),\n    mn.StyleRibbon(),\n    mn.StyleSpheres(geometry=\"Instance\", subdivisions=4),\n]\nmaterials = [\n    mn.material.Default(),\n    mn.material.AmbientOcclusion(),\n    mn.material.FlatOutline(),\n]\n\nfor code, style, material in zip(codes, styles, materials):\n    mol = mn.Molecule.fetch(code)\n    mol.add_style(style, material=material)\n    cv.frame_object(mol)\n    cv.snapshot()\n    cv.clear()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmol = (\n    mn.Molecule.fetch(\"8H1B\")\n    .add_style(\"cartoon\", material = mn.material.AmbientOcclusion())\n    .add_style(\n        style=\"surface\",\n        selection=mn.MoleculeSelector().is_peptide(),\n        color=(0.6, 0.6, 0.8, 1.0),\n        material=mn.material.TransparentOutline()\n        )\n)\ncv.frame_object(mol)\ncv.snapshot()\n\n\n\n\n\n\n\n\n\nmol.styles[0].remove()\ncv.snapshot()\n\n\n\n\n\n\n\n\n\n(\n    mol\n    .add_style('ribbon', selection=\"is_peptide\")\n    .add_style('surface', selection=\"is_nucleic\")\n)\nstyle = mol.styles[1]\nstyle.backbone_radius = 1.5\nstyle.quality = 5\nstyle.material = mn.material.AmbientOcclusion()\ncv.snapshot()\n\n\n\n\n\n\n\n\n\ncv.clear()\ncv.engine = mn.scene.Cycles(samples=32)\nmol = (\n    mn.Molecule.fetch(\"9EYM\")\n    .add_style(\"cartoon\", material = mn.material.AmbientOcclusion(), selection = \"is_peptide\")\n    .add_style(\"ball_and_stick\", selection=mn.entities.MoleculeSelector().not_peptide())\n)\nmol.styles[1].bond_find = True\ncv.frame_view(mol)\ncv.snapshot()\n\n\n\n\n\n\n\n\n\ncv.frame_view(mol, (-3.14, 0, 0))\ncv.snapshot()",
    "crumbs": [
      "Styles"
    ]
  },
  {
    "objectID": "api/density.html",
    "href": "api/density.html",
    "title": "Density",
    "section": "",
    "text": "The Density entity can be used to load density grids into Blender. It uses MDAnalysis GridDataFormats library and supports a wide variety of formats.",
    "crumbs": [
      "Density"
    ]
  },
  {
    "objectID": "api/density.html#setup-molecular-nodes",
    "href": "api/density.html#setup-molecular-nodes",
    "title": "Density",
    "section": "Setup Molecular Nodes",
    "text": "Setup Molecular Nodes\n\nimport molecularnodes as mn\n\n# create a canvas object\ncanvas = mn.Canvas()\n\n\nAdd 1EHE Molecule\n\n# fetch 1EHE and add cartoon style with uniform color and transparency\nmol = mn.Molecule.fetch(\"1EHE\").add_style(\"cartoon\", color=(0.2, 1.0, 0.3, 0.5))\n\n\n# frame molecule and render\ncanvas.frame_object(mol)\ncanvas.snapshot()",
    "crumbs": [
      "Density"
    ]
  },
  {
    "objectID": "api/density.html#add-apbs-density-example",
    "href": "api/density.html#add-apbs-density-example",
    "title": "Density",
    "section": "Add APBS density example",
    "text": "Add APBS density example\n\nfrom pathlib import Path\n\napbs_sample = Path(\"../../\") / \"tests/data/apbs.dx.gz\"\n\n# load density file\nd = mn.entities.density.io.load(\n    file_path=apbs_sample,\n    style=\"density_iso_surface\",\n    overwrite=True,\n)\n\n\nSet ISO Value\n\n# get the density style\nds = d.styles[0]\n\n\n# set iso value\nds.iso_value = 1",
    "crumbs": [
      "Density"
    ]
  },
  {
    "objectID": "api/density.html#show-density-grid-and-info",
    "href": "api/density.html#show-density-grid-and-info",
    "title": "Density",
    "section": "Show Density Grid and Info",
    "text": "Show Density Grid and Info\n\n# add density grid annotation\ndg = d.annotations.add_grid_axes()\n# add density info annotation\ndi = d.annotations.add_density_info()\n\n\n# frame molecule and render\ncanvas.frame_view(mol.get_view(), viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# hide density grid and info\ndg.visible = di.visible = False",
    "crumbs": [
      "Density"
    ]
  },
  {
    "objectID": "api/density.html#density-view",
    "href": "api/density.html#density-view",
    "title": "Density",
    "section": "Density View",
    "text": "Density View\n\n# frame density and render\ncanvas.frame_view(d.get_view(), viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\nISO Value = 25\n\n# set iso value\nds.iso_value = 25\n\n\n# frame density and render\ncanvas.frame_view(d.get_view(), viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n\nContours\n\n# reset ISO value to 1\nds.iso_value = 1\n\n\n# enable contours\nds.show_contours = True\n# set contour thickness\nds.contour_thickness = 0.1\nds.contour_color = (1.0, 1.0, 1.0, 0.5)\n# use ds.only_contours to only show contours\n\n\n# frame density and render\ncanvas.frame_view(d.get_view(), viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n\nSlicing\nDensity grids can be sliced from left, right, front, back, top and bottom as a percentage of the grid width along that direction.\n\n# remove molecule style\nmol.styles[0].remove()\n\n\n# slice the grid from the left 35%\nds.slice_left = 35\n\n\n# frame density and render\ncanvas.frame_view(d.get_view(), viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n\nRotated View\n\n# rotate camera 45 degress to left from front view\ncanvas.camera.rotation = (90, 0, -45)\n\n\n# frame density and render\ncanvas.frame_view(d.get_view())\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n\nMaterial\n\n# disable contours\nds.show_contours = False\n\n\n# set material\nds.material = \"MN Flat Outline\"\n\n\n# frame density and render\ncanvas.frame_view(d.get_view())\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n\nColors\n\n# set color for positive ISO values\nds.positive_color = (0.7, 1.0, 0.7, 1.0)\n# set color for negative ISO values\nds.negative_color = (0.7, 0.0, 1.0, 1.0)\n\n\n# frame density and render\ncanvas.frame_view(d.get_view())\ncanvas.snapshot()",
    "crumbs": [
      "Density"
    ]
  },
  {
    "objectID": "api/density.html#annotations",
    "href": "api/density.html#annotations",
    "title": "Density",
    "section": "Annotations",
    "text": "Annotations\nThe bundled annotation types for Densities are:\n\ndensity_info - For info about the density grid\ngrid_axes - For displaying the grid axes\nlabel_2d - For adding a generic 2d label in viewport / render\nlabel_3d - For adding a generic 3d label\n\n\ndensity_info\nDisplay the density grid info.\nThe input parameters for this annotation are:\n\nlocation - Normalized 2d location (0.0 - 1.0) to show the info wrt viewport / render\nshow_filename - Whether to display the grid filename\nshow_threshold - Whether to display the ISO value\nshow_origin - Whether to display the origin coordinates of the grid\nshow_delta - Whether to display the grid lengths along the axes\nshow_shape - Whether to display the grid size along the axes\n\n\n\ngrid_axes\nDisplay the grid axes.\nThe input parameters for this annotation are:\n\nshow_length - Whether to show the length of each axis\nunits - The units to display for the axis length\n\n\n\nlabel_2d\nDisplay a generic 2d label in the viewport / render.\nThe input parameters for this annotation are:\n\ntext - Text to display\nlocation - Normalized location (0.0 - 1.0) to show the text wrt viewport / render\n\n\n\nlabel_3d\nDisplay a generic 3d label on the density grid.\nThe input parameters for this annotation are:\n\ntext - Text to display\nlocation - 3d coordinates in grid to display text\n\n\n\nCustom Annotations\nA custom density annotation class has to extend DensityAnnotation and implement the draw method. Optional defaults method can be used to set defaults for the annotation and a validate method that can validate inputs when they change can be implemented. The custom class will have access to the density entity via self.density, the density grid object (Grid) via self.density.grid and the annotation params via self.interface. Please see the Annotations API for all the methods available to draw onto the viewport / renders from the draw code.",
    "crumbs": [
      "Density"
    ]
  },
  {
    "objectID": "api/blender.html",
    "href": "api/blender.html",
    "title": "Blender",
    "section": "",
    "text": "bpy.props have an implicit name attribute. (It is ok to define it explicitly too) This applies to CollectionProperty as well and the find method of a collection property uses this name to return the index of an item if present. This can be very helpful. Without this, the alternative is to convert the keys to a list and use the index method of the list. Note that the name becomes part of a tuple during insertion and hence immutable - use a constant value like a hash before insertion (and not something like object name that can change)\nThe list index property when using UILists can be set to -1. This is the equivalent of nothing selected in the displayed UI list. Always check that the list index is in range before displaying any item details (to avoid out of bound errors) - Blender only sets the value when a UI list item is clicked but updating it when items are added/deleted is user’s responsibility\nBlender’s UIList has a way to both filter (using bit fields) and re-order items using the filter_items method. There are also some helper methods that Blender provides in bpy.types.UI_UL_list that helps both. The management of active index of the selected item in the UIList becomes tricky in case of filtering\nProperty changes/updates cannot happen in the draw/draw_item context. They lead to a AttributeError: Writing to ID classes in this context is not allowed: error. So, any property changes that need to reflect when drawing the layout should be updated in a different (like operator/API) context\nPanels can use a mix-in parent class as specified here to not repeat the common bl_ values and methods like poll etc\nBlender allows panels in the UI layout drawn by users (using layout.panel(...)). This allows better organization in what we display\nPanels created using &lt;layout_item&gt;.panel() in Blender can be None immediately after, so a guarding check is needed to use this correctly in the UI code\nA CollectionProperty with a dynamic PropertyGroup can be assigned to standard types (like bpy.types.Object) at runtime. This is the key that allows extensibility. Blender converts these to ID properties when the corresponding type classes are not registered. Once the type classes are registered they become API defined properties\n\nThe property path has to be at the top level and not nested under another property. For example, bpy.types.Object.mn_annotations works, but bpy.types.Object.mn.annotations doesn’t. The later leads to a AttributeError: '_PropertyDeferred' object has no attribute '...' error\n\n.bl_rna.properties of a PropertyGroup can be used to iterate all the properties within a PropertyGroup. The property name is available under the identifier attribute of the iterated item. The type attribute specifies the property type (like POINTER etc)\nChanging Blender properties through API will need the viewport to be tagged for redraw (area.tag_redraw()) to show updated values immediately in Blender’s GUI\nbpy.props cannot be setup for instances and can only be setup for types and hence apply to all instances. Once defined, the min/max and other values cannot be updated without re-defining it (which changes for all instances). For example, different objects cannot have a frame (bpy.props.IntProperty) with different min/max. The set/get have to be used to enforce limits\nIn property update callbacks, self points to the property. For properties/property groups tied to objects, use self.id_data to access the object (or parent type) directly\nProperty update callbacks have to be carefully used. There are several caveats as noted in the bpy.props page. There are also no safety checks for infinite recursion and hence the need for them and the ordering should be carefully considered\nA lambda function can be used to pass the actual property name within a property group that caused the update in the update callback. Care should be taken when using lambda functions in a loop - a closure is needed to ensure that correct values are passed - this can be done using defaults, a custom function etc\nAlways use Blender properties to keep track of state - this allows interoperability between API and GUI modes. Blender’s PointerProperty can only hold references to Blender’s own bpy.props or ID properties and not arbitrary data. There is no way to reference your own python class/object from a Blender property\nProperties that have an update callback will NOT be called when keyframing that property. See Bug 86675 - need to use the set method as that is the only one that will get called\nProperties cannot have just the set method alone - both set and get are needed. See Bug 107671\nThere is currently no way to mark a custom property as non-animatable. See BUg 113506\nUsing a custom property in the getter and setter of a blender properties interface allows the use of both blender property types and any custom types for API use. We use this trick to support AtomGroup selections through the API. Blender property update callbacks being different from the API based getter/setter allows for this to work seamlessly\nThere is no way to specify a filter for specific files when using Blender’s StringProperty with subtype FILE_PATH directly - users can filter from Blender’s file selection GUI\nBlender’s EnumProperty defaults to the first value when the default is not specified, so it is good to explicitly set a default\nBlender ID properties (non API defined custom properties) are very different from bpy.props (API defined). A good guide to some of the basic differences are highlighted here. ID properties having nested levels are not possible to access through the UI (panels, etc). They have to be flat and at the top level of an instance (like object). They can be used as drivers, can be completely customized for ui (using id_properties_ui and update) but don’t have update callbacks and cannot use bpy.msgbus subscriptions as well. Their application for UI needs is pretty limited",
    "crumbs": [
      "Blender"
    ]
  },
  {
    "objectID": "api/blender.html#props-and-gui",
    "href": "api/blender.html#props-and-gui",
    "title": "Blender",
    "section": "",
    "text": "bpy.props have an implicit name attribute. (It is ok to define it explicitly too) This applies to CollectionProperty as well and the find method of a collection property uses this name to return the index of an item if present. This can be very helpful. Without this, the alternative is to convert the keys to a list and use the index method of the list. Note that the name becomes part of a tuple during insertion and hence immutable - use a constant value like a hash before insertion (and not something like object name that can change)\nThe list index property when using UILists can be set to -1. This is the equivalent of nothing selected in the displayed UI list. Always check that the list index is in range before displaying any item details (to avoid out of bound errors) - Blender only sets the value when a UI list item is clicked but updating it when items are added/deleted is user’s responsibility\nBlender’s UIList has a way to both filter (using bit fields) and re-order items using the filter_items method. There are also some helper methods that Blender provides in bpy.types.UI_UL_list that helps both. The management of active index of the selected item in the UIList becomes tricky in case of filtering\nProperty changes/updates cannot happen in the draw/draw_item context. They lead to a AttributeError: Writing to ID classes in this context is not allowed: error. So, any property changes that need to reflect when drawing the layout should be updated in a different (like operator/API) context\nPanels can use a mix-in parent class as specified here to not repeat the common bl_ values and methods like poll etc\nBlender allows panels in the UI layout drawn by users (using layout.panel(...)). This allows better organization in what we display\nPanels created using &lt;layout_item&gt;.panel() in Blender can be None immediately after, so a guarding check is needed to use this correctly in the UI code\nA CollectionProperty with a dynamic PropertyGroup can be assigned to standard types (like bpy.types.Object) at runtime. This is the key that allows extensibility. Blender converts these to ID properties when the corresponding type classes are not registered. Once the type classes are registered they become API defined properties\n\nThe property path has to be at the top level and not nested under another property. For example, bpy.types.Object.mn_annotations works, but bpy.types.Object.mn.annotations doesn’t. The later leads to a AttributeError: '_PropertyDeferred' object has no attribute '...' error\n\n.bl_rna.properties of a PropertyGroup can be used to iterate all the properties within a PropertyGroup. The property name is available under the identifier attribute of the iterated item. The type attribute specifies the property type (like POINTER etc)\nChanging Blender properties through API will need the viewport to be tagged for redraw (area.tag_redraw()) to show updated values immediately in Blender’s GUI\nbpy.props cannot be setup for instances and can only be setup for types and hence apply to all instances. Once defined, the min/max and other values cannot be updated without re-defining it (which changes for all instances). For example, different objects cannot have a frame (bpy.props.IntProperty) with different min/max. The set/get have to be used to enforce limits\nIn property update callbacks, self points to the property. For properties/property groups tied to objects, use self.id_data to access the object (or parent type) directly\nProperty update callbacks have to be carefully used. There are several caveats as noted in the bpy.props page. There are also no safety checks for infinite recursion and hence the need for them and the ordering should be carefully considered\nA lambda function can be used to pass the actual property name within a property group that caused the update in the update callback. Care should be taken when using lambda functions in a loop - a closure is needed to ensure that correct values are passed - this can be done using defaults, a custom function etc\nAlways use Blender properties to keep track of state - this allows interoperability between API and GUI modes. Blender’s PointerProperty can only hold references to Blender’s own bpy.props or ID properties and not arbitrary data. There is no way to reference your own python class/object from a Blender property\nProperties that have an update callback will NOT be called when keyframing that property. See Bug 86675 - need to use the set method as that is the only one that will get called\nProperties cannot have just the set method alone - both set and get are needed. See Bug 107671\nThere is currently no way to mark a custom property as non-animatable. See BUg 113506\nUsing a custom property in the getter and setter of a blender properties interface allows the use of both blender property types and any custom types for API use. We use this trick to support AtomGroup selections through the API. Blender property update callbacks being different from the API based getter/setter allows for this to work seamlessly\nThere is no way to specify a filter for specific files when using Blender’s StringProperty with subtype FILE_PATH directly - users can filter from Blender’s file selection GUI\nBlender’s EnumProperty defaults to the first value when the default is not specified, so it is good to explicitly set a default\nBlender ID properties (non API defined custom properties) are very different from bpy.props (API defined). A good guide to some of the basic differences are highlighted here. ID properties having nested levels are not possible to access through the UI (panels, etc). They have to be flat and at the top level of an instance (like object). They can be used as drivers, can be completely customized for ui (using id_properties_ui and update) but don’t have update callbacks and cannot use bpy.msgbus subscriptions as well. Their application for UI needs is pretty limited",
    "crumbs": [
      "Blender"
    ]
  },
  {
    "objectID": "api/blender.html#operators",
    "href": "api/blender.html#operators",
    "title": "Blender",
    "section": "Operators",
    "text": "Operators\n\nMost internal operators require the context to be set correctly before they are invoked. bpy.context.temp_override can be used. Since there can be multiple windows with different areas and regions within, it is always safe to iterate through all for the required window/area/region before setting the context so that everything is updated correctly\nwindow_manager.invoke_confirm in an operator’s invoke is used for confirmation dialogs. window_manager.invoke_props_dialog in an operator’s invoke is used to show a dialog with the operator properties. An explicit draw method can be used to customize the layout of what is shown\nThe execute method of operators can be directly invoked (bypassing invoke etc) using the first param as EXEC_DEFAULT - this is very useful in tests to test operators. EXEC_INVOKE can be used to directly call the operator and run it’s invoke method\nThe most common way to delete an object is to select it and then call an operator like bpy.ops.object.delete(). This can be problematic at times if the view layer is not up to date and whatever is the active object will get deleted. A better way is to explicitly delete the object using bpy.data.objects.remove and passing the object. Avoid using operators if the same can be achieved in a different way. Operators are both slow and can be asynchronous with different context requirements\nBlender does not allow dynamic properties in an operator. To achieve dynamic properties in an operator (to show in the invoke UI for example), a temporary operator has to be created, registered with Blender and invoked. A dynamic PropertyGroup with dynamic properties can be created using the type() method. This dynamic type can be used within a PointerProperty of the temporary operator for dynamic inputs\nbpy.types.Operator.__subclasses__() and bpy.types.PropertyGroup.__subclasses__() can be used to verify whether temporary operators and property groups are being unregistered and garbage collected. sys.getrefcount can be used on a class to get the reference counts",
    "crumbs": [
      "Blender"
    ]
  },
  {
    "objectID": "api/blender.html#viewport",
    "href": "api/blender.html#viewport",
    "title": "Blender",
    "section": "Viewport",
    "text": "Viewport\n\nAn object’s hide_viewport property is not animatable. To support visibility changes that are animatable, a custom property (with get and set callbacks) that controls both the viewport and rendering visibility works better\nAn object’s visible_get() method to get whether the object is visible or not can throw a ReferenceError: StructRNA of type Object has been removed exception at times - one such case is when the object is selected and moved in the viewport using the g operator\nbpy.context.object and bpy.context.active_object are not necessarily interchangeable. The Context Access page specifies the contexts in which the properties are available. One key point to note is that when an object is active, but hidden, bpy.context.active_object will be None. So, even though bpy.context.object is available for use in panels, the active_object property could be useful to distinguish between the active but hidden cases\nThe view_matrix of Blender’s region data can be used to determine the distance of a 3D point to the virtual 3D viewport camera. This works for both the othographic and the more common perspective projection modes. A range of the distance values for an object can be determined by calculating the min and max of the object’s bounding box vertices (8 of them). This allows for a really fast way to determine on a normalized scale how far a point in the object space is from the 3D viewport. We use this to adjust the text size of annotations to create a perception of depth.\nBlender uses a bit of magic math to display the camera view outline in the 3D viewport. The actual camera width and height shown and the position can be determined based on the view_camera_zoom and view_camera_offset params of the region’s 3d data. There is also a dependency on the viewport aspect ratio\nBlender’s camera_to_view_selected (bpy.ops.view3d.camera_to_view_selected()) is a great way to frame a selection. Care should be taken to ensure only what is required is selected (and restored) before calling this operator\nViewport rendering uses OpenGL (bpy.ops.render.opengl). OpenGL context is not setup in the background (-b) mode, which is the same when using the bpy module in headless mode\nMost Blender crashes are due to accessing something before the viewport got updated. Ensuring that the viewport is redrawn eliminates most of these crashes. bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1) as outlined in the Blender Gotchas page is one quick way, but is not guaranteed compatibility in future. Timers/Handlers/Modals are other recommended ways\nForce redrawing viewport using bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1) doesn’t work in background mode - don’t use it in that mode",
    "crumbs": [
      "Blender"
    ]
  },
  {
    "objectID": "api/blender.html#rendering-and-pil",
    "href": "api/blender.html#rendering-and-pil",
    "title": "Blender",
    "section": "Rendering and PIL",
    "text": "Rendering and PIL\n\nBlender’s current default font is Inter (4.x onwards) - the font files are in the datafiles/fonts directory. PIL needs access to the font file to display text\nPIL does not have anti-aliasing for lines drawn using ImageDraw.line. The only alternatives are to have a custom implementation of anti-aliasing or draw to a bigger image and resize using Image.resize using the resample set to something like Resampling.LANCZOS. For the later, font sizes and line widths have to be adjusted accordingly\nPIL’s textbbox can be used to get the bounding box - to determine the text width / height\nPIL’s co-ordinate system is from the top left, where as Blender’s 3D viewport is from bottom left\nPIL does not have text rotation support. The recommendation for this support is to draw the text on a separate image, rotate the image and paste it - not ideal\nBlender’s object_utils.world_to_camera_view (from bpy_extras) can directly be used to get the corresponding 2D coords of a 3D point in the camera space for rendering\nIn the render mode, we can use the inverted value of the world matrix (camera.matrix_world.inverted()) as the view matrix for any computations\nMost of what is available through operators for Blender’s Video Sequence Editor (like bpy.ops.sequencer.image_strip_add) can be done through API as well (scene.sequence_editor_create), which has the added advantage that it is faster and doesn’t require the context to be present\nImages appended to an image strip using elements.append will only have to pass the base name of the images and not the full path\nVideo sequence editor has to be created (and deleted after generating the video) after rendering all the frames, else it will interfere with the rendering as it has higher precedence, so they must be cleared if setup temporarily\nSetting bpy.context.scene.render.use_lock_interface (equivalent of Render &gt; Lock Interface in the UI) seems to help, which prevents viewport updates while rendering\nbpy.context.scene.view_settings.view_transform = \"Standard\", which is the equivalent of Color Management &gt; View Transform in Render/Output properties seems to generate sharper viewport render images. The default from Blender 4.0 is AgX. If annotations with white (1, 1, 1, 1) don’t show up as such in renders, this is the reason\nbpy.data.images[\"Render Result\"] cannot be accessed to get the raw pixels of the render output. An alternative is to attach a Viewer Node in the compositor and access the pixels. However, the pixel values aren’t entirely between 0 and 1 and hence cannot be converted to a PIL image, etc. As outlined here the viewer node output isn’t color corrected etc. So there is no way of accessing the raw bytes (that match the file output) before it is written out to a file\nPIL images have to be flipped (numpy.flipud) for use as bpy.data.images in compositor",
    "crumbs": [
      "Blender"
    ]
  },
  {
    "objectID": "api/blender.html#nodes",
    "href": "api/blender.html#nodes",
    "title": "Blender",
    "section": "Nodes",
    "text": "Nodes\n\nChanging the node tree in a property callback (like set) could lead to a Blender crash when the property is keyframed (see gotchas). The workaround is to do the updates in a one off timer (bpy.app.timers.register(_update_func, first_interval=0.001)). An alternative is also described in the Application Timers page. It is best to not have the node tree structurally change during the rendering process\nNode Group instances can be decoupled from one another by simply making a copy of the node tree - this is also equivalent to making a data block as single-user in Blender. This allows changes to each of the node groups to be independent of others\nPanel placeholders in a Blender’s Geometry Node provide a way to add inputs so that when inputs are iterated, they are iterated in a required order. Dynamically adding a new socket at a specific position isn’t straightforward\nThere doesn’t seem to be an easy way to link a Geometry Node input to a specific material setting (like say the use_backface_culling)\nUsing Ctrl when placing nodes in the Geometry Nodes editor will ensure snapping to the grid and avoid node locations having floating point values\nBoth the Geometry Node editor and Composite editor have the same area type (NODE_EDITOR), so the tree type in the context’s space data (context.space_data.tree_type) has to be used to distinguish between them (eg: CompositorNodeTree for Composite editor)\nThe only way to find nodes that belong to a particular frame is by checking the parent property of all nodes. Alternatively node names can be saved in properties for direct access instead of full node traversal",
    "crumbs": [
      "Blender"
    ]
  },
  {
    "objectID": "api/blender.html#misc",
    "href": "api/blender.html#misc",
    "title": "Blender",
    "section": "Misc",
    "text": "Misc\n\nbpy.msgbus can be used to subscribe to property changes of Blender datablocks. For example, to detect active object changes, bpy.msgbus.subscribe_rna has to be used for the key (bpy.types.LayerObjects, \"active\"). This works for all RNA properties (builtin ones and custom ones) and won’t work for ID properties\nAny object can be used as a owner for Blender’s msgbus subscriptions using bpy.msgbus.subscribe_rna. Using a owner allows to clear all subscriptions by the owner using bpy.msgbus.clear_by_owner\nBlender has a concept of Restricted Context during an extension’s register() and unregister() methods that limits what is available during those methods. For example, the scene entity does not exist in bpy.context in these cases\nBlender’s openvdb support uses nanogrid to check and warn for leaks. Any vdb grids created must be ensured they are cleaned up to avoid memory errors, especially in pytests\nBlender seems to have some wierd caching of contents loaded from vdb files. Overwriting a vdb file that is already loaded and re-loading it as a new object will update the old object as well\nThere is no separate font styling support in Blender (like Bold, Italic etc) - the corresponding font file has to be loaded if that is needed (using blf.load)\nFonts loaded using blf.load have to be unloaded using blf.unload with the same font file as the param and not the returned font id from the load\nFor text and lines drawn using blf/gpu modules, there is a font size and line width discrepancy that depends on the screen resolution. Apparently Blender uses a dpi of 72 internally. bpy.context.preferences.system.dpi and bpy.context.preferences.system.pixel_size have the dpi and pixel size data. (MacOS retina has 144/2 and regular ones 72/1) Text/line widths have to be scaled accordingly\nA set of vertices can be turned to an object using from_pydata of bpy.data.meshes that can be used to create bounding box objects\nbpy.utils.expose_bundled_modules() is needed to access Blender’s bundled openvdb package in the background mode (bpy)\nBlender app handlers (like frame_change_post, etc) are easy to add, but not straightforward to remove. Using the clear will remove all handlers, which is not desirable. The alternative is to remove by using the actual handler name (the function name)\nAlways use Blender’s portable installation to keep environments separate and clean\nNever keep references to Blender data. This is the primary cause of most crashes as outlined in the gotchas",
    "crumbs": [
      "Blender"
    ]
  },
  {
    "objectID": "api/trajectory/styles.html",
    "href": "api/trajectory/styles.html",
    "title": "Styles",
    "section": "",
    "text": "Different styles or representations can be added to Trajectories.",
    "crumbs": [
      "Trajectory",
      "Styles"
    ]
  },
  {
    "objectID": "api/trajectory/styles.html#setup-molecular-nodes",
    "href": "api/trajectory/styles.html#setup-molecular-nodes",
    "title": "Styles",
    "section": "Setup Molecular Nodes",
    "text": "Setup Molecular Nodes\n\nimport molecularnodes as mn\nimport MDAnalysis as mda\nfrom MDAnalysis.tests.datafiles import DCD, PSF, TPR, XTC\n\nu = mda.Universe(PSF, DCD)\ncanvas = mn.Canvas()",
    "crumbs": [
      "Trajectory",
      "Styles"
    ]
  },
  {
    "objectID": "api/trajectory/styles.html#add-trajectory",
    "href": "api/trajectory/styles.html#add-trajectory",
    "title": "Styles",
    "section": "Add Trajectory",
    "text": "Add Trajectory\nA style can be specified when adding the trajectory to Blender as follows:\n\nt = mn.Trajectory(u).add_style(mn.StyleRibbon(quality=4, backbone_radius = 0.5))\ncanvas.frame_object(t)\ncanvas.snapshot()",
    "crumbs": [
      "Trajectory",
      "Styles"
    ]
  },
  {
    "objectID": "api/trajectory/styles.html#add-styles",
    "href": "api/trajectory/styles.html#add-styles",
    "title": "Styles",
    "section": "Add Styles",
    "text": "Add Styles\nStyles can be added to different selections of the universe after it has been added to Blender using the add_style() API.\nTrajectory.add_style(\n    style='spheres',\n    color='common',\n    selection=None,\n    material=None,\n    name=None,\n)\n\nstyle param\n\nThis param can be a string or an instance of nodes.StyleBase class.\nWhen passed as a string, the value can be one of ball_and_stick, cartoon, ribbon, spheres, sticks, surface, etc.\nWhen passed as a nodes.StyleBase instance, the value can be an instance of nodes.StyleBallAndStick, nodes.StyleCartoon, nodes.StyleRibbon, nodes.StyleSpheres, nodes.StyleSticks and nodes.StyleSurface.\n\ncolor param\n\nThis param can be a string or a tuple with rgba values\nWhen passed as a string, the value can be one of default or common\nWhen passed as a tuple a regular rgba tuple with four float values can be used\n\nselection param\n\nThis param can be an MDAnalysis selection phrase or an AtomGroup of the universe\n\nmaterial param\n\nThis param can be a string or an instance of a material instance created using the mn.material API.\nWhen passed as a string, the value can be one of the default materials like MN Default, MN Flat Outline, MN Squishy, MN Transparent Outline, MN Ambient Occlusion or any other material name\n\nname param to give a name to the style\n\n\n# add spheres style to resid 1 and 129\nt.add_style(\n    mn.StyleSpheres(geometry=\"Instance\", subdivisions=4),\n    selection=\"resid 1 129\",\n)\n\n&lt;Trajectory, `universe`: &lt;Universe with 3341 atoms&gt;, `object`: &lt;bpy_struct, Object(\"NewUniverseObject\") at 0x110f85408&gt;\n\n\n\n# frame trajectory and render\ncanvas.frame_object(t)\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# add surface style for resids between 100 and 150 with transparent material\nt.add_style(\n    style=\"surface\", selection=\"resid 100:150\", material=\"MN Transparent Outline\"\n)\n\n&lt;Trajectory, `universe`: &lt;Universe with 3341 atoms&gt;, `object`: &lt;bpy_struct, Object(\"NewUniverseObject\") at 0x110f85408&gt;\n\n\n\n# frame trajectory and render\ncanvas.frame_object(t)\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# add a ball and style for resids 180:200\nt.add_style(mn.StyleBallAndStick(quality=4), selection=u.select_atoms(\"resid 180:200\"))\n\n&lt;Trajectory, `universe`: &lt;Universe with 3341 atoms&gt;, `object`: &lt;bpy_struct, Object(\"NewUniverseObject\") at 0x110f85408&gt;\n\n\n\n# frame trajectory and render\ncanvas.frame_object(t)\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# add surface style for resids 40:50 with transparent uniform color\nt.add_style(style=\"surface\", selection=\"resid 40:50\", color=(0.162, 0.624, 0.196, 0.5))\n\n&lt;Trajectory, `universe`: &lt;Universe with 3341 atoms&gt;, `object`: &lt;bpy_struct, Object(\"NewUniverseObject\") at 0x110f85408&gt;\n\n\n\n# frame trajectory and render\ncanvas.frame_object(t)\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n# create a sticks style instance\ns = mn.nodes.styles.StyleSticks()\n# set radius to 0.1\ns.radius = 0.1\n# add style with a style instance\nt.add_style(style=s, selection=\"resid 40:50\")\n\n&lt;Trajectory, `universe`: &lt;Universe with 3341 atoms&gt;, `object`: &lt;bpy_struct, Object(\"NewUniverseObject\") at 0x110f85408&gt;\n\n\n\n# frame trajectory and render\ncanvas.frame_object(t)\ncanvas.snapshot()",
    "crumbs": [
      "Trajectory",
      "Styles"
    ]
  },
  {
    "objectID": "api/trajectory/styles.html#access-styles",
    "href": "api/trajectory/styles.html#access-styles",
    "title": "Styles",
    "section": "Access Styles",
    "text": "Access Styles\nStyles added to a trajectory can be accessed using the styles interface. This interface allows access to all the style specific parameters (Geometry Node inputs).\n\nfor s in t.styles:\n    print(s)\n\n&lt;molecularnodes.nodes.geometry.DynamicStyleInterface_Ribbon object at 0x362cacd90&gt;\n&lt;molecularnodes.nodes.geometry.DynamicStyleInterface_Spheres object at 0x362f82fd0&gt;\n&lt;molecularnodes.nodes.geometry.DynamicStyleInterface_Surface object at 0x362f890d0&gt;\n&lt;molecularnodes.nodes.geometry.DynamicStyleInterface_Ball and Stick object at 0x35d0e5750&gt;\n&lt;molecularnodes.nodes.geometry.DynamicStyleInterface_Surface.001 object at 0x362f81b10&gt;\n&lt;molecularnodes.nodes.geometry.DynamicStyleInterface_Sticks object at 0x10696bd10&gt;\n\n\n\n# access the first style - cartoon of the trajectory\ns = t.styles[0]\ns\n\n&lt;molecularnodes.nodes.geometry.DynamicStyleInterface_Ribbon at 0x362f83110&gt;\n\n\n\n# access the last style - sticks resid 40:50\ns = t.styles[-1]\n# set the sticks radius to 0.3\ns.sticks_radius = 0.3\n\n\n# frame trajectory and render\ncanvas.frame_object(t)\ncanvas.snapshot()",
    "crumbs": [
      "Trajectory",
      "Styles"
    ]
  },
  {
    "objectID": "api/trajectory/styles.html#remove-styles",
    "href": "api/trajectory/styles.html#remove-styles",
    "title": "Styles",
    "section": "Remove Styles",
    "text": "Remove Styles\nStyles can be removed using the remove method of the style interface.\n\n# remove last two styles\nt.styles[-1].remove()\nt.styles[-1].remove()\n\n\n# frame trajectory and render\ncanvas.frame_object(t)\ncanvas.snapshot()",
    "crumbs": [
      "Trajectory",
      "Styles"
    ]
  },
  {
    "objectID": "api/trajectory/solvent.html",
    "href": "api/trajectory/solvent.html",
    "title": "Solvent Density",
    "section": "",
    "text": "This example follows the Calculating the solvent density around a protein example from the MDAnalysis user guide.\nimport MDAnalysis as mda\nimport molecularnodes as mn\nimport numpy as np\nfrom MDAnalysis import transformations as trans\nfrom MDAnalysis.analysis import density\nfrom MDAnalysis.tests.datafiles import TPR, XTC\n\ncanvas = mn.Canvas()",
    "crumbs": [
      "Trajectory",
      "Solvent Density"
    ]
  },
  {
    "objectID": "api/trajectory/solvent.html#load-and-transform-universe",
    "href": "api/trajectory/solvent.html#load-and-transform-universe",
    "title": "Solvent Density",
    "section": "Load and transform Universe",
    "text": "Load and transform Universe\n\nu = mda.Universe(TPR, XTC)\n\nprotein = u.select_atoms(\"protein\")\nwater = u.select_atoms(\"not protein\")\n\nworkflow = [\n    trans.unwrap(u.atoms),  # unwrap all fragments\n    trans.center_in_box(\n        protein,\n        center=\"geometry\",  # move atoms to center protein\n    ),\n    trans.wrap(\n        water,\n        compound=\"residues\",  # wrap each water back into box\n    ),\n    trans.fit_rot_trans(\n        protein,\n        protein,\n        weights=\"mass\",  # align protein to first frame\n    ),\n]\n\nu.trajectory.add_transformations(*workflow)",
    "crumbs": [
      "Trajectory",
      "Solvent Density"
    ]
  },
  {
    "objectID": "api/trajectory/solvent.html#analyse-and-export-.dx",
    "href": "api/trajectory/solvent.html#analyse-and-export-.dx",
    "title": "Solvent Density",
    "section": "Analyse and Export .dx",
    "text": "Analyse and Export .dx\n\now = u.select_atoms(\"name OW\")\ndens = density.DensityAnalysis(ow, delta=4.0, padding=2)\ndens.run()\n# convert density unit to TIP4P\ndens.results.density.convert_density(\"TIP4P\")\ndens.results.density.export(\"water.dx\")",
    "crumbs": [
      "Trajectory",
      "Solvent Density"
    ]
  },
  {
    "objectID": "api/trajectory/solvent.html#add-universe-to-blender",
    "href": "api/trajectory/solvent.html#add-universe-to-blender",
    "title": "Solvent Density",
    "section": "Add Universe to Blender",
    "text": "Add Universe to Blender\nImport universe as a Trajectory and add a ribbon style to represent the protein. We also add a style to the non-rotein atoms, sliced along the y axis. After taking the snapshot for visual reference we remove the sphere style as we will be showing the water as a density.\n\nprotein_center = np.mean(protein.atoms.positions, axis=0)\n\nt = mn.Trajectory(u).add_style(mn.StyleRibbon(quality=5, backbone_radius=2))\nt.add_style(\n    mn.StyleSpheres(\"Instance\", subdivisions=4),\n    selection=f\"not protein and prop y &gt;= {protein_center[1]}\",\n)\n\ncanvas.frame_view(t, (np.pi / 2, 0, np.pi / 3))\ncanvas.snapshot()\nt.styles[-1].remove()",
    "crumbs": [
      "Trajectory",
      "Solvent Density"
    ]
  },
  {
    "objectID": "api/trajectory/solvent.html#add-density-component",
    "href": "api/trajectory/solvent.html#add-density-component",
    "title": "Solvent Density",
    "section": "Add density component",
    "text": "Add density component\nWe can load the density that was written-out from the analysis performed previously as a Density entity.\n\n# load density file\nd = mn.entities.density.io.load(\n    file_path=\"water.dx\",\n    style=\"density_iso_surface\",\n    overwrite=True,\n)\n# add a density info annotation for the density entity\nda = d.annotations.add_density_info()\n# only show the filename and ISO value\nda.show_origin = da.show_delta = da.show_shape = False",
    "crumbs": [
      "Trajectory",
      "Solvent Density"
    ]
  },
  {
    "objectID": "api/trajectory/solvent.html#visualization",
    "href": "api/trajectory/solvent.html#visualization",
    "title": "Solvent Density",
    "section": "Visualization",
    "text": "Visualization\n\nSet density style values\n\n# get the density style\nds = d.styles[0]\n# set the positive color to blue with 50% opacity\nds.positive_color = (0, 0, 1, 0.5)\n\n\n\nISO Value 0.5\n\n# set ISO value to 0.5\nds.iso_value = 0.5\n\n\n# frame the density component and render\ncanvas.frame_view(d, viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n\nISO Value 0.5 with Contours\n\n# set ISO value to 0.5\nds.iso_value = 0.5\n# enable contours\nds.show_contours = True\n# set contour thickness\nds.contour_thickness = 0.25\n# set contour colors\nds.contour_color = (1, 1, 1, 1)\n\n\n# frame the density component and render\ncanvas.frame_view(d.get_view(), viewpoint=\"front\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n\nFrom Top with Grid Axes\n\n# add grid axes annotation\nga = d.annotations.add_grid_axes_3d()\n\n\n# set viewpoint to top\ncanvas.frame_view(d.get_view(), viewpoint=\"top\")\ncanvas.snapshot()\n# hide grid axes\nga.visible = False\n\n\n\n\n\n\n\n\n\n\nISO Value 0.5 sliced from Left\n\n# slice the grid from the left 50%\nds.slice_left = 50\n\n\n# set viewpoint to left\ncanvas.frame_view(d.get_view(), viewpoint=\"left\")\ncanvas.snapshot()\n\n\n\n\n\n\n\n\n\n\nOnly Contours\n\n# reset slicing\nds.slice_left = 0\n# only show contours\nds.only_contours = True\n\n\n# set viewpoint to front\ncanvas.frame_view(d.get_view(), viewpoint=\"front\")\ncanvas.snapshot()",
    "crumbs": [
      "Trajectory",
      "Solvent Density"
    ]
  },
  {
    "objectID": "api/reference/entities.Ensemble.html",
    "href": "api/reference/entities.Ensemble.html",
    "title": "entities.Ensemble",
    "section": "",
    "text": "entities.Ensemble(file_path)\n\n\n\n\n\nName\nDescription\n\n\n\n\ninstance_collection\nThe instances of the ensemble.\n\n\nstyles\nGet the styles in the tree.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate_object\nCreate a 3D object for the ensemble.\n\n\nget_view\nGet the 3D bounding box of the entity object\n\n\nset_frame\nUpdate the underlying data to correspond to changes in the scene frame.\n\n\n\n\n\nentities.Ensemble.create_object(\n    name='NewEnsemble',\n    node_setup=True,\n    world_scale=0.01,\n    fraction=1.0,\n    simplify=False,\n)\nCreate a 3D object for the ensemble.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe name of the model, by default “NewEnsemble”\n'NewEnsemble'\n\n\nnode_setup\nbool\nWhether to setup nodes for the data and instancing objects, by default True\nTrue\n\n\nworld_scale\nfloat\nScaling transform for the coordinates before loading in to Blender, by default 0.01\n0.01\n\n\nfraction\nfloat\nThe fraction of the instances to display on loading. Reducing can help with performance, by default 1.0\n1.0\n\n\nsimplify\nbool\nWhether to instance the given models or simplify them for debugging and performance, by default False\nFalse\n\n\n\n\n\n\nCreates a data object which stores all of the required instancing information. If there are molecules to be instanced, they are also created in their own data collection.\n\n\n\n\nentities.Ensemble.get_view()\nGet the 3D bounding box of the entity object\n\n\n\nentities.Ensemble.set_frame(frame)\nUpdate the underlying data to correspond to changes in the scene frame.\nThis method should be implemented by subclasses to update the entity’s data based on the given frame number. This can include updating positions and performing other necessary calculations.\nArgs: frame (int): The frame number to update the entity’s data to.\nRaises: NotImplementedError: If the method is not implemented by a subclass.",
    "crumbs": [
      "Reference",
      "Entity",
      "entities.Ensemble"
    ]
  },
  {
    "objectID": "api/reference/entities.Ensemble.html#attributes",
    "href": "api/reference/entities.Ensemble.html#attributes",
    "title": "entities.Ensemble",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ninstance_collection\nThe instances of the ensemble.\n\n\nstyles\nGet the styles in the tree.",
    "crumbs": [
      "Reference",
      "Entity",
      "entities.Ensemble"
    ]
  },
  {
    "objectID": "api/reference/entities.Ensemble.html#methods",
    "href": "api/reference/entities.Ensemble.html#methods",
    "title": "entities.Ensemble",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncreate_object\nCreate a 3D object for the ensemble.\n\n\nget_view\nGet the 3D bounding box of the entity object\n\n\nset_frame\nUpdate the underlying data to correspond to changes in the scene frame.\n\n\n\n\n\nentities.Ensemble.create_object(\n    name='NewEnsemble',\n    node_setup=True,\n    world_scale=0.01,\n    fraction=1.0,\n    simplify=False,\n)\nCreate a 3D object for the ensemble.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe name of the model, by default “NewEnsemble”\n'NewEnsemble'\n\n\nnode_setup\nbool\nWhether to setup nodes for the data and instancing objects, by default True\nTrue\n\n\nworld_scale\nfloat\nScaling transform for the coordinates before loading in to Blender, by default 0.01\n0.01\n\n\nfraction\nfloat\nThe fraction of the instances to display on loading. Reducing can help with performance, by default 1.0\n1.0\n\n\nsimplify\nbool\nWhether to instance the given models or simplify them for debugging and performance, by default False\nFalse\n\n\n\n\n\n\nCreates a data object which stores all of the required instancing information. If there are molecules to be instanced, they are also created in their own data collection.\n\n\n\n\nentities.Ensemble.get_view()\nGet the 3D bounding box of the entity object\n\n\n\nentities.Ensemble.set_frame(frame)\nUpdate the underlying data to correspond to changes in the scene frame.\nThis method should be implemented by subclasses to update the entity’s data based on the given frame number. This can include updating positions and performing other necessary calculations.\nArgs: frame (int): The frame number to update the entity’s data to.\nRaises: NotImplementedError: If the method is not implemented by a subclass.",
    "crumbs": [
      "Reference",
      "Entity",
      "entities.Ensemble"
    ]
  },
  {
    "objectID": "api/reference/annotations.base.html",
    "href": "api/reference/annotations.base.html",
    "title": "annotations.base",
    "section": "",
    "text": "annotations.base\n\n\n\n\n\nName\nDescription\n\n\n\n\nBaseAnnotation\nBase class for an Annotation\n\n\n\n\n\nannotations.base.BaseAnnotation()\nBase class for an Annotation\nAny Entity that needs annotations support can derive from this base class for Entity specific annotations. The derived entity annotation will have to implement ‘init_subclass’ to register with the Entity’s annotation manager and ‘init’ to pass the entity to annotations.\nEntity annotations will have to implement the ‘draw’ method that specifies how to display the annotations An optional ‘validate’ method can be provided to validate annotation inputs An optional ‘defaults’ method can be provided to set default values to the annotation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nname\nstr\nName (label) of the annotation\n\n\ninterface\nAnnotationInterface\nDynamic interface of the annotation instance\n\n\nviewport_width\nint\nWidth of the viewport region in pixels\n\n\nviewport_height\nint\nHeight of the viewport region in pixels\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndefaults\nOptional method to set default annotation params\n\n\ndistance\nDistance between two vectors\n\n\ndraw\nThe main draw method for an annotation\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\nvalidate\nOptional method to validate annotation inputs\n\n\n\n\n\nannotations.base.BaseAnnotation.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.defaults()\nOptional method to set default annotation params This is called only once when the annotation instance is created\n\n\n\nannotations.base.BaseAnnotation.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw()\nThe main draw method for an annotation This is called multiple times in the 3D viewport draw handler\n\n\n\nannotations.base.BaseAnnotation.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_bpy_image(pos_2d, image, scale=1.0)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_text_2d(pos_2d, text, overrides=None)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_text_3d(pos_3d, text, overrides=None)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.validate(input_name=None)\nOptional method to validate annotation inputs This is called during annotation creation and any time the inputs change either through the API or GUI. Can return False or raise an exception when validation fails. Returns True when all validations succeed.\nNote: This method gets called when any inputs change, so updating values in here will lead to a recursive loop and should not be done.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_name\nstr\nThe input name update that trigged this validation callback. When no specific input name is available, None is passed.\nNone",
    "crumbs": [
      "Reference",
      "Annotations",
      "annotations.base"
    ]
  },
  {
    "objectID": "api/reference/annotations.base.html#classes",
    "href": "api/reference/annotations.base.html#classes",
    "title": "annotations.base",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBaseAnnotation\nBase class for an Annotation\n\n\n\n\n\nannotations.base.BaseAnnotation()\nBase class for an Annotation\nAny Entity that needs annotations support can derive from this base class for Entity specific annotations. The derived entity annotation will have to implement ‘init_subclass’ to register with the Entity’s annotation manager and ‘init’ to pass the entity to annotations.\nEntity annotations will have to implement the ‘draw’ method that specifies how to display the annotations An optional ‘validate’ method can be provided to validate annotation inputs An optional ‘defaults’ method can be provided to set default values to the annotation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nname\nstr\nName (label) of the annotation\n\n\ninterface\nAnnotationInterface\nDynamic interface of the annotation instance\n\n\nviewport_width\nint\nWidth of the viewport region in pixels\n\n\nviewport_height\nint\nHeight of the viewport region in pixels\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndefaults\nOptional method to set default annotation params\n\n\ndistance\nDistance between two vectors\n\n\ndraw\nThe main draw method for an annotation\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\nvalidate\nOptional method to validate annotation inputs\n\n\n\n\n\nannotations.base.BaseAnnotation.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.defaults()\nOptional method to set default annotation params This is called only once when the annotation instance is created\n\n\n\nannotations.base.BaseAnnotation.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw()\nThe main draw method for an annotation This is called multiple times in the 3D viewport draw handler\n\n\n\nannotations.base.BaseAnnotation.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_bpy_image(pos_2d, image, scale=1.0)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_text_2d(pos_2d, text, overrides=None)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_text_3d(pos_3d, text, overrides=None)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\nannotations.base.BaseAnnotation.validate(input_name=None)\nOptional method to validate annotation inputs This is called during annotation creation and any time the inputs change either through the API or GUI. Can return False or raise an exception when validation fails. Returns True when all validations succeed.\nNote: This method gets called when any inputs change, so updating values in here will lead to a recursive loop and should not be done.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_name\nstr\nThe input name update that trigged this validation callback. When no specific input name is available, None is passed.\nNone",
    "crumbs": [
      "Reference",
      "Annotations",
      "annotations.base"
    ]
  },
  {
    "objectID": "api/reference/StyleBallAndStick.html",
    "href": "api/reference/StyleBallAndStick.html",
    "title": "StyleBallAndStick",
    "section": "",
    "text": "StyleBallAndStick(\n    quality=2,\n    sphere_geometry='Instance',\n    sphere_radius=0.3,\n    bond_split=False,\n    bond_radius=0.3,\n    bond_find=False,\n    bond_find_scale=1.0,\n    color_blur=False,\n    shade_smooth=True,\n)\nStyle class for Style Ball and Stick\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquality\nint\nA lower value results in less geometry, with a higher value meaning better looking but more dense geometry\n2\n\n\nsphere_geometry\nAny\nShow spheres as a Point Cloud, Instances of a mesh Icosphere, or realised Mesh instances of an Icosphere. Point cloud is best for performance and should definitely be used if rendering in Cycles.\n'Instance'\n\n\nsphere_radius\nfloat\nScale the vdw_radii attribute before setting the radius for the spheres\n0.3\n\n\nbond_split\nbool\nSplit apart double and triple bonds visually\nFalse\n\n\nbond_radius\nfloat\nSet the radius for the generated bonds in Angstroms\n0.3\n\n\nbond_find\nbool\nFind possible bonds for the selected atoms based on a distance search. Unselected atoms maintain any bonds they already have. Bonds that are found are all treated as single bonds\nFalse\n\n\nbond_find_scale\nfloat\nScale the VDW radii of the atoms when searching for bonds\n1.0\n\n\ncolor_blur\nbool\nInterpolate between colors when enabled. When disabled the faces will take their color from their corresponding atom without interpolating\nFalse\n\n\nshade_smooth\nbool\nApply smooth shading to the created geometry\nTrue\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nupdate_style_node\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nStyleBallAndStick.update_style_node(node_style)\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnode_style\nGeometryNodeGroup\nThe Blender GeometryNodeGroup to update\nrequired",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleBallAndStick"
    ]
  },
  {
    "objectID": "api/reference/StyleBallAndStick.html#parameters",
    "href": "api/reference/StyleBallAndStick.html#parameters",
    "title": "StyleBallAndStick",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nquality\nint\nA lower value results in less geometry, with a higher value meaning better looking but more dense geometry\n2\n\n\nsphere_geometry\nAny\nShow spheres as a Point Cloud, Instances of a mesh Icosphere, or realised Mesh instances of an Icosphere. Point cloud is best for performance and should definitely be used if rendering in Cycles.\n'Instance'\n\n\nsphere_radius\nfloat\nScale the vdw_radii attribute before setting the radius for the spheres\n0.3\n\n\nbond_split\nbool\nSplit apart double and triple bonds visually\nFalse\n\n\nbond_radius\nfloat\nSet the radius for the generated bonds in Angstroms\n0.3\n\n\nbond_find\nbool\nFind possible bonds for the selected atoms based on a distance search. Unselected atoms maintain any bonds they already have. Bonds that are found are all treated as single bonds\nFalse\n\n\nbond_find_scale\nfloat\nScale the VDW radii of the atoms when searching for bonds\n1.0\n\n\ncolor_blur\nbool\nInterpolate between colors when enabled. When disabled the faces will take their color from their corresponding atom without interpolating\nFalse\n\n\nshade_smooth\nbool\nApply smooth shading to the created geometry\nTrue",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleBallAndStick"
    ]
  },
  {
    "objectID": "api/reference/StyleBallAndStick.html#methods",
    "href": "api/reference/StyleBallAndStick.html#methods",
    "title": "StyleBallAndStick",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nupdate_style_node\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nStyleBallAndStick.update_style_node(node_style)\nUpdate the Blender node inputs with values from this style’s attributes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnode_style\nGeometryNodeGroup\nThe Blender GeometryNodeGroup to update\nrequired",
    "crumbs": [
      "Reference",
      "Styles",
      "StyleBallAndStick"
    ]
  },
  {
    "objectID": "api/reference/Trajectory.html",
    "href": "api/reference/Trajectory.html",
    "title": "Trajectory",
    "section": "",
    "text": "Trajectory(\n    universe,\n    name='NewUniverseObject',\n    world_scale=0.01,\n    create_object=True,\n)\nMD trajectory entity for Blender visualization.\nComplete interface for loading, visualizing, and manipulating MD trajectories in Blender using MDAnalysis.\nFeatures: trajectory loading, attribute computation, selection management, visual styling, frame interpolation/averaging, periodic boundary handling, Blender animation integration.",
    "crumbs": [
      "Reference",
      "Entity",
      "Trajectory"
    ]
  },
  {
    "objectID": "api/reference/Trajectory.html#attributes",
    "href": "api/reference/Trajectory.html#attributes",
    "title": "Trajectory",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\nuniverse\nmda.Universe\nMDAnalysis Universe with topology and trajectory\n\n\nframe_manager\nFrameManager\nPosition caching and frame updates\n\n\nselections\nSelectionManager\nDynamic atom selections\n\n\ncalculations\ndict\nCustom per-frame calculations\n\n\nannotations\nTrajectoryAnnotationManager\nTrajectory annotations\n\n\nworld_scale\nfloat\nScale factor from Angstroms to Blender units\n\n\nframe\nint\nCurrent animation frame (synced with Blender)\n\n\nsubframes\nint\nInterpolation steps between frames\n\n\noffset\nint\nFrame offset for playback\n\n\naverage\nint\nNumber of frames to average (smoothing)\n\n\ncorrect_periodic\nbool\nApply periodic boundary corrections\n\n\ninterpolate\nbool\nEnable position interpolation\n\n\ndssp\nDSSPManager\nA DSSP Manager to compute and show secondary structures",
    "crumbs": [
      "Reference",
      "Entity",
      "Trajectory"
    ]
  },
  {
    "objectID": "api/reference/Trajectory.html#examples",
    "href": "api/reference/Trajectory.html#examples",
    "title": "Trajectory",
    "section": "Examples",
    "text": "Examples\n\nimport MDAnalysis as mda\nfrom MDAnalysis.tests.datafiles import PSF, DCD\nimport molecularnodes as mn\ncanvas = mn.Canvas()\nu = mda.Universe(PSF, DCD)\ntraj = mn.entities.Trajectory(u)\ntraj.add_style(mn.StyleSpheres(geometry=\"Mesh\"), selection=\"resname LYS\")\ncanvas.frame_view(traj)\ncanvas.snapshot()",
    "crumbs": [
      "Reference",
      "Entity",
      "Trajectory"
    ]
  },
  {
    "objectID": "api/reference/Trajectory.html#methods",
    "href": "api/reference/Trajectory.html#methods",
    "title": "Trajectory",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nadd_style\nAdd a visual style to the trajectory.\n\n\ncreate_object\nCreate and initialize Blender object for trajectory.\n\n\nget_view\nGet the 3D bounding box of a selection within the trajectory\n\n\nreset_playback\nSet the playback settings to their default values\n\n\nset_frame\nUpdate trajectory state for scene frame.\n\n\n\n\nadd_style\nTrajectory.add_style(\n    style='spheres',\n    color='common',\n    selection=None,\n    material=None,\n    name=None,\n)\nAdd a visual style to the trajectory.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstyle\nbpy.types.GeometryNodeTree | str\nThe style to apply to the trajectory. Can be a GeometryNodeTree or a string identifying a predefined style (e.g., “spheres”, “sticks”, “ball_stick”). Default is “spheres”.\n'spheres'\n\n\ncolor\nstr | None\nThe coloring scheme to apply. Can be “common” (element-based coloring), “chain”, “residue”, or other supported schemes. If None, no coloring is applied. Default is “common”.\n'common'\n\n\nselection\nstr | AtomGroup | None\nApply the style only to atoms matching this selection. Can be: - A string referring to an existing boolean attribute on the trajectory - A AtomGroup object defining a selection criteria - None to apply to all atoms (default)\nNone\n\n\nmaterial\nbpy.types.Material | str | None\nThe material to apply to the styled atoms. Can be a Blender Material object, a string with a material name, or None to use default materials. Default is None.\nNone\n\n\nname\nstr | None\nThe label for this style\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectory\nReturns self for method chaining.\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an unsupported style string is passed\n\n\n\n\n\nNotes\nIf a selection is provided, it will be evaluated and stored as a new named attribute on the trajectory with an automatically generated name (sel_N).\n\n\n\ncreate_object\nTrajectory.create_object(name='NewUniverseObject')\nCreate and initialize Blender object for trajectory.\nCreates mesh, computes attributes, sets up modifiers, registers with MolecularNodes.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName for the Blender object\n\"NewUniverseObject\"\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Object\nCreated Blender object\n\n\n\n\n\n\nget_view\nTrajectory.get_view(selection=None, frame=None)\nGet the 3D bounding box of a selection within the trajectory\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselection\nstr | AtomGroup\nA selection phrase or AtomGroup When not specified, the whole entity is considered\nNone\n\n\nframe\nint | None\nFrame number of trajectory to use for calculating bounds. When not specified, current trajectory frame is used\nNone\n\n\n\n\n\n\nreset_playback\nTrajectory.reset_playback()\nSet the playback settings to their default values\n\n\nset_frame\nTrajectory.set_frame(frame)\nUpdate trajectory state for scene frame.\nMain entry point called by Blender’s animation system. Updates positions, selections, and calculations with recursion prevention.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nframe\nint\nScene frame number (mapping applied to get Universe frame)\nrequired\n\n\n\n\n\nNotes\nTypically called automatically by frame change handlers, not user code.",
    "crumbs": [
      "Reference",
      "Entity",
      "Trajectory"
    ]
  },
  {
    "objectID": "api/reference/session.MNSession.html",
    "href": "api/reference/session.MNSession.html",
    "title": "session.MNSession",
    "section": "",
    "text": "session.MNSession()\n\n\n\n\n\nName\nDescription\n\n\n\n\nn_items\nThe number of items being tracked by this session.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_trajectory\nAdd a new trajectory\n\n\nclear\nRemove references to all molecules, trajectories and ensembles.\n\n\nget_object\nTry and get an object from Blender’s object database that matches the uuid given.\n\n\nget_trajectory\nGet trajectory instance by name\n\n\nprune\nRemove any entities that no longer exist in Blender\n\n\nregister_entity\nAdd entity to the dictionary\n\n\nremove\nRemove an entity by uuid\n\n\nremove_entity\nRemove entity from the dictionary\n\n\nremove_trajectory\nRemove an existing trajectory\n\n\n\n\n\nsession.MNSession.add_trajectory(\n    universe,\n    style='vdw',\n    name='NewUniverseObject',\n)\nAdd a new trajectory\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuniverse\nmda.Universe | AtomGroup\nMDAnalysis Universe or AtomGroup instance\nrequired\n\n\nstyle\nstr | None\nThe style to apply to the Universe or AtomGroup.\n'vdw'\n\n\nname\nstr\nName of the trajectory object in Blender\n'NewUniverseObject'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectory\nThe newly added Trajectory instance\n\n\n\n\n\n\n\nsession.MNSession.clear()\nRemove references to all molecules, trajectories and ensembles.\n\n\n\nsession.MNSession.get_object(uuid)\nTry and get an object from Blender’s object database that matches the uuid given.\nIf nothing is be found to match, return None.\n\n\n\nsession.MNSession.get_trajectory(name)\nGet trajectory instance by name\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName of the trajectory object\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectory\nA Trajectory instance\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError if trajectory is not found\n\n\n\n\n\n\n\n\nsession.MNSession.prune()\nRemove any entities that no longer exist in Blender\n\n\n\nsession.MNSession.register_entity(item)\nAdd entity to the dictionary\n\n\n\nsession.MNSession.remove(uuid)\nRemove an entity by uuid\n\n\n\nsession.MNSession.remove_entity(uuid)\nRemove entity from the dictionary\n\n\n\nsession.MNSession.remove_trajectory(trajectory)\nRemove an existing trajectory\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntrajectory\nTrajectory | str\nA Trajectory instance or name of the trajectory\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError if trajectory name is not found",
    "crumbs": [
      "Reference",
      "Session",
      "session.MNSession"
    ]
  },
  {
    "objectID": "api/reference/session.MNSession.html#attributes",
    "href": "api/reference/session.MNSession.html#attributes",
    "title": "session.MNSession",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nn_items\nThe number of items being tracked by this session.",
    "crumbs": [
      "Reference",
      "Session",
      "session.MNSession"
    ]
  },
  {
    "objectID": "api/reference/session.MNSession.html#methods",
    "href": "api/reference/session.MNSession.html#methods",
    "title": "session.MNSession",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_trajectory\nAdd a new trajectory\n\n\nclear\nRemove references to all molecules, trajectories and ensembles.\n\n\nget_object\nTry and get an object from Blender’s object database that matches the uuid given.\n\n\nget_trajectory\nGet trajectory instance by name\n\n\nprune\nRemove any entities that no longer exist in Blender\n\n\nregister_entity\nAdd entity to the dictionary\n\n\nremove\nRemove an entity by uuid\n\n\nremove_entity\nRemove entity from the dictionary\n\n\nremove_trajectory\nRemove an existing trajectory\n\n\n\n\n\nsession.MNSession.add_trajectory(\n    universe,\n    style='vdw',\n    name='NewUniverseObject',\n)\nAdd a new trajectory\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuniverse\nmda.Universe | AtomGroup\nMDAnalysis Universe or AtomGroup instance\nrequired\n\n\nstyle\nstr | None\nThe style to apply to the Universe or AtomGroup.\n'vdw'\n\n\nname\nstr\nName of the trajectory object in Blender\n'NewUniverseObject'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectory\nThe newly added Trajectory instance\n\n\n\n\n\n\n\nsession.MNSession.clear()\nRemove references to all molecules, trajectories and ensembles.\n\n\n\nsession.MNSession.get_object(uuid)\nTry and get an object from Blender’s object database that matches the uuid given.\nIf nothing is be found to match, return None.\n\n\n\nsession.MNSession.get_trajectory(name)\nGet trajectory instance by name\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName of the trajectory object\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTrajectory\nA Trajectory instance\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError if trajectory is not found\n\n\n\n\n\n\n\n\nsession.MNSession.prune()\nRemove any entities that no longer exist in Blender\n\n\n\nsession.MNSession.register_entity(item)\nAdd entity to the dictionary\n\n\n\nsession.MNSession.remove(uuid)\nRemove an entity by uuid\n\n\n\nsession.MNSession.remove_entity(uuid)\nRemove entity from the dictionary\n\n\n\nsession.MNSession.remove_trajectory(trajectory)\nRemove an existing trajectory\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntrajectory\nTrajectory | str\nA Trajectory instance or name of the trajectory\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError if trajectory name is not found",
    "crumbs": [
      "Reference",
      "Session",
      "session.MNSession"
    ]
  },
  {
    "objectID": "api/reference/entities.trajectory.annotations.html",
    "href": "api/reference/entities.trajectory.annotations.html",
    "title": "entities.trajectory.annotations",
    "section": "",
    "text": "entities.trajectory.annotations\n\n\n\n\n\nName\nDescription\n\n\n\n\nAtomInfo\nAtom Info Trajectory Annotation\n\n\nCOM\nCenter-of-Mass Trajectory Annotation\n\n\nCOMDistance\nDistance between Center-of-Masses Trajectory Annotation\n\n\nCanonicalDihedrals\nCanonical Dihedrals of a given residue\n\n\nTrajectoryAnnotation\nBase class for a Trajectory Annotation\n\n\nTrajectoryAnnotationManager\nAnnotation Manager for Trajectory Entity\n\n\nUniverseInfo\nUniverse Info Trajectory Annotation\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo(trajectory)\nAtom Info Trajectory Annotation\nThis annotation shows the atom info of a selection. This annotation can be added using the ‘add_atom_info’ method of the trajectory’s annotation manager: trajectory.annotations.add_atom_info(…)\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nselection\nstr\nMDAnalysis selection phrase to select the atom group\n\n\nshow_resid\nbool\nWhether or not to show the res ID along with the atom name\n\n\nshow_segid\nbool\nWhether or not to show the seg ID along with the atom name\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM(trajectory)\nCenter-of-Mass Trajectory Annotation\nThis annotation shows the center-of-mass of a selection. This annotation can be added using the ‘add_com’ method of the trajectory’s annotation manager: trajectory.annotations.add_com(…)\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nselection\nstr\nMDAnalysis selection phrase to select the atom group\n\n\ntext\nstr\nText do display at the center-of-mass\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.trajectory.annotations.COM.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_bpy_image(pos_2d, image, scale=1.0)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_text_2d(pos_2d, text, overrides=None)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_text_3d(pos_3d, text, overrides=None)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance(trajectory)\nDistance between Center-of-Masses Trajectory Annotation\nThis annotation shows the distance between center-of-masses of two selections. This annotation can be added using the ‘add_com_distance’ method of the trajectory’s annotation manager: trajectory.annotations.add_com_distance(…)\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nselection1\nstr\nMDAnalysis selection phrase to select the first atom group\n\n\nselection2\nstr\nMDAnalysis selection phrase to select the second atom group\n\n\ntext1\nstr\nText do display at the first center-of-mass\n\n\ntext2\nstr\nText do display at the second center-of-mass\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals(trajectory)\nCanonical Dihedrals of a given residue\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nresid\nint\nThe residue number\n\n\nshow_atom_names\nbool\nWhether or not to show the individual atom names in the residue\n\n\nshow_direction\nbool\nWhether or not to show the arc indicating the angle direction\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.bpy_image_to_pil_image(\n    bpy_image,\n)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_bmesh(\n    bm,\n    overrides=None,\n)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation(trajectory)\nBase class for a Trajectory Annotation\nAll trajectory annotations should derive from this base class and implement the ‘draw’ method. All derived classes will have access to the trajectory instance (self.trajectory) and all the annotation inputs and common params via self.interface.\nAn optional ‘defaults’ method can be provided to set default values to the annotation.\n\n\n\n\n\nName\nDescription\n\n\n\n\nviewport_height\nGet the viewport region height in pixels\n\n\nviewport_width\nGet the viewport region width in pixels\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndefaults\nOptional method to set default annotation params\n\n\ndistance\nDistance between two vectors\n\n\ndraw\nThe main draw method for an annotation\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\nvalidate\nOptional method to validate annotation inputs\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.bpy_image_to_pil_image(\n    bpy_image,\n)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.defaults()\nOptional method to set default annotation params This is called only once when the annotation instance is created\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw()\nThe main draw method for an annotation This is called multiple times in the 3D viewport draw handler\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_bmesh(\n    bm,\n    overrides=None,\n)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.validate(input_name=None)\nOptional method to validate annotation inputs This is called during annotation creation and any time the inputs change either through the API or GUI. Can return False or raise an exception when validation fails. Returns True when all validations succeed.\nNote: This method gets called when any inputs change, so updating values in here will lead to a recursive loop and should not be done.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_name\nstr\nThe input name update that trigged this validation callback. When no specific input name is available, None is passed.\nNone\n\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotationManager(entity)\nAnnotation Manager for Trajectory Entity\n\n\n\n\n\nName\nDescription\n\n\n\n\nvisible\nVisibility of all annotations - getter\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nclear\nRemove all annotations\n\n\nget\nGet an annotation by name\n\n\nregister_class\nRegister an annotation class\n\n\nremove\nRemove an annotation by name or instance\n\n\nunregister_type\nUnregister a registered annotation type\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotationManager.clear()\nRemove all annotations\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotationManager.get(name)\nGet an annotation by name\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotationManager.register_class(\n    annotation_class,\n)\nRegister an annotation class\nThis method adds the annotation class to the entity specific class registry (classes) and adds a new method (add) to the manager with a signature that matches the annotation inputs.\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotationManager.remove(annotation)\nRemove an annotation by name or instance\nWhen a name is used, all annotations that match the name will be removed\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotationManager.unregister_type(\n    annotation_type,\n)\nUnregister a registered annotation type\nThis method removes the annotation type from the entity speicific class registry and removes the ‘add_&lt;&gt;’ method from the manager\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo(trajectory)\nUniverse Info Trajectory Annotation\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlocation\ntuple[float, float]\nNormalized coordinates (0.0 - 1.0) of the postion in viewport / render\n\n\nshow_frame\nbool\nWhether or not to show the frame number\n\n\nshow_time\nbool\nWhether or not to show the timestep time\n\n\nshow_step\nbool\nWhether or not to show the timestep step\n\n\nshow_topology\nbool\nWhether or not to show the topology filename\n\n\nshow_trajectory\nbool\nWhether or not to show the trajectory filename\n\n\nshow_atoms\nbool\nWhether or not to show the number of atoms\n\n\ncustom_text\nstr\nAny custom text to add at the end of the annotation\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image",
    "crumbs": [
      "Reference",
      "Annotations",
      "entities.trajectory.annotations"
    ]
  },
  {
    "objectID": "api/reference/entities.trajectory.annotations.html#classes",
    "href": "api/reference/entities.trajectory.annotations.html#classes",
    "title": "entities.trajectory.annotations",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAtomInfo\nAtom Info Trajectory Annotation\n\n\nCOM\nCenter-of-Mass Trajectory Annotation\n\n\nCOMDistance\nDistance between Center-of-Masses Trajectory Annotation\n\n\nCanonicalDihedrals\nCanonical Dihedrals of a given residue\n\n\nTrajectoryAnnotation\nBase class for a Trajectory Annotation\n\n\nTrajectoryAnnotationManager\nAnnotation Manager for Trajectory Entity\n\n\nUniverseInfo\nUniverse Info Trajectory Annotation\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo(trajectory)\nAtom Info Trajectory Annotation\nThis annotation shows the atom info of a selection. This annotation can be added using the ‘add_atom_info’ method of the trajectory’s annotation manager: trajectory.annotations.add_atom_info(…)\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nselection\nstr\nMDAnalysis selection phrase to select the atom group\n\n\nshow_resid\nbool\nWhether or not to show the res ID along with the atom name\n\n\nshow_segid\nbool\nWhether or not to show the seg ID along with the atom name\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.AtomInfo.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM(trajectory)\nCenter-of-Mass Trajectory Annotation\nThis annotation shows the center-of-mass of a selection. This annotation can be added using the ‘add_com’ method of the trajectory’s annotation manager: trajectory.annotations.add_com(…)\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nselection\nstr\nMDAnalysis selection phrase to select the atom group\n\n\ntext\nstr\nText do display at the center-of-mass\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.trajectory.annotations.COM.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_bpy_image(pos_2d, image, scale=1.0)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_text_2d(pos_2d, text, overrides=None)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_text_3d(pos_3d, text, overrides=None)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COM.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance(trajectory)\nDistance between Center-of-Masses Trajectory Annotation\nThis annotation shows the distance between center-of-masses of two selections. This annotation can be added using the ‘add_com_distance’ method of the trajectory’s annotation manager: trajectory.annotations.add_com_distance(…)\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nselection1\nstr\nMDAnalysis selection phrase to select the first atom group\n\n\nselection2\nstr\nMDAnalysis selection phrase to select the second atom group\n\n\ntext1\nstr\nText do display at the first center-of-mass\n\n\ntext2\nstr\nText do display at the second center-of-mass\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.COMDistance.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals(trajectory)\nCanonical Dihedrals of a given residue\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nresid\nint\nThe residue number\n\n\nshow_atom_names\nbool\nWhether or not to show the individual atom names in the residue\n\n\nshow_direction\nbool\nWhether or not to show the arc indicating the angle direction\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.bpy_image_to_pil_image(\n    bpy_image,\n)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_bmesh(\n    bm,\n    overrides=None,\n)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.CanonicalDihedrals.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation(trajectory)\nBase class for a Trajectory Annotation\nAll trajectory annotations should derive from this base class and implement the ‘draw’ method. All derived classes will have access to the trajectory instance (self.trajectory) and all the annotation inputs and common params via self.interface.\nAn optional ‘defaults’ method can be provided to set default values to the annotation.\n\n\n\n\n\nName\nDescription\n\n\n\n\nviewport_height\nGet the viewport region height in pixels\n\n\nviewport_width\nGet the viewport region width in pixels\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndefaults\nOptional method to set default annotation params\n\n\ndistance\nDistance between two vectors\n\n\ndraw\nThe main draw method for an annotation\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\nvalidate\nOptional method to validate annotation inputs\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.bpy_image_to_pil_image(\n    bpy_image,\n)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.defaults()\nOptional method to set default annotation params This is called only once when the annotation instance is created\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw()\nThe main draw method for an annotation This is called multiple times in the 3D viewport draw handler\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_bmesh(\n    bm,\n    overrides=None,\n)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotation.validate(input_name=None)\nOptional method to validate annotation inputs This is called during annotation creation and any time the inputs change either through the API or GUI. Can return False or raise an exception when validation fails. Returns True when all validations succeed.\nNote: This method gets called when any inputs change, so updating values in here will lead to a recursive loop and should not be done.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_name\nstr\nThe input name update that trigged this validation callback. When no specific input name is available, None is passed.\nNone\n\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotationManager(entity)\nAnnotation Manager for Trajectory Entity\n\n\n\n\n\nName\nDescription\n\n\n\n\nvisible\nVisibility of all annotations - getter\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nclear\nRemove all annotations\n\n\nget\nGet an annotation by name\n\n\nregister_class\nRegister an annotation class\n\n\nremove\nRemove an annotation by name or instance\n\n\nunregister_type\nUnregister a registered annotation type\n\n\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotationManager.clear()\nRemove all annotations\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotationManager.get(name)\nGet an annotation by name\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotationManager.register_class(\n    annotation_class,\n)\nRegister an annotation class\nThis method adds the annotation class to the entity specific class registry (classes) and adds a new method (add) to the manager with a signature that matches the annotation inputs.\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotationManager.remove(annotation)\nRemove an annotation by name or instance\nWhen a name is used, all annotations that match the name will be removed\n\n\n\nentities.trajectory.annotations.TrajectoryAnnotationManager.unregister_type(\n    annotation_type,\n)\nUnregister a registered annotation type\nThis method removes the annotation type from the entity speicific class registry and removes the ‘add_&lt;&gt;’ method from the manager\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo(trajectory)\nUniverse Info Trajectory Annotation\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlocation\ntuple[float, float]\nNormalized coordinates (0.0 - 1.0) of the postion in viewport / render\n\n\nshow_frame\nbool\nWhether or not to show the frame number\n\n\nshow_time\nbool\nWhether or not to show the timestep time\n\n\nshow_step\nbool\nWhether or not to show the timestep step\n\n\nshow_topology\nbool\nWhether or not to show the topology filename\n\n\nshow_trajectory\nbool\nWhether or not to show the trajectory filename\n\n\nshow_atoms\nbool\nWhether or not to show the number of atoms\n\n\ncustom_text\nstr\nAny custom text to add at the end of the annotation\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.trajectory.annotations.UniverseInfo.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image",
    "crumbs": [
      "Reference",
      "Annotations",
      "entities.trajectory.annotations"
    ]
  },
  {
    "objectID": "api/reference/index.html",
    "href": "api/reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Importing and manipulating different molecular entities\n\n\n\nMolecule\nPrimary Molecular Nodes class that coordinates the conversion of structural bioinformatic data\n\n\nMoleculeSelector\nA helper to create selections for Molecules and AtomArrays.\n\n\nTrajectory\nMD trajectory entity for Blender visualization.\n\n\nentities.Ensemble\n\n\n\nentities.OXDNA\nA class to handle oxDNA trajectory data.\n\n\n\n\n\n\nWorking with molecular dynamics trajectories\n\n\n\nTrajectory\nMD trajectory entity for Blender visualization.\n\n\nentities.trajectory.SelectionManager\nManages atom selections for a trajectory.\n\n\nentities.trajectory.DSSPManager\nDSSP Manager for trajectories\n\n\nentities.StreamingTrajectory\nTrajectory subclass for IMD streaming connections.\n\n\n\n\n\n\nSetting and controlling the different styles\n\n\n\nStyleSpheres\nStyle class for Style Spheres\n\n\nStyleRibbon\nStyle class for Style Ribbon\n\n\nStyleCartoon\nStyle class for Style Cartoon\n\n\nStyleSurface\nStyle class for Style Surface\n\n\nStyleSticks\nStyle class for Style Sticks\n\n\nStyleBallAndStick\nStyle class for Style Ball and Stick\n\n\n\n\n\n\nSetting and controlling the different materials\n\n\n\nmaterial.AmbientOcclusion\n\n\n\nmaterial.Default\n\n\n\nmaterial.Squishy\n\n\n\nmaterial.FlatOutline\n\n\n\nmaterial.TransparentOutline\n\n\n\n\n\n\n\nSession object to control molecular entities\n\n\n\nsession.MNSession\n\n\n\n\n\n\n\nAnnotations for molecular entitites\n\n\n\nannotations.base\n\n\n\nannotations.interface\n\n\n\nannotations.manager\n\n\n\nentities.trajectory.annotations\n\n\n\nentities.molecule.annotations\n\n\n\nentities.density.annotations\n\n\n\n\n\n\n\nControl settings for the Blender scene through the Canvas object.\n\n\n\nCanvas\nHigh-level render controller for Blender scenes.\n\n\nscene.camera",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "api/reference/index.html#entity",
    "href": "api/reference/index.html#entity",
    "title": "Function reference",
    "section": "",
    "text": "Importing and manipulating different molecular entities\n\n\n\nMolecule\nPrimary Molecular Nodes class that coordinates the conversion of structural bioinformatic data\n\n\nMoleculeSelector\nA helper to create selections for Molecules and AtomArrays.\n\n\nTrajectory\nMD trajectory entity for Blender visualization.\n\n\nentities.Ensemble\n\n\n\nentities.OXDNA\nA class to handle oxDNA trajectory data.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "api/reference/index.html#trajectory",
    "href": "api/reference/index.html#trajectory",
    "title": "Function reference",
    "section": "",
    "text": "Working with molecular dynamics trajectories\n\n\n\nTrajectory\nMD trajectory entity for Blender visualization.\n\n\nentities.trajectory.SelectionManager\nManages atom selections for a trajectory.\n\n\nentities.trajectory.DSSPManager\nDSSP Manager for trajectories\n\n\nentities.StreamingTrajectory\nTrajectory subclass for IMD streaming connections.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "api/reference/index.html#styles",
    "href": "api/reference/index.html#styles",
    "title": "Function reference",
    "section": "",
    "text": "Setting and controlling the different styles\n\n\n\nStyleSpheres\nStyle class for Style Spheres\n\n\nStyleRibbon\nStyle class for Style Ribbon\n\n\nStyleCartoon\nStyle class for Style Cartoon\n\n\nStyleSurface\nStyle class for Style Surface\n\n\nStyleSticks\nStyle class for Style Sticks\n\n\nStyleBallAndStick\nStyle class for Style Ball and Stick",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "api/reference/index.html#materials",
    "href": "api/reference/index.html#materials",
    "title": "Function reference",
    "section": "",
    "text": "Setting and controlling the different materials\n\n\n\nmaterial.AmbientOcclusion\n\n\n\nmaterial.Default\n\n\n\nmaterial.Squishy\n\n\n\nmaterial.FlatOutline\n\n\n\nmaterial.TransparentOutline",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "api/reference/index.html#session",
    "href": "api/reference/index.html#session",
    "title": "Function reference",
    "section": "",
    "text": "Session object to control molecular entities\n\n\n\nsession.MNSession",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "api/reference/index.html#annotations",
    "href": "api/reference/index.html#annotations",
    "title": "Function reference",
    "section": "",
    "text": "Annotations for molecular entitites\n\n\n\nannotations.base\n\n\n\nannotations.interface\n\n\n\nannotations.manager\n\n\n\nentities.trajectory.annotations\n\n\n\nentities.molecule.annotations\n\n\n\nentities.density.annotations",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "api/reference/index.html#scene",
    "href": "api/reference/index.html#scene",
    "title": "Function reference",
    "section": "",
    "text": "Control settings for the Blender scene through the Canvas object.\n\n\n\nCanvas\nHigh-level render controller for Blender scenes.\n\n\nscene.camera",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "api/reference/Canvas.html",
    "href": "api/reference/Canvas.html",
    "title": "Canvas",
    "section": "",
    "text": "Canvas(\n    engine='EEVEE',\n    resolution=(1280, 720),\n    transparent=False,\n    template='Molecular Nodes',\n)\nHigh-level render controller for Blender scenes.\nCanvas configures the active Blender scene for Molecular Nodes renders (engine, resolution, transparency, color management), exposes convenient properties for common render settings, and provides helpers to frame objects/views and render stills or animations.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nengine\nEEVEE | Cycles | str\nRender engine to use. Accepts an instance of mn.scene.EEVEE or mn.scene.Cycles, or a case-insensitive string: \"EEVEE\" or \"CYCLES\".\n\"EEVEE\"\n\n\nresolution\ntuple[int, int]\nOutput resolution in pixels as (width, height).\n(1280, 720)\n\n\ntransparent\nbool\nWhen True, renders use a transparent film (alpha background).\nFalse\n\n\ntemplate\npathlib.Path | str | None\nScene template to initialize. If a string is provided it can be either the name of an installed Blender app template (e.g. \"Molecular Nodes\"), or a path to a .blend file. If None, the Blender default startup file is used.\n\"Molecular Nodes\"\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscene\nbpy.types.Scene\nThe active Blender scene.\n\n\ncamera\nmolecularnodes.scene.camera.Camera\nConvenience camera controller bound to the active scene camera.\n\n\nengine\nEEVEE | Cycles\nThe configured render engine object.\n\n\nresolution\ntuple[int, int]\nCurrent render resolution in pixels.\n\n\ntransparent\nbool\nWhether the film background is transparent.\n\n\nfps\nfloat\nFrames per second for animation output.\n\n\nframe_start\nint\nStart frame of the scene range.\n\n\nframe_end\nint\nEnd frame of the scene range.\n\n\nbackground\ntuple[float, float, float, float]\nWorld background color as RGBA in the range [0, 1].\n\n\nview_transform\n{Standard, 'Khronos PBR Neutral', AgX, Filmic, 'Filmic Log', 'False Color', Raw}\nActive view transform for color management.\n\n\n\n\n\n\nCreate a canvas and render a snapshot with a transparent background::\nimport molecularnodes as mn\ncv = mn.Canvas(engine=\"CYCLES\", resolution=(800, 800), transparent=True)\ncv.snapshot(\"frame.png\")\n\n\n\nmolecularnodes.scene.engines.EEVEE : Render engine configuration for EEVEE. molecularnodes.scene.engines.Cycles : Render engine configuration for Cycles. molecularnodes.scene.camera.Camera : Camera controller used by Canvas.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nanimation\nRender an animation of the current scene.\n\n\nclear\nClear all Molecular Nodes entities from the scene.\n\n\nframe_object\nFrame an object or MolecularEntity in the active camera view.\n\n\nframe_view\nFrame one or more views of Molecular entities.\n\n\nload\nLoad a .blend file replacing the current scene.\n\n\nscene_reset\nReset the scene from a template or startup file.\n\n\nsnapshot\nRender an image of the current scene.\n\n\n\n\n\nCanvas.animation(path=None, frame_start=None, frame_end=None, render_scale=100)\nRender an animation of the current scene.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nstr | Path | None\nFile path to write the rendered animation to.\nNone\n\n\nframe_start\nint\nStart frame of the animation. When not specified, current scene’s start frame is used\nNone\n\n\nframe_end\nint\nEnd frame of the animation. When not specified, current scene’s end frame is used\nNone\n\n\nrender_scale\nint\nScale of the rendered animation frames with respect to the resolution.\n100\n\n\n\n\n\n\n\nCanvas.clear()\nClear all Molecular Nodes entities from the scene.\n\n\nThis does not modify lighting, world, or render settings.\n\n\n\n\nCanvas.frame_object(obj, viewpoint=None)\nFrame an object or MolecularEntity in the active camera view.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nobj\nbpy.types.Object | MolecularEntity\nBlender object or Molecular Nodes entity to frame.\nrequired\n\n\nviewpoint\nViewpoints | str\nViewing direction along a principal axis. One of {“default”, “front”, “back”, “top”, “bottom”, “left”, “right”}.\nNone\n\n\n\n\n\n\n\nCanvas.frame_view(view, viewpoint=None)\nFrame one or more views of Molecular entities. Multiple views can be combined using + before passing the result.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nview\nlist[tuple] | MolecularEntity\nA bounding box represented by 8 three-dimensional vertices [(x, y, z), ...] or an entity from which a view is derived.\nrequired\n\n\nviewpoint\nViewpoints | str\nViewing direction along a principal axis. One of {“default”, “front”, “back”, “top”, “bottom”, “left”, “right”}.\nNone\n\n\n\n\n\n\n\nCanvas.load(path)\nLoad a .blend file replacing the current scene.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nstr | Path\nThe file path to the .blend file to load.\nrequired\n\n\n\n\n\n\n\nCanvas.scene_reset(template='Molecular Nodes', engine='EEVEE')\nReset the scene from a template or startup file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntemplate\npathlib.Path | str | None\nName of an installed Blender app template, a path to a .blend file, or None to use Blender’s default startup file.\n\"Molecular Nodes\"\n\n\nengine\nEEVEE | Cycles | str\nRender engine to configure after loading the template.\n\"EEVEE\"\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf template is not None, not a valid .blend file path, and not a known app template name.\n\n\n\n\n\n\n\nCanvas.snapshot(path=None, frame=None, file_format='PNG')\nRender an image of the current scene.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nstr | Path | None\nFile path to write the rendered image to.\nNone\n\n\nframe\nint\nFrame number of scene to render. When not specified, current scene’s current_frame is used\nNone\n\n\nfile_format\nstr\nFile format of the rendered image.\n'PNG'",
    "crumbs": [
      "Reference",
      "Scene",
      "Canvas"
    ]
  },
  {
    "objectID": "api/reference/Canvas.html#parameters",
    "href": "api/reference/Canvas.html#parameters",
    "title": "Canvas",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nengine\nEEVEE | Cycles | str\nRender engine to use. Accepts an instance of mn.scene.EEVEE or mn.scene.Cycles, or a case-insensitive string: \"EEVEE\" or \"CYCLES\".\n\"EEVEE\"\n\n\nresolution\ntuple[int, int]\nOutput resolution in pixels as (width, height).\n(1280, 720)\n\n\ntransparent\nbool\nWhen True, renders use a transparent film (alpha background).\nFalse\n\n\ntemplate\npathlib.Path | str | None\nScene template to initialize. If a string is provided it can be either the name of an installed Blender app template (e.g. \"Molecular Nodes\"), or a path to a .blend file. If None, the Blender default startup file is used.\n\"Molecular Nodes\"",
    "crumbs": [
      "Reference",
      "Scene",
      "Canvas"
    ]
  },
  {
    "objectID": "api/reference/Canvas.html#attributes",
    "href": "api/reference/Canvas.html#attributes",
    "title": "Canvas",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nscene\nbpy.types.Scene\nThe active Blender scene.\n\n\ncamera\nmolecularnodes.scene.camera.Camera\nConvenience camera controller bound to the active scene camera.\n\n\nengine\nEEVEE | Cycles\nThe configured render engine object.\n\n\nresolution\ntuple[int, int]\nCurrent render resolution in pixels.\n\n\ntransparent\nbool\nWhether the film background is transparent.\n\n\nfps\nfloat\nFrames per second for animation output.\n\n\nframe_start\nint\nStart frame of the scene range.\n\n\nframe_end\nint\nEnd frame of the scene range.\n\n\nbackground\ntuple[float, float, float, float]\nWorld background color as RGBA in the range [0, 1].\n\n\nview_transform\n{Standard, 'Khronos PBR Neutral', AgX, Filmic, 'Filmic Log', 'False Color', Raw}\nActive view transform for color management.",
    "crumbs": [
      "Reference",
      "Scene",
      "Canvas"
    ]
  },
  {
    "objectID": "api/reference/Canvas.html#examples",
    "href": "api/reference/Canvas.html#examples",
    "title": "Canvas",
    "section": "",
    "text": "Create a canvas and render a snapshot with a transparent background::\nimport molecularnodes as mn\ncv = mn.Canvas(engine=\"CYCLES\", resolution=(800, 800), transparent=True)\ncv.snapshot(\"frame.png\")",
    "crumbs": [
      "Reference",
      "Scene",
      "Canvas"
    ]
  },
  {
    "objectID": "api/reference/Canvas.html#see-also",
    "href": "api/reference/Canvas.html#see-also",
    "title": "Canvas",
    "section": "",
    "text": "molecularnodes.scene.engines.EEVEE : Render engine configuration for EEVEE. molecularnodes.scene.engines.Cycles : Render engine configuration for Cycles. molecularnodes.scene.camera.Camera : Camera controller used by Canvas.",
    "crumbs": [
      "Reference",
      "Scene",
      "Canvas"
    ]
  },
  {
    "objectID": "api/reference/Canvas.html#methods",
    "href": "api/reference/Canvas.html#methods",
    "title": "Canvas",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nanimation\nRender an animation of the current scene.\n\n\nclear\nClear all Molecular Nodes entities from the scene.\n\n\nframe_object\nFrame an object or MolecularEntity in the active camera view.\n\n\nframe_view\nFrame one or more views of Molecular entities.\n\n\nload\nLoad a .blend file replacing the current scene.\n\n\nscene_reset\nReset the scene from a template or startup file.\n\n\nsnapshot\nRender an image of the current scene.\n\n\n\n\n\nCanvas.animation(path=None, frame_start=None, frame_end=None, render_scale=100)\nRender an animation of the current scene.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nstr | Path | None\nFile path to write the rendered animation to.\nNone\n\n\nframe_start\nint\nStart frame of the animation. When not specified, current scene’s start frame is used\nNone\n\n\nframe_end\nint\nEnd frame of the animation. When not specified, current scene’s end frame is used\nNone\n\n\nrender_scale\nint\nScale of the rendered animation frames with respect to the resolution.\n100\n\n\n\n\n\n\n\nCanvas.clear()\nClear all Molecular Nodes entities from the scene.\n\n\nThis does not modify lighting, world, or render settings.\n\n\n\n\nCanvas.frame_object(obj, viewpoint=None)\nFrame an object or MolecularEntity in the active camera view.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nobj\nbpy.types.Object | MolecularEntity\nBlender object or Molecular Nodes entity to frame.\nrequired\n\n\nviewpoint\nViewpoints | str\nViewing direction along a principal axis. One of {“default”, “front”, “back”, “top”, “bottom”, “left”, “right”}.\nNone\n\n\n\n\n\n\n\nCanvas.frame_view(view, viewpoint=None)\nFrame one or more views of Molecular entities. Multiple views can be combined using + before passing the result.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nview\nlist[tuple] | MolecularEntity\nA bounding box represented by 8 three-dimensional vertices [(x, y, z), ...] or an entity from which a view is derived.\nrequired\n\n\nviewpoint\nViewpoints | str\nViewing direction along a principal axis. One of {“default”, “front”, “back”, “top”, “bottom”, “left”, “right”}.\nNone\n\n\n\n\n\n\n\nCanvas.load(path)\nLoad a .blend file replacing the current scene.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nstr | Path\nThe file path to the .blend file to load.\nrequired\n\n\n\n\n\n\n\nCanvas.scene_reset(template='Molecular Nodes', engine='EEVEE')\nReset the scene from a template or startup file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntemplate\npathlib.Path | str | None\nName of an installed Blender app template, a path to a .blend file, or None to use Blender’s default startup file.\n\"Molecular Nodes\"\n\n\nengine\nEEVEE | Cycles | str\nRender engine to configure after loading the template.\n\"EEVEE\"\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf template is not None, not a valid .blend file path, and not a known app template name.\n\n\n\n\n\n\n\nCanvas.snapshot(path=None, frame=None, file_format='PNG')\nRender an image of the current scene.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nstr | Path | None\nFile path to write the rendered image to.\nNone\n\n\nframe\nint\nFrame number of scene to render. When not specified, current scene’s current_frame is used\nNone\n\n\nfile_format\nstr\nFile format of the rendered image.\n'PNG'",
    "crumbs": [
      "Reference",
      "Scene",
      "Canvas"
    ]
  },
  {
    "objectID": "api/reference/scene.camera.html",
    "href": "api/reference/scene.camera.html",
    "title": "scene.camera",
    "section": "",
    "text": "scene.camera\n\n\n\n\n\nName\nDescription\n\n\n\n\nCamera\nA class to handle camera settings in Blender.\n\n\n\n\n\nscene.camera.Camera()\nA class to handle camera settings in Blender.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncamera\nGet Camera object\n\n\ncamera_data\nGet Camera data\n\n\nclip_end\nGet Camera far clipping distance\n\n\nclip_start\nGet Camera near clipping distance\n\n\nlens\nGet Camera focal length\n\n\nrotation\nGet Camera rotation in degrees (XYZ)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_viewpoint\nSet viewpoint to a preset or a custom Euler rotation.\n\n\n\n\n\nscene.camera.Camera.set_viewpoint(viewpoint)\nSet viewpoint to a preset or a custom Euler rotation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nviewpoint\nViewpoints | Sequence[float]\nEither a named viewpoint string (e.g. “front”, “top”) or a tuple/list of three Euler angles in radians.\nrequired",
    "crumbs": [
      "Reference",
      "Scene",
      "scene.camera"
    ]
  },
  {
    "objectID": "api/reference/scene.camera.html#classes",
    "href": "api/reference/scene.camera.html#classes",
    "title": "scene.camera",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nCamera\nA class to handle camera settings in Blender.\n\n\n\n\n\nscene.camera.Camera()\nA class to handle camera settings in Blender.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncamera\nGet Camera object\n\n\ncamera_data\nGet Camera data\n\n\nclip_end\nGet Camera far clipping distance\n\n\nclip_start\nGet Camera near clipping distance\n\n\nlens\nGet Camera focal length\n\n\nrotation\nGet Camera rotation in degrees (XYZ)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_viewpoint\nSet viewpoint to a preset or a custom Euler rotation.\n\n\n\n\n\nscene.camera.Camera.set_viewpoint(viewpoint)\nSet viewpoint to a preset or a custom Euler rotation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nviewpoint\nViewpoints | Sequence[float]\nEither a named viewpoint string (e.g. “front”, “top”) or a tuple/list of three Euler angles in radians.\nrequired",
    "crumbs": [
      "Reference",
      "Scene",
      "scene.camera"
    ]
  },
  {
    "objectID": "api/reference/material.AmbientOcclusion.html",
    "href": "api/reference/material.AmbientOcclusion.html",
    "title": "material.AmbientOcclusion",
    "section": "",
    "text": "material.AmbientOcclusion\nmaterial.AmbientOcclusion(**kwargs)",
    "crumbs": [
      "Reference",
      "Materials",
      "material.AmbientOcclusion"
    ]
  },
  {
    "objectID": "api/reference/annotations.interface.html",
    "href": "api/reference/annotations.interface.html",
    "title": "annotations.interface",
    "section": "",
    "text": "annotations.interface\n\n\n\n\n\nName\nDescription\n\n\n\n\nAnnotationInterface\nBase class for Annotation Interface\n\n\n\n\n\nannotations.interface.AnnotationInterface(instance)\nBase class for Annotation Interface\nAnnotationManager creates a dynamic AnnotationInterface for every instance of an annotation. All the annotation specific inputs and the common annotation params are exposed though this interface for the API, GUI and the annotation drawing code.",
    "crumbs": [
      "Reference",
      "Annotations",
      "annotations.interface"
    ]
  },
  {
    "objectID": "api/reference/annotations.interface.html#classes",
    "href": "api/reference/annotations.interface.html#classes",
    "title": "annotations.interface",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAnnotationInterface\nBase class for Annotation Interface\n\n\n\n\n\nannotations.interface.AnnotationInterface(instance)\nBase class for Annotation Interface\nAnnotationManager creates a dynamic AnnotationInterface for every instance of an annotation. All the annotation specific inputs and the common annotation params are exposed though this interface for the API, GUI and the annotation drawing code.",
    "crumbs": [
      "Reference",
      "Annotations",
      "annotations.interface"
    ]
  },
  {
    "objectID": "api/reference/annotations.manager.html",
    "href": "api/reference/annotations.manager.html",
    "title": "annotations.manager",
    "section": "",
    "text": "annotations.manager\n\n\n\n\n\nName\nDescription\n\n\n\n\nBaseAnnotationManager\nBase class for Annotation Manager\n\n\n\n\n\nannotations.manager.BaseAnnotationManager(entity)\nBase class for Annotation Manager\nThis is the base class for the Annotation Manager, which manages all the annotation classes, instances and interfaces\nEntities that need annotation support have to derive from this base class and set the class attribute _entity_type to the entity tpye, the class attribute ’_classes’ and instance attribute ’_interfaces’ to empty dictionaries. Derived classes will have to pass the entity instance as part of its ‘init’ as well.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nvisible\nbool\nWhether to show or hide all annotations\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nclear\nRemove all annotations\n\n\nget\nGet an annotation by name\n\n\nregister_class\nRegister an annotation class\n\n\nremove\nRemove an annotation by name or instance\n\n\nunregister_type\nUnregister a registered annotation type\n\n\n\n\n\nannotations.manager.BaseAnnotationManager.clear()\nRemove all annotations\n\n\n\nannotations.manager.BaseAnnotationManager.get(name)\nGet an annotation by name\n\n\n\nannotations.manager.BaseAnnotationManager.register_class(annotation_class)\nRegister an annotation class\nThis method adds the annotation class to the entity specific class registry (classes) and adds a new method (add) to the manager with a signature that matches the annotation inputs.\n\n\n\nannotations.manager.BaseAnnotationManager.remove(annotation)\nRemove an annotation by name or instance\nWhen a name is used, all annotations that match the name will be removed\n\n\n\nannotations.manager.BaseAnnotationManager.unregister_type(annotation_type)\nUnregister a registered annotation type\nThis method removes the annotation type from the entity speicific class registry and removes the ‘add_&lt;&gt;’ method from the manager",
    "crumbs": [
      "Reference",
      "Annotations",
      "annotations.manager"
    ]
  },
  {
    "objectID": "api/reference/annotations.manager.html#classes",
    "href": "api/reference/annotations.manager.html#classes",
    "title": "annotations.manager",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBaseAnnotationManager\nBase class for Annotation Manager\n\n\n\n\n\nannotations.manager.BaseAnnotationManager(entity)\nBase class for Annotation Manager\nThis is the base class for the Annotation Manager, which manages all the annotation classes, instances and interfaces\nEntities that need annotation support have to derive from this base class and set the class attribute _entity_type to the entity tpye, the class attribute ’_classes’ and instance attribute ’_interfaces’ to empty dictionaries. Derived classes will have to pass the entity instance as part of its ‘init’ as well.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nvisible\nbool\nWhether to show or hide all annotations\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nclear\nRemove all annotations\n\n\nget\nGet an annotation by name\n\n\nregister_class\nRegister an annotation class\n\n\nremove\nRemove an annotation by name or instance\n\n\nunregister_type\nUnregister a registered annotation type\n\n\n\n\n\nannotations.manager.BaseAnnotationManager.clear()\nRemove all annotations\n\n\n\nannotations.manager.BaseAnnotationManager.get(name)\nGet an annotation by name\n\n\n\nannotations.manager.BaseAnnotationManager.register_class(annotation_class)\nRegister an annotation class\nThis method adds the annotation class to the entity specific class registry (classes) and adds a new method (add) to the manager with a signature that matches the annotation inputs.\n\n\n\nannotations.manager.BaseAnnotationManager.remove(annotation)\nRemove an annotation by name or instance\nWhen a name is used, all annotations that match the name will be removed\n\n\n\nannotations.manager.BaseAnnotationManager.unregister_type(annotation_type)\nUnregister a registered annotation type\nThis method removes the annotation type from the entity speicific class registry and removes the ‘add_&lt;&gt;’ method from the manager",
    "crumbs": [
      "Reference",
      "Annotations",
      "annotations.manager"
    ]
  },
  {
    "objectID": "api/reference/MoleculeSelector.html",
    "href": "api/reference/MoleculeSelector.html",
    "title": "MoleculeSelector",
    "section": "",
    "text": "MoleculeSelector(mol=None)\nA helper to create selections for Molecules and AtomArrays.\nThe selection (self.mask) is not computed or returned until the evaluate_on_array method is called. Until then methods are stored for later evaluation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmol\nMolecule\nThe molecule object to select from.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmol\nMolecule\nThe molecule object to select from.\n\n\nmask\nndarray or None\nBoolean array for the selection on the most recently evaluated array.\n\n\npending_selections\nlist\nList of selection operations to be applied once evaluate_on_array is called.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\natom_name\nSelect atoms by their name.\n\n\nchain_id\nSelect atoms by chain identifier.\n\n\nelement\nSelect atoms by element symbol.\n\n\nevaluate_on_array\nEvaluate this selection on the AtomArray.\n\n\nis_amino_acid\nSelect amino acid residues.\n\n\nis_backbone\nSelect backbone atoms for peptide and nucleotide.\n\n\nis_canonical_amino_acid\nSelect canonical amino acid residues.\n\n\nis_canonical_nucleotide\nSelect canonical nucleotide residues.\n\n\nis_carbohydrate\nSelect carbohydrate residues.\n\n\nis_hetero\nSelect hetero atoms.\n\n\nis_ligand\nSelect ligand atoms.\n\n\nis_monoatomic_ion\nSelect monoatomic ions.\n\n\nis_nucleotide\nSelect nucleotide residues.\n\n\nis_peptide_backbone\nSelect peptide backbone atoms.\n\n\nis_phosphate_backbone\nSelect phosphate backbone atoms.\n\n\nis_polymer\nSelect polymer atoms.\n\n\nis_solvent\nSelect solvent atoms.\n\n\nlinear_bond_continuity\nSelect atoms with linear bond continuity.\n\n\nnot_amino_acids\nSelect non-amino acid residues.\n\n\nnot_atom_names\nSelect atoms not matching the specified atom names.\n\n\nnot_canonical_amino_acids\nSelect non-canonical amino acid residues.\n\n\nnot_canonical_nucleotides\nSelect non-canonical nucleotide residues.\n\n\nnot_carbohydrates\nSelect non-carbohydrate residues.\n\n\nnot_chain_id\nSelect atoms not in the specified chains.\n\n\nnot_element\nSelect atoms not matching the specified elements.\n\n\nnot_hetero\nSelect non-hetero atoms.\n\n\nnot_monoatomic_ions\nSelect non-monoatomic ion atoms.\n\n\nnot_nucleotides\nSelect non-nucleotide residues.\n\n\nnot_peptide_backbone\nSelect non-peptide backbone atoms.\n\n\nnot_phosphate_backbone\nSelect non-phosphate backbone atoms.\n\n\nnot_polymer\nSelect non-polymer atoms.\n\n\nnot_res_id\nSelect atoms not matching the specified residue IDs.\n\n\nnot_res_name\nSelect atoms not matching the specified residue names.\n\n\nnot_solvent\nSelect non-solvent atoms.\n\n\nres_id\nSelect atoms by residue ID.\n\n\nres_name\nSelect atoms by residue name.\n\n\nreset\nReset all pending selections and the mask\n\n\nstore_selection\nEvaluate and store the current selection as a named attribute on the Molecule\n\n\n\n\n\nMoleculeSelector.atom_name(atom_name)\nSelect atoms by their name.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_name\nstr or list of str or tuple of str or ndarray\nThe atom name(s) to select.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.chain_id(chain_id)\nSelect atoms by chain identifier.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nchain_id\nlist of str or tuple of str or ndarray\nThe chain identifier(s) to select.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.element(element)\nSelect atoms by element symbol.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nelement\nlist of str or tuple of str or ndarray\nThe element symbol(s) to select.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.evaluate_on_array(array)\nEvaluate this selection on the AtomArray.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\narray\nAtomArray or AtomArrayStack\nThe atomic structure to evaluate the selection on.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nBoolean mask array indicating which atoms match the selection criteria.\n\n\n\n\n\n\nAll of the selection operations that have been staged for this Selector are evaluated and combined with a logical AND, using the AtomArray as input.\n\n\n\n\nMoleculeSelector.is_amino_acid()\nSelect amino acid residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_backbone()\nSelect backbone atoms for peptide and nucleotide.\n\n\n\nMoleculeSelector.is_canonical_amino_acid()\nSelect canonical amino acid residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_canonical_nucleotide()\nSelect canonical nucleotide residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_carbohydrate()\nSelect carbohydrate residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_hetero()\nSelect hetero atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_ligand()\nSelect ligand atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_monoatomic_ion()\nSelect monoatomic ions.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_nucleotide()\nSelect nucleotide residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_peptide_backbone()\nSelect peptide backbone atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_phosphate_backbone()\nSelect phosphate backbone atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_polymer()\nSelect polymer atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_solvent()\nSelect solvent atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.linear_bond_continuity()\nSelect atoms with linear bond continuity.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_amino_acids()\nSelect non-amino acid residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_atom_names(atomname)\nSelect atoms not matching the specified atom names.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomname\nstr or list of str\nThe atom name(s) to exclude.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_canonical_amino_acids()\nSelect non-canonical amino acid residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_canonical_nucleotides()\nSelect non-canonical nucleotide residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_carbohydrates()\nSelect non-carbohydrate residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_chain_id(chain_id)\nSelect atoms not in the specified chains.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nchain_id\nstr or list of str\nThe chain identifier(s) to exclude.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_element(element)\nSelect atoms not matching the specified elements.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nelement\nstr or list of str\nThe element symbol(s) to exclude.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_hetero()\nSelect non-hetero atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_monoatomic_ions()\nSelect non-monoatomic ion atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_nucleotides()\nSelect non-nucleotide residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_peptide_backbone()\nSelect non-peptide backbone atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_phosphate_backbone()\nSelect non-phosphate backbone atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_polymer()\nSelect non-polymer atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_res_id(num)\nSelect atoms not matching the specified residue IDs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum\nint or list of int\nThe residue ID(s) to exclude.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_res_name(res_name)\nSelect atoms not matching the specified residue names.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nres_name\nstr or list of str\nThe residue name(s) to exclude.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_solvent()\nSelect non-solvent atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.res_id(num)\nSelect atoms by residue ID.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum\nint or list of int\nThe residue ID(s) to select.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.res_name(res_name)\nSelect atoms by residue name.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nres_name\nstr or list of str\nThe residue name(s) to select.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.reset()\nReset all pending selections and the mask\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nself\nSelector\nReturns self for method chaining\n\n\n\n\n\n\n\nMoleculeSelector.store_selection(name)\nEvaluate and store the current selection as a named attribute on the Molecule\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe name to store the selection under.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf no selection has been made.",
    "crumbs": [
      "Reference",
      "Entity",
      "MoleculeSelector"
    ]
  },
  {
    "objectID": "api/reference/MoleculeSelector.html#parameters",
    "href": "api/reference/MoleculeSelector.html#parameters",
    "title": "MoleculeSelector",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nmol\nMolecule\nThe molecule object to select from.\nNone",
    "crumbs": [
      "Reference",
      "Entity",
      "MoleculeSelector"
    ]
  },
  {
    "objectID": "api/reference/MoleculeSelector.html#attributes",
    "href": "api/reference/MoleculeSelector.html#attributes",
    "title": "MoleculeSelector",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nmol\nMolecule\nThe molecule object to select from.\n\n\nmask\nndarray or None\nBoolean array for the selection on the most recently evaluated array.\n\n\npending_selections\nlist\nList of selection operations to be applied once evaluate_on_array is called.",
    "crumbs": [
      "Reference",
      "Entity",
      "MoleculeSelector"
    ]
  },
  {
    "objectID": "api/reference/MoleculeSelector.html#methods",
    "href": "api/reference/MoleculeSelector.html#methods",
    "title": "MoleculeSelector",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\natom_name\nSelect atoms by their name.\n\n\nchain_id\nSelect atoms by chain identifier.\n\n\nelement\nSelect atoms by element symbol.\n\n\nevaluate_on_array\nEvaluate this selection on the AtomArray.\n\n\nis_amino_acid\nSelect amino acid residues.\n\n\nis_backbone\nSelect backbone atoms for peptide and nucleotide.\n\n\nis_canonical_amino_acid\nSelect canonical amino acid residues.\n\n\nis_canonical_nucleotide\nSelect canonical nucleotide residues.\n\n\nis_carbohydrate\nSelect carbohydrate residues.\n\n\nis_hetero\nSelect hetero atoms.\n\n\nis_ligand\nSelect ligand atoms.\n\n\nis_monoatomic_ion\nSelect monoatomic ions.\n\n\nis_nucleotide\nSelect nucleotide residues.\n\n\nis_peptide_backbone\nSelect peptide backbone atoms.\n\n\nis_phosphate_backbone\nSelect phosphate backbone atoms.\n\n\nis_polymer\nSelect polymer atoms.\n\n\nis_solvent\nSelect solvent atoms.\n\n\nlinear_bond_continuity\nSelect atoms with linear bond continuity.\n\n\nnot_amino_acids\nSelect non-amino acid residues.\n\n\nnot_atom_names\nSelect atoms not matching the specified atom names.\n\n\nnot_canonical_amino_acids\nSelect non-canonical amino acid residues.\n\n\nnot_canonical_nucleotides\nSelect non-canonical nucleotide residues.\n\n\nnot_carbohydrates\nSelect non-carbohydrate residues.\n\n\nnot_chain_id\nSelect atoms not in the specified chains.\n\n\nnot_element\nSelect atoms not matching the specified elements.\n\n\nnot_hetero\nSelect non-hetero atoms.\n\n\nnot_monoatomic_ions\nSelect non-monoatomic ion atoms.\n\n\nnot_nucleotides\nSelect non-nucleotide residues.\n\n\nnot_peptide_backbone\nSelect non-peptide backbone atoms.\n\n\nnot_phosphate_backbone\nSelect non-phosphate backbone atoms.\n\n\nnot_polymer\nSelect non-polymer atoms.\n\n\nnot_res_id\nSelect atoms not matching the specified residue IDs.\n\n\nnot_res_name\nSelect atoms not matching the specified residue names.\n\n\nnot_solvent\nSelect non-solvent atoms.\n\n\nres_id\nSelect atoms by residue ID.\n\n\nres_name\nSelect atoms by residue name.\n\n\nreset\nReset all pending selections and the mask\n\n\nstore_selection\nEvaluate and store the current selection as a named attribute on the Molecule\n\n\n\n\n\nMoleculeSelector.atom_name(atom_name)\nSelect atoms by their name.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_name\nstr or list of str or tuple of str or ndarray\nThe atom name(s) to select.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.chain_id(chain_id)\nSelect atoms by chain identifier.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nchain_id\nlist of str or tuple of str or ndarray\nThe chain identifier(s) to select.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.element(element)\nSelect atoms by element symbol.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nelement\nlist of str or tuple of str or ndarray\nThe element symbol(s) to select.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.evaluate_on_array(array)\nEvaluate this selection on the AtomArray.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\narray\nAtomArray or AtomArrayStack\nThe atomic structure to evaluate the selection on.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nBoolean mask array indicating which atoms match the selection criteria.\n\n\n\n\n\n\nAll of the selection operations that have been staged for this Selector are evaluated and combined with a logical AND, using the AtomArray as input.\n\n\n\n\nMoleculeSelector.is_amino_acid()\nSelect amino acid residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_backbone()\nSelect backbone atoms for peptide and nucleotide.\n\n\n\nMoleculeSelector.is_canonical_amino_acid()\nSelect canonical amino acid residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_canonical_nucleotide()\nSelect canonical nucleotide residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_carbohydrate()\nSelect carbohydrate residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_hetero()\nSelect hetero atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_ligand()\nSelect ligand atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_monoatomic_ion()\nSelect monoatomic ions.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_nucleotide()\nSelect nucleotide residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_peptide_backbone()\nSelect peptide backbone atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_phosphate_backbone()\nSelect phosphate backbone atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_polymer()\nSelect polymer atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.is_solvent()\nSelect solvent atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.linear_bond_continuity()\nSelect atoms with linear bond continuity.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_amino_acids()\nSelect non-amino acid residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_atom_names(atomname)\nSelect atoms not matching the specified atom names.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomname\nstr or list of str\nThe atom name(s) to exclude.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_canonical_amino_acids()\nSelect non-canonical amino acid residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_canonical_nucleotides()\nSelect non-canonical nucleotide residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_carbohydrates()\nSelect non-carbohydrate residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_chain_id(chain_id)\nSelect atoms not in the specified chains.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nchain_id\nstr or list of str\nThe chain identifier(s) to exclude.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_element(element)\nSelect atoms not matching the specified elements.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nelement\nstr or list of str\nThe element symbol(s) to exclude.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_hetero()\nSelect non-hetero atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_monoatomic_ions()\nSelect non-monoatomic ion atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_nucleotides()\nSelect non-nucleotide residues.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_peptide_backbone()\nSelect non-peptide backbone atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_phosphate_backbone()\nSelect non-phosphate backbone atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_polymer()\nSelect non-polymer atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_res_id(num)\nSelect atoms not matching the specified residue IDs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum\nint or list of int\nThe residue ID(s) to exclude.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_res_name(res_name)\nSelect atoms not matching the specified residue names.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nres_name\nstr or list of str\nThe residue name(s) to exclude.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.not_solvent()\nSelect non-solvent atoms.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.res_id(num)\nSelect atoms by residue ID.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum\nint or list of int\nThe residue ID(s) to select.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.res_name(res_name)\nSelect atoms by residue name.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nres_name\nstr or list of str\nThe residue name(s) to select.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSelector\nReturns self for method chaining.\n\n\n\n\n\n\n\nMoleculeSelector.reset()\nReset all pending selections and the mask\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nself\nSelector\nReturns self for method chaining\n\n\n\n\n\n\n\nMoleculeSelector.store_selection(name)\nEvaluate and store the current selection as a named attribute on the Molecule\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe name to store the selection under.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf no selection has been made.",
    "crumbs": [
      "Reference",
      "Entity",
      "MoleculeSelector"
    ]
  },
  {
    "objectID": "api/reference/material.FlatOutline.html",
    "href": "api/reference/material.FlatOutline.html",
    "title": "material.FlatOutline",
    "section": "",
    "text": "material.FlatOutline\nmaterial.FlatOutline(**kwargs)",
    "crumbs": [
      "Reference",
      "Materials",
      "material.FlatOutline"
    ]
  },
  {
    "objectID": "api/reference/entities.molecule.annotations.html",
    "href": "api/reference/entities.molecule.annotations.html",
    "title": "entities.molecule.annotations",
    "section": "",
    "text": "entities.molecule.annotations\n\n\n\n\n\nName\nDescription\n\n\n\n\nLabel2D\nCommon Label2D Annotation for all entities\n\n\nLabel3D\nCommon Label3D Annotation for all entities\n\n\nMoleculeAnnotation\nBase class for a Molecule Annotation\n\n\nMoleculeAnnotationManager\nAnnotation Manager for Molecule Entity\n\n\nMoleculeInfo\nMolecule Info Annotation\n\n\n\n\n\nentities.molecule.annotations.Label2D()\nCommon Label2D Annotation for all entities\n\n\n\nentities.molecule.annotations.Label3D()\nCommon Label3D Annotation for all entities\n\n\n\nentities.molecule.annotations.MoleculeAnnotation(molecule)\nBase class for a Molecule Annotation\nAll molecule annotations should derive from this base class and implement the ‘draw’ method. All derived classes will have access to the molecule instance (self.molecule) and all the annotation inputs and common params via self.interface.\nAn optional ‘defaults’ method can be provided to set default values to the annotation.\n\n\n\n\n\nName\nDescription\n\n\n\n\nviewport_height\nGet the viewport region height in pixels\n\n\nviewport_width\nGet the viewport region width in pixels\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndefaults\nOptional method to set default annotation params\n\n\ndistance\nDistance between two vectors\n\n\ndraw\nThe main draw method for an annotation\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\nvalidate\nOptional method to validate annotation inputs\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.bpy_image_to_pil_image(\n    bpy_image,\n)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.defaults()\nOptional method to set default annotation params This is called only once when the annotation instance is created\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw()\nThe main draw method for an annotation This is called multiple times in the 3D viewport draw handler\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.validate(input_name=None)\nOptional method to validate annotation inputs This is called during annotation creation and any time the inputs change either through the API or GUI. Can return False or raise an exception when validation fails. Returns True when all validations succeed.\nNote: This method gets called when any inputs change, so updating values in here will lead to a recursive loop and should not be done.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_name\nstr\nThe input name update that trigged this validation callback. When no specific input name is available, None is passed.\nNone\n\n\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotationManager(entity)\nAnnotation Manager for Molecule Entity\n\n\n\n\n\nName\nDescription\n\n\n\n\nvisible\nVisibility of all annotations - getter\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nclear\nRemove all annotations\n\n\nget\nGet an annotation by name\n\n\nregister_class\nRegister an annotation class\n\n\nremove\nRemove an annotation by name or instance\n\n\nunregister_type\nUnregister a registered annotation type\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotationManager.clear()\nRemove all annotations\n\n\n\nentities.molecule.annotations.MoleculeAnnotationManager.get(name)\nGet an annotation by name\n\n\n\nentities.molecule.annotations.MoleculeAnnotationManager.register_class(\n    annotation_class,\n)\nRegister an annotation class\nThis method adds the annotation class to the entity specific class registry (classes) and adds a new method (add) to the manager with a signature that matches the annotation inputs.\n\n\n\nentities.molecule.annotations.MoleculeAnnotationManager.remove(annotation)\nRemove an annotation by name or instance\nWhen a name is used, all annotations that match the name will be removed\n\n\n\nentities.molecule.annotations.MoleculeAnnotationManager.unregister_type(\n    annotation_type,\n)\nUnregister a registered annotation type\nThis method removes the annotation type from the entity speicific class registry and removes the ‘add_&lt;&gt;’ method from the manager\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo(molecule)\nMolecule Info Annotation\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlocation\ntuple[float, float]\nNormalized coordinates (0.0 - 1.0) of the postion in viewport / render\n\n\nshow_models\nbool\nWhether or not to show the number of models in the molecule\n\n\nshow_atoms\nbool\nWhether or not to show the number of atoms in the molecule\n\n\ncustom_text\nstr\nAny custom text to add at the end of the annotation\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image",
    "crumbs": [
      "Reference",
      "Annotations",
      "entities.molecule.annotations"
    ]
  },
  {
    "objectID": "api/reference/entities.molecule.annotations.html#classes",
    "href": "api/reference/entities.molecule.annotations.html#classes",
    "title": "entities.molecule.annotations",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLabel2D\nCommon Label2D Annotation for all entities\n\n\nLabel3D\nCommon Label3D Annotation for all entities\n\n\nMoleculeAnnotation\nBase class for a Molecule Annotation\n\n\nMoleculeAnnotationManager\nAnnotation Manager for Molecule Entity\n\n\nMoleculeInfo\nMolecule Info Annotation\n\n\n\n\n\nentities.molecule.annotations.Label2D()\nCommon Label2D Annotation for all entities\n\n\n\nentities.molecule.annotations.Label3D()\nCommon Label3D Annotation for all entities\n\n\n\nentities.molecule.annotations.MoleculeAnnotation(molecule)\nBase class for a Molecule Annotation\nAll molecule annotations should derive from this base class and implement the ‘draw’ method. All derived classes will have access to the molecule instance (self.molecule) and all the annotation inputs and common params via self.interface.\nAn optional ‘defaults’ method can be provided to set default values to the annotation.\n\n\n\n\n\nName\nDescription\n\n\n\n\nviewport_height\nGet the viewport region height in pixels\n\n\nviewport_width\nGet the viewport region width in pixels\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndefaults\nOptional method to set default annotation params\n\n\ndistance\nDistance between two vectors\n\n\ndraw\nThe main draw method for an annotation\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\nvalidate\nOptional method to validate annotation inputs\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.bpy_image_to_pil_image(\n    bpy_image,\n)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.defaults()\nOptional method to set default annotation params This is called only once when the annotation instance is created\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw()\nThe main draw method for an annotation This is called multiple times in the 3D viewport draw handler\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotation.validate(input_name=None)\nOptional method to validate annotation inputs This is called during annotation creation and any time the inputs change either through the API or GUI. Can return False or raise an exception when validation fails. Returns True when all validations succeed.\nNote: This method gets called when any inputs change, so updating values in here will lead to a recursive loop and should not be done.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_name\nstr\nThe input name update that trigged this validation callback. When no specific input name is available, None is passed.\nNone\n\n\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotationManager(entity)\nAnnotation Manager for Molecule Entity\n\n\n\n\n\nName\nDescription\n\n\n\n\nvisible\nVisibility of all annotations - getter\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nclear\nRemove all annotations\n\n\nget\nGet an annotation by name\n\n\nregister_class\nRegister an annotation class\n\n\nremove\nRemove an annotation by name or instance\n\n\nunregister_type\nUnregister a registered annotation type\n\n\n\n\n\nentities.molecule.annotations.MoleculeAnnotationManager.clear()\nRemove all annotations\n\n\n\nentities.molecule.annotations.MoleculeAnnotationManager.get(name)\nGet an annotation by name\n\n\n\nentities.molecule.annotations.MoleculeAnnotationManager.register_class(\n    annotation_class,\n)\nRegister an annotation class\nThis method adds the annotation class to the entity specific class registry (classes) and adds a new method (add) to the manager with a signature that matches the annotation inputs.\n\n\n\nentities.molecule.annotations.MoleculeAnnotationManager.remove(annotation)\nRemove an annotation by name or instance\nWhen a name is used, all annotations that match the name will be removed\n\n\n\nentities.molecule.annotations.MoleculeAnnotationManager.unregister_type(\n    annotation_type,\n)\nUnregister a registered annotation type\nThis method removes the annotation type from the entity speicific class registry and removes the ‘add_&lt;&gt;’ method from the manager\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo(molecule)\nMolecule Info Annotation\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlocation\ntuple[float, float]\nNormalized coordinates (0.0 - 1.0) of the postion in viewport / render\n\n\nshow_models\nbool\nWhether or not to show the number of models in the molecule\n\n\nshow_atoms\nbool\nWhether or not to show the number of atoms in the molecule\n\n\ncustom_text\nstr\nAny custom text to add at the end of the annotation\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbpy_image_to_pil_image\nConvert Blender image to PIL image\n\n\ndistance\nDistance between two vectors\n\n\ndraw_bmesh\nDraw a Blender bmesh\n\n\ndraw_bpy_image\nDraw an image from bpy.data.images at the given 2D position (normalized\n\n\ndraw_circle_2d\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\ndraw_circle_3d\nDraw a circle around a 3D point in the plane perpendicular to the\n\n\ndraw_cone\nDraw a cone\n\n\ndraw_cylinder\nDraw a cylinder\n\n\ndraw_line_2d\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\ndraw_line_3d\nDraw a line between two points in 3D space\n\n\ndraw_n_sided_cylinder\nDraw an n sided cylinder\n\n\ndraw_n_sided_pyramid\nDraw an n sided pyramid\n\n\ndraw_sphere\nDraw a sphere\n\n\ndraw_text_2d\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\ndraw_text_3d\nDraw text at a given 3D position\n\n\ndraw_triclinic_cell\nDraw a triclinic box based on box vector lengths and angles\n\n\ndraw_wigner_seitz_cell\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\npil_image_to_bpy_image\nConvert PIL image to Blender image\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.bpy_image_to_pil_image(bpy_image)\nConvert Blender image to PIL image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbpy_image\nbpy.types.Image\nBlender image\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImage.Image\nPIL Image\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.distance(v1, v2)\nDistance between two vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\nv2\nVector\nA 3D or 2D vector or tuple\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDistance between the two vectors\n\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_bmesh(bm, overrides=None)\nDraw a Blender bmesh\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbm\nbmesh.types.BMesh\nA bmesh object. A copy is made for internal use. Users will have to free the passed in object\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_bpy_image(\n    pos_2d,\n    image,\n    scale=1.0,\n)\nDraw an image from bpy.data.images at the given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left. Bottom left of the image is placed at this position\nrequired\n\n\nimage\nbpy.types.Image\nAn image from bpy.data.images to draw at specified position\nrequired\n\n\nscale\nfloat\nScale of the image to draw\n1.0\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_circle_2d(\n    center,\n    radius,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 2D point (normalized coordinate) in the viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 2D co-ordinate of the center. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the circle plane is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_circle_3d(\n    center,\n    radius,\n    normal=None,\n    angle=360.0,\n    start_dv=None,\n    c_arrow=False,\n    cc_arrow=False,\n    overrides=None,\n)\nDraw a circle around a 3D point in the plane perpendicular to the given normal\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\nVector\nA 3D position vector of the center\nrequired\n\n\nradius\nfloat\nThe radius of the circle\nrequired\n\n\nnormal\nVector | None\nThe normal vector of the plane on which the cirle is to be drawn. When None, the circle is drawn in the viewport plane\nNone\n\n\nangle\nfloat\nAn angle less than 360 for partial circle (arc) - in degrees Default is 360 degrees\n360.0\n\n\nstart_dv\nVector\nThe direction vector along which to start the circle (arc) If not provided, a random point in the plane perpendicular to the normal is chosen\nNone\n\n\nc_arrow\nbool\nWhether to display clockwise arrow. Default is False\nFalse\n\n\ncc_arrow\nbool\nWhether to display counter clockwise arrow. Default is False\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_cone(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cone\n1.0\n\n\nheight\nfloat\nHeight of the cone\n1.0\n\n\naxis\nVector\nAxis of the cone\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the base\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_cylinder(\n    location=(0, 0, 0),\n    radius=1.0,\n    height=1.0,\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw a cylinder\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the base center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the cylinder\n1.0\n\n\nheight\nfloat\nHeight of the cylinder\n1.0\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_line_2d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points (normalized co-ordinates) in 2D viewport space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n2D co-ordinates of the first point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv2\nVector\n2D co-ordinates of the second point. Normalized co-ordinate (0 - 1). (0, 0) is at bottom left\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_line_3d(\n    v1,\n    v2,\n    v1_text=None,\n    v2_text=None,\n    mid_text=None,\n    v1_arrow=False,\n    v2_arrow=False,\n    overrides=None,\n)\nDraw a line between two points in 3D space\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv1\nVector\n3D co-ordinates of the first point\nrequired\n\n\nv2\nVector\n3D co-ordinates of the second point\nrequired\n\n\nv1_text\nstr\nOptional text to display at v1\nNone\n\n\nv2_text\nstr\nOptional text to display at v2\nNone\n\n\nmid_text\nstr\nOptional text to display at the middle of the line\nNone\n\n\nv1_arrow\nbool\nWhether to display an arrow at v1\nFalse\n\n\nv2_arrow\nbool\nWhether to display an arrow at v2\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_n_sided_cylinder(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided cylinder Eg: square, rectangle, triangular prism, cube, cuboid, hexagonal cell etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the cylinder\n10\n\n\nheight\nfloat\nHeight of the cylinder\n10\n\n\norigin\nVector\nCenter of the base of the cylinder\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the cylinder\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of cylinder\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_n_sided_pyramid(\n    n=6,\n    radius=10,\n    height=10,\n    origin=(0, 0, 0),\n    axis=(0, 0, 1),\n    cap_ends=True,\n    overrides=None,\n)\nDraw an n sided pyramid Eg: triangle, prism, square pyramid, pentagonal pyramid, etc\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\n6\n\n\nradius\nfloat\nRadius of the pyramid\n10\n\n\nheight\nfloat\nHeight of the pyramid\n10\n\n\norigin\nVector\nCenter of the base of the pyramid\n(0, 0, 0)\n\n\naxis\nVector\nAxis of the pyramid\n(0, 0, 1)\n\n\ncap_ends\nbool\nWhether to cap the ends of pyramid\nTrue\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_sphere(\n    location=(0, 0, 0),\n    radius=1.0,\n    overrides=None,\n)\nDraw a sphere\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlocation\nVector\nA 3D position vector of the center\n(0, 0, 0)\n\n\nradius\nfloat\nRadius of the sphere\n1.0\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_text_2d(\n    pos_2d,\n    text,\n    overrides=None,\n)\nDraw text at a given 2D position (normalized co-ordinates) of Viewport.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_2d\nVector\nNormalized co-ordinates (0 - 1). (0, 0) is at bottom left\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_text_3d(\n    pos_3d,\n    text,\n    overrides=None,\n)\nDraw text at a given 3D position\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npos_3d\nVector\nCo-ordinates in 3D world space (x, y, z)\nrequired\n\n\ntext\nstr\nText to display. ‘|’ as multi-line separator\nrequired\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_triclinic_cell(\n    a=10.0,\n    b=10.0,\n    c=10.0,\n    alpha=90.0,\n    beta=90.0,\n    gamma=90.0,\n    origin=(0, 0, 0),\n    show_lattice=False,\n    overrides=None,\n)\nDraw a triclinic box based on box vector lengths and angles\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nBox vector a length\n10.0\n\n\nb\nfloat\nBox vector b length\n10.0\n\n\nc\nfloat\nBox vector c length\n10.0\n\n\nalpha\nfloat\nAngle between box vectors bc\n90.0\n\n\nbeta\nfloat\nAngle between box vectors ac\n90.0\n\n\ngamma\nfloat\nAngle between box vectors ab\n90.0\n\n\norigin\nVector\nOrigin of the box\n(0, 0, 0)\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.draw_wigner_seitz_cell(\n    triclinic_vectors,\n    center_to_origin=False,\n    show_lattice=False,\n    overrides=None,\n)\nDraw a Wigner-Seitz cell from triclinic vectors\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntriclinic_vectors\nnpt.ArrayLike\nVectors that represent the base triclinic cell\nrequired\n\n\ncenter_to_origin\nbool\nMove the center of the cell to origin (0, 0, 0)\nFalse\n\n\nshow_lattice\nbool\nWhether to show a 3x3x3 lattice\nFalse\n\n\noverrides\ndict\nOptional dictionary to override common annotation params\nNone\n\n\n\n\n\n\n\nentities.molecule.annotations.MoleculeInfo.pil_image_to_bpy_image(\n    pil_image,\n    name='PIL Image',\n)\nConvert PIL image to Blender image\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npil_image\nImage.Image\nPIL Image\nrequired\n\n\nname\nstr\nName of the bpy.data.images data block. Using an exisiting name will re-use the data block, whereas using a new name will create a new image data block.\n'PIL Image'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbpy.types.Image\nBlender Image",
    "crumbs": [
      "Reference",
      "Annotations",
      "entities.molecule.annotations"
    ]
  },
  {
    "objectID": "tutorials/streaming-trajectories.html",
    "href": "tutorials/streaming-trajectories.html",
    "title": "Streaming Trajectories",
    "section": "",
    "text": "With the MDAnalysis 2.10 release we can now stream information (positions, velocities etc) from an actively running simulation. This is useful for doing analysis ‘on-the-fly’ and even getting access to timesteps that would normally be discarded when saving to disk for size constraints.\nThanks to MDAnalysis handling everything ‘under the hood’ - we can also stream these results directly into Blender using Molecular Nodes.\nThis example uses the 2025 IMD workshop materials which provides example code for setting up and running a simulation that provide results for streaming. The simulation I show below is the example GROMACS simulation.\nStreaming isn’t supported in a GROMACS release at time of writing (but will be soon) - I followed these instructions for how to compile it myself with the new IMDClient functionality.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Streaming Trajectories"
    ]
  },
  {
    "objectID": "tutorials/streaming-trajectories.html#running-the-simulation",
    "href": "tutorials/streaming-trajectories.html#running-the-simulation",
    "title": "Streaming Trajectories",
    "section": "Running the Simulation",
    "text": "Running the Simulation\nOnce installed GROMACS and running the simulation should just be ./run.sh inside of the sample_simulation/GROMACS folder. By defualt it is set up to run on a single core (this demo was intended to run on GitHub codespaces), so we can make a quick change to increase the core count or else it won’t simulate fast enough for our purposes:\n\n\nrun.sh\n\n # Run simulation with IMD streaming\n-gmx mdrun -v -nt 1 \\\n+gmx mdrun -v -nt 8 \\\n\nAfter increasing the number of cores - we can start kick off the simulation and it will setup and wait for a client to connect.\nVideo\nOnce we have the simulation up and running - we can connect to it remotely with something using IMD Client. This is the point where you can do analysis with MDAnalysis, and also the point where we can connect to it with Molecular Nodes.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Streaming Trajectories"
    ]
  },
  {
    "objectID": "tutorials/streaming-trajectories.html#connecting-to-the-simulation",
    "href": "tutorials/streaming-trajectories.html#connecting-to-the-simulation",
    "title": "Streaming Trajectories",
    "section": "Connecting to the Simulation",
    "text": "Connecting to the Simulation\n\n\n\n\n\n\nExperimental\n\n\n\nConnecting to streaming trajectories in MN should still be considered experimental. As it becomes more mature in the simulation packages themselves we should be able to better decide on how this should all work.\n\n\nOnce we have a simulation that is up and running, we can import it to Molecular Nodes like we would a normal trajecotry. For the coordinates, instead of a filepath we give the IMD streaming server. By default on your own machine it will be imd://localhost:8889.\nAfter we load the trajectory, every time the frame changes inside of Blender it will fetch the latest frame from the simulation and the 3D model will be updated.\nVideo\nIf the simulation is dependent on GO / PAUSE orders then pausing Blender will pause the simulation, but we could just as easily link this to a running simulation which doesn’t wait for us and just visually inspect / render some frames from the simulation as it runs.\nEverything inside of Molecular Nodes like adding styles & selections should all work as normal, just that the positions come from a currently updating simulation.\n\n\n\n\n\n\nTimeline\n\n\n\nIf you scrub around on the timeline (move to the first frame) it will still advance to the next frame in the simulation. There is no caching of positions currently enabled so even going back in ‘time’ will move forward in time for the simulation.\n\n\n\nPotential Features\nLike said above - this is very experimental. Potential features could be: - caching some number of frames of the simulation so that scrubbing back N number of frames does acces old positions rather than always fetching new ones - IMD protocol supports sending forces back to the simulation. We could interact with the simulation via Blender\nIf you have other suggestions of questions around it, please open an issue or discussion on the GitHub page and discuss it there.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Streaming Trajectories"
    ]
  },
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "There are some written tutorials for different aspects of the process.\nThey are slightly outdated, as maintaining large amounts of documentation takes a lot of effort. Contributions on more documentation from community members are always appreciated!",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Tutorials"
    ]
  },
  {
    "objectID": "tutorials/installation.html",
    "href": "tutorials/installation.html",
    "title": "Installation",
    "section": "",
    "text": "Blender 4.2\n\n\n\nFor Blender 4.2, we no longer have to download anything externally. Molecular Nodes can be installed and updated from within Blender, using the new extensions platform. The installation instructions below are now much simpler.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Installation"
    ]
  },
  {
    "objectID": "tutorials/installation.html#downloading-blender",
    "href": "tutorials/installation.html#downloading-blender",
    "title": "Installation",
    "section": "Downloading Blender",
    "text": "Downloading Blender\nMolecular Nodes is an add-on for the 3D animation program Blender. It runs inside of Blender, so the first step for installation is to download and install the latest version of blender.\n\n\n\nThe download page of Blender.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Installation"
    ]
  },
  {
    "objectID": "tutorials/installation.html#installing-the-addon",
    "href": "tutorials/installation.html#installing-the-addon",
    "title": "Installation",
    "section": "Installing the Addon",
    "text": "Installing the Addon\nFollow the screenshots below to install the add-on. These steps should be the same across platforms.\nOpen the preferences window.\n\nSelect the Get Extensions panel and search for Molecular Nodes.\n\nClicking the Install button will download and install the add-on. The download is ~100 MB so may take some minutes depending on internet connection.\nVideo\n\nThat’s it!\nAll of the additional python packages now come pre-installed. To update the add-on, use the same panel and Blender should automatically detect updates.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Installation"
    ]
  },
  {
    "objectID": "tutorials/installation.html#installing-the-startup-template",
    "href": "tutorials/installation.html#installing-the-startup-template",
    "title": "Installation",
    "section": "Installing the Startup Template",
    "text": "Installing the Startup Template\nThere are a number of settings that are useful to have tweaked on startup. You can install the Molecular Nodes startup template in the add-on preferences or uninstall the template.\nTHis adds it as an option on the startup splash screen, or when starting a new file.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Installation"
    ]
  },
  {
    "objectID": "tutorials/installation.html#start-importing-structures",
    "href": "tutorials/installation.html#start-importing-structures",
    "title": "Installation",
    "section": "Start Importing Structures!",
    "text": "Start Importing Structures!\nMolecular nodes should be fully installed. See the Getting Started page on how to start importing into Blender!",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Installation"
    ]
  },
  {
    "objectID": "tutorials/installation.html#troubleshooting",
    "href": "tutorials/installation.html#troubleshooting",
    "title": "Installation",
    "section": "Troubleshooting",
    "text": "Troubleshooting\n\nInstallation error: missing biotite module\nIn some Linux systems, trying to install Molecular Nodes through the Get Extensions panel in Blender may lead to the following error:\nReport: Error\nNo module named 'biotite.structure.bonds' \nThis is likely due to a mismatch in the Python versions installed in your system and in what Blender expects (see issue #629).\nTo avoid this issue, try installing Blender through a self-contained package system such as Flatpack or Snap. These package managers usually need to be installed and/or activated in your system.\nFor example, after installing Snap in Fedora 40, you can install Blender through Snap with the command which solves the biotite dependency error.\nsudo snap install blender --classic",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "Installation"
    ]
  },
  {
    "objectID": "tutorials/cryoem.html",
    "href": "tutorials/cryoem.html",
    "title": "CryoEM Maps",
    "section": "",
    "text": "We can import CryoEM maps, which are imported into Blender as a ‘volume’ object. As Blender is designed to work with data for movies and TV shows, this is implemented in a way to emulate smoke or gas. We aren’t looking to annimate these volumes, but when we import the volume we can create a surface based on a cutoff for the density, the same as you do with ChimeraX.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "CryoEM Maps"
    ]
  },
  {
    "objectID": "tutorials/cryoem.html#importing-panel",
    "href": "tutorials/cryoem.html#importing-panel",
    "title": "CryoEM Maps",
    "section": "Importing Panel",
    "text": "Importing Panel\n\n\nName The name that will be given to the newly created object inside of Blender.\nFile The .map or .map.gz file to be imported to Blender.\nStyle The initial style to apply to the volume object when imported into Blender.\nInvert Data Whether to invert the data when importing (usually used for CryoET data)\nCentre Density Translates the data so that the world origin is in the middle, rather than the corner of the density.\n\n\n\n\n\n\n\nWarning\n\n\n\nBlender currently can’t directly import the .map files. Instead we convert the file to a .vdb volume file, then import that to Blender. This intermediate file will be saved next to the .map file. If you move or delete this intermediate file, then it will break the volume inside of Blender, so be careful moving files around after import.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "CryoEM Maps"
    ]
  },
  {
    "objectID": "tutorials/cryoem.html#example-data",
    "href": "tutorials/cryoem.html#example-data",
    "title": "CryoEM Maps",
    "section": "Example Data",
    "text": "Example Data\nAs an example, we are going to use the structure and the map correlating to 8E3Z as an example. You can import the structure using the PDB import in Molecular Nodes, and the map you can download from the EMDB page. Ensure you download the .map.gz file.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "CryoEM Maps"
    ]
  },
  {
    "objectID": "tutorials/cryoem.html#importing",
    "href": "tutorials/cryoem.html#importing",
    "title": "CryoEM Maps",
    "section": "Importing",
    "text": "Importing\nSelect the file and import to Blender.\nThere should be a surface that has appeared, which has a goemetry nodes modifier with a single node applied.\n\nYou can adjust the threshold which is the cutoff at which Blender will create a surface mesh.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "CryoEM Maps"
    ]
  },
  {
    "objectID": "tutorials/cryoem.html#importing-structure",
    "href": "tutorials/cryoem.html#importing-structure",
    "title": "CryoEM Maps",
    "section": "Importing Structure",
    "text": "Importing Structure\nWhen we import a structure, both the density and the structure should align perfectly, as long as neither were imported with the ‘centre’ option selected.\nWe can import the structure 8E3Z via the PDB tab with Ribbon styling, and see how it overlaps with the surface from the density.",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "CryoEM Maps"
    ]
  },
  {
    "objectID": "tutorials/cryoem.html#sampling-colors",
    "href": "tutorials/cryoem.html#sampling-colors",
    "title": "CryoEM Maps",
    "section": "Sampling Colors",
    "text": "Sampling Colors\nCurrently all of the colors on the mesh are uniform. There is the field input Color, so we can sample the color from the atoms of a structure, and use that information to color the surface.\nWe will use the Sample Nearest Attribute node from the Molecular Nodes -&gt; Density menu. This node will take the atoms of a structure and can transfer the information from that structure onto the surface created for that volume.\nThe structure which we have currently imported however isn’t showing the atoms - it is displaying the ribbon style. We can duplicate the structure with Shift + D in the 3D viewport, and change the node group used so that it displays the atoms rather than applying a style.\nVideo\nIn the demo video, we duplicate the object. When duplicating, both objects are using the same node tree, so we then also duplicate the node tree. Now we can remove the style from the new node tree, and use this object to sample colors for our surface. The original structure object remains unchanged and still contains a node tree which applies the ribbon style.\nIf you want to change the colors which are applied to the surface, we change the node tree of the object which contains the atoms. Changing thesse nodes will change the colors that are applied, and thus change the colors which are sampled to the surface for coloring.\nVideo",
    "crumbs": [
      "Documentation",
      "Tutorials",
      "CryoEM Maps"
    ]
  }
]