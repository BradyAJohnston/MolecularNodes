---
title: Annotations
description: Annotations API and Examples
jupyter: python3
execute:
  daemon: false
---

Annotations API allows adding annotations to molecular entities. Molecular Nodes comes with a few bundled annotations for trajectories, but new ones can be dynamically added as well.

## Setup Molecular Nodes

```{python}
import molecularnodes as mn
import MDAnalysis as mda
from MDAnalysis.tests.datafiles import DCD, PSF, TPR, XTC

# create a canvas object
canvas = mn.Canvas()
```

## Add a Trajectory Entity

```{python}
#| warning: false
u = mda.Universe(PSF, DCD)
t = mn.Trajectory(u).add_style("cartoon")
```

## Adding Annotations

Annotations can be added using the `add_<annotation_type>` method of the annotations manager of an entity. Each entity can have different annotation types supported. 

The bundled annotation types for Trajectories are:

- [`add_atom_info()`](`~mn.entities.trajectory.annotations.AtomInfo`) - For some basic atom info
- [`add_com()`](`~mn.entities.trajectory.annotations.COM) - For center-of-mass of a selection
- [`add_com_distance()`](`~mn.entities.trajectory.annotations.COMDistance`) - For distance between two center-of-masses
- [`add_canonical_dihedrals()`](`~mn.entities.trajectory.annotations.CanonicalDihedrals`) - For canonical dihedrals of a residue
- [`add_universe_info()`](`~mn.entities.trajectory.annotations.UniverseInfo`) - For universe info
- [`add_label_2d()`](`~mn.entities.trajectory.annotations.Label2D`) - For adding a generic 2d label in viewport / render
- [`add_label_3d()`](`~mn.entities.trajectory.annotations.Label3D`) - For adding a generic 3d label

All selections used in the annotation APIs can be either MDAnalysis selection phrases (strings) or instances of `AtomGroup`s.

Here is how to access the annotations manager of an entity:

```{python}
# annotations manager
t.annotations
```

Available annotation types can be seen as follows:

```{python}
# available annotation types
[a for a in t.annotations.__dir__() if a.startswith("add_")]
```

Each annotation type can have different input parameters. A common parameter `name` can be passed to name the annotation for easier name based lookups later. All the parameters to the `add_<annotation_type>` method have to be keyword params. 

Annotations can be added using the `add_<annotation_type>` method, which returns an instance that can be used to further customize the annotation. Annotation specific inputs as well as common annotation parameters can be customized.

The function signature for adding an annotation type can be seen as follows:

```{python}
t.annotations.add_atom_info.func.__signature__
```

## Annotation Examples

### [atom_info](`~molecularnodes.entities.trajectory.annotations.AtomInfo`)

Display the atom info of a selection.

The input parameters for this annotation are:

- `selection` - An MDAnalysis selection phrase or `AtomGroup`
- `show_resid` - Whether to show the resid
- `show_segid` - Whether to show the segid

```{python}
# add a style to display all the alpha carbons as spheres
t.add_style(
    selection="name CA", style="ball_and_stick", color=(0.162, 0.624, 0.196, 1.0)
)
# add the atom_info annotation
a1 = t.annotations.add_atom_info(
    selection="resid 73:78 and name CA",
    show_resid=True,
    show_segid=True,
    name="r1 atom info"
)
# set the font size to 12
a1.text_size = 12
```

```{python}
# frame the view and render
canvas.frame_view(t.get_view("resid 73:78"), viewpoint="front")
canvas.snapshot()
```

```{python}
# hide the annotation and remove the added style
a1.visible = False
t.styles[1].remove()
```

### [com](`molecularnodes.entities.trajectory.annotations.COM`)

Display the center-of-mass of a selection.

The input parameters for this annotation are:

- `selection` - An MDAnalysis selection phrase or `AtomGroup`
- `text` - Text to be displayed at the center-of-mass of selection

```{python}
# show com of the whole protein
a2 = t.annotations.add_com(selection="protein", text="Protein|COM", name="Protein COM")
# show com of residues 150 through 170
a3 = t.annotations.add_com(selection="resid 150:170", text="resid 150:170|COM")
```

```{python}
# frame the view and render
canvas.frame_view(t.get_view(), viewpoint="front")
canvas.snapshot()
```

```{python}
# hide the added annotations
a2.visible = False
a3.visible = False
```

### [com_distance](`molecularnodes.entities.trajectory.annotations.COMDistance`)

Display the distance between center-of-masses of two selections.

The input parameters for this annotation are:

- `selection1` - An MDAnalysis selection phrase or `AtomGroup` of first selection
- `selection2` - An MDAnalysis selection phrase or `AtomGroup` of second selection
- `text1` - Text to display at com of first selection
- `text2` - Text to display at com of second selection

```{python}
# add com_distance between resid 1 and 129
a4 = t.annotations.add_com_distance(
    selection1="resid 1",
    selection2=u.select_atoms("resid 129"),
    text1="resid 1|COM",
    text2="resid 129|COM",
    name="r1-129 distance",
)
# display the distance line as a 3d mesh
# with the 2d line overlay and a specific color
a4.line_mode = "mesh_and_overlay"
a4.mesh_color = (0, 1, 0, 1)  # (r, g, b, a)
```

```{python}
# frame the view and render
canvas.frame_view(t.get_view("resid 1 129"), viewpoint="bottom")
canvas.snapshot()
```

```{python}
# hide the added annotation
a4.visible = False
```

### [canonical_dihedrals](`molecularnodes.entities.trajectory.annotations.CanonicalDihedrals`)

Display the canonical dihedrals of a residue

The input parameters for this annotation are:

- `resid` - The residue id
- `show_atom_names` - Whether to show the atom names in the residue
- `show_direction` - Whether to show the direction arcs of the dihedral angles

```{python}
# show canonical dihedrals of residue 200
a5 = t.annotations.add_canonical_dihedrals(resid=200)
```

```{python}
# frame the view and render
canvas.frame_view(t.get_view("resid 200"), viewpoint="back")
canvas.snapshot()
```

```{python}
# hide the added annotation
a5.visible = False
```

### [universe_info](`molecularnodes.entities.trajectory.annotations.UniverseInfo`)

Display the universe info of the trajectory.

The input parameters for this annotation are:

- `location` - Normalized 2d location (0.0 - 1.0) to show the info wrt viewport / render
- `show_frame` - Whether or not to show the frame number of the trajectory
- `show_topology` - Whether or not to show the topology filename
- `show_trajectory` - Whether or not to show the trajectory filename
- `show_atoms` - Whether or not to show the number of atoms in the universe

```{python}
# add universe_info annotation
a6 = t.annotations.add_universe_info()
```

```{python}
# frame the view and render
canvas.frame_view(t.get_view(), viewpoint="top")
canvas.snapshot(frame=50)
```

```{python}
# hide the added annotation
a6.visible = False
```

### [simulation_box](`molecularnodes.entities.trajectory.annotations.SimulationBox`)

Display the simulation box of the trajectory if box dimensions are present.

The input parameters for this annotation are:

- `center_to_origin` - Whether to move the center of the box to Origin (0, 0, 0)
- `compact` - Whether to create a compact Wigner-Seitz cell. Note that the trajectory needs to have been wrapped with the compact option to see it within the box
- `show_lattice` - Whether to show a 3x3x3 lattice of the box

```{python}
# add simulation box annotation
t.annotations.add_simulation_box()
```

### [label_2d](`molecularnodes.entities.trajectory.annotations.Label2D`)

Display a generic 2d label in the viewport / render.

The input parameters for this annotation are:

- `text` - Text to display
- `location` - Normalized location (0.0 - 1.0) to show the text wrt viewport / render

```{python}
# show a 2d label at the top left
a7 = t.annotations.add_label_2d(text="Any|2D Label", location=(0.1, 0.8))
```

```{python}
# frame the view and render
canvas.frame_view(t.get_view(), viewpoint="left")
canvas.snapshot()
```

```{python}
# hide the added annotation
a7.visible = False
```

### [label_3d](`molecularnodes.entities.trajectory.annotations.Label3D`)

Display a generic 3d label on the universe.

The input parameters for this annotation are:

- `text` - Text to display
- `location` - 3d coordinates in universe to display text

```{python}
# show the alpha carbon of resid 1 as a sphere
t.add_style(
    selection="resid 1 and name CA",
    style="ball_and_stick",
    color=(0.162, 0.624, 0.196, 1.0),
)
# select the alpha carbon of resid 1
r1 = t.universe.select_atoms("resid 1 and name CA")
atom = r1.atoms[0]
# add a 3d label to display text at this atom's location
a8 = t.annotations.add_label_3d(text=f"CA|resid 1|{atom.segid}", location=atom.position)
# add a pointer to point at the location
a8.line_pointer_length = 2
a8.line_width = 2
```

```{python}
# frame the view and render
canvas.frame_view(t.get_view("resid 1"), viewpoint="front")
canvas.snapshot()
```

```{python}
# hide the added annotation
a8.visible = False
# remove the added style
t.styles[1].remove()
```

## Accessing Annotations

Annotations added to an entity can be accessed in several different ways.

### Name based access

```{python}
# get the resid 1 atom info annotation by name - subscriptable
a = t.annotations["r1 atom info"]
print(a)
# get the resid 1 atom info annotation by name - get method
a = t.annotations.get("r1 atom info")
print(a)
```

### Index based access

```{python}
print("# annotations = ", len(t.annotations))
# get the protein COM annotation by index
a = t.annotations[1]
a
```

### Iterable access

```{python}
# access all annotations by iteration
for a in t.annotations:
    print(a.name)
```

## Controlling Visiblity

All annotations of an entity can be collectively hidden or displayed using the `visible` attribute of the annotations manager.

```{python}
# get current annotations visibility
t.annotations.visible
```

```{python}
# hide all annotations
t.annotations.visible = False
t.annotations.visible
```

```{python}
# show all annotations
t.annotations.visible = True
t.annotations.visible
```

## Common Annotation Params

All annotations have common params that control the display properties. These params are in addition to the annotation specific inputs.

The common annotation params are:

- `name` - Name of the annotation
- `visible` - Whether or not the annotation is visible
- `text_font` - Filename of the custom font to use for text
- `text_color` - Text color - rgba tuple like (1.0, 0.0, 1.0, 1.0)
- `text_size` - Size of the text displayed
- `text_alignment` - Alignment of the text (`center`, `left`, `right`)
- `text_rotation` - Angle by which to rotate text when left aligned
- `text_vspacing` - Vertical spacing between lines in multi line text
- `text_depth` - Whether to enable showing text size based on depth (default: True)
- `text_falloff` - A normalized value (0.0 - 1.0) of how the text size falls off with distance from the viewport / camera
- `text_offset_x` - Text offset along the x direction (in pixels)
- `text_offset_y` - Text offset along the y direction (in pixels)
- `line_arrow_size` - Size of the arrow displayed (for lines with arrow ends)
- `line_pointer_length` - Length of a pointer line to draw (defaults to 0, which is no pointer)
- `line_mode` - Display mode of line (`overlay`, `mesh`, `mesh_and_overlay`)
- `mesh_wireframe` - Whether to show 3d meshes as wireframes
- `mesh_thickness` - Thickness of the edges in wireframe mode
- `mesh_color` - Color of the 3d meshes
- `mesh_material` - Material to use for 3d meshes
- `mesh_shade_smooth` - Whether to use shade smooth for 3d meshes

```{python}
# common annotation params for a1
[(p, getattr(a1, p)) for p in a1.__dir__() if not p.startswith("_")]
```

## Removing Annotations

Individual annotaitons can be removed using the annotation name or annotation instance.

### Remove by name

```{python}
# remove by an annotation name
t.annotations.remove("r1 atom info")
```
### Remove by instance

```{python}
# remove by an annotation instance
t.annotations.remove(a4)
```

### Remove all annoations

```{python}
# remove all annotations
t.annotations.clear()
```

## Custom Annotations

In addition to the above bundled annotations for Trajectories, custom annotation types can be created by extending the [](`~molecularnodes.entities.trajectory.annotations.TrajectoryAnnotation`) class. These custom annotation types will be automatically registered and can be added using the same `add_<annotation_type>` method of a trajectory instance. The GUI to add and configure the annotation will also be automatically available.

### Create a custom annotation

A custom trajectory annotation class has to extend [](`~molecularnodes.entities.trajectory.annotations.TrajectoryAnnotation`) and implement the [](`~molecularnodes.annotations.base.BaseAnnotation.draw`) method. Optional [](`~molecularnodes.annotations.base.BaseAnnotation.defaults`) method can be used to set defaults for the annotation and a [](`~molecularnodes.annotations.base.BaseAnnotation.validate`) method that can validate inputs when they change can be implemented. The custom class will have access to the trajectory entity via `self.trajectory`, universe via `self.trajectory.universe` and the annotation params via `self.interface`. Please see the drawing utilities section for all the methods available to draw onto the viewport / renders from the [](`~molecularnodes.annotations.base.BaseAnnotation.draw`) code.

```{python}
# Add a CutomAnnotation class
# This class will auto-register with the Trajectory entities
class CustomAnnotation(mn.entities.trajectory.TrajectoryAnnotation):
    annotation_type = "custom_annotation"

    selection: str  # required param
    bool_param: bool = False  # optional bool param

    # optional defaults method
    def defaults(self) -> None:
        # any default settings for this annotation go here
        params = self.interface
        # set text size to 24
        params.text_size = 20

    # optional validate method
    def validate(self, input_name: str = None) -> bool:
        # validate any input params that change (either through API or GUI)
        # return True if validation succeeds else False or raise an Exception
        params = self.interface
        universe = self.trajectory.universe
        # validate and save the selection atom group
        if isinstance(params.selection, str):
            # check if selection phrase is valid
            # mda throws exception if invalid
            self.atom_group = universe.select_atoms(params.selection)
        elif isinstance(params.selection, AtomGroup):
            self.atom_group = params.selection
        else:
            raise ValueError(f"Need str or AtomGroup. Got {type(params.selection)}")
        return True

    # required draw method
    def draw(self) -> None:
        # the draw code for this annotation
        # self.trajectory points to the trajectory instance
        # self.interface points to the interface that provides
        #     the annotation inputs and common annotation parameters
        # show the atom names of the selection
        for atom in self.atom_group:
            self.draw_text_3d(atom.position, atom.name)
```

### Add the custom annotation

```{python}
t.add_style(selection="resid 75", style="ball_and_stick")
# add the custom annotation and pass the required selection parameter
ca = t.annotations.add_custom_annotation(selection="resid 75")
ca
```

```{python}
# frame the view and render
canvas.frame_view(t.get_view("resid 75"), viewpoint="front")
canvas.snapshot()
```

```{python}
# hide the added annotation
ca.visible = False
```

### Unregister a custom annotation

Custom annotations get automatically registered with the [](`~mn.entities.trajectory.annotations.TrajectoryAnnotationManager`). They can be manually unregistered and re-registered using the [](`~mn.annotations.manager.BaseAnnotationManager.unregister_type`) and [](`~mn.annotations.manager.BaseAnnotationManager.register_class`) methods if required.

```{python}
# unregister the annotation
manager = mn.entities.trajectory.TrajectoryAnnotationManager
manager.unregister_type("custom_annotation")
```

### Drawing utilities

Custom annotations can use the drawing utilities available from the base annotation class to display text or drawings in the viewport / renders.

The following utility methods are currently available:

- [](`~molecularnodes.annotations.base.BaseAnnotation.distance`) - Distance between two vectors
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_text_2d`) - Draw text at a given 2D position (in pixels) of Viewport
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_text_2d_norm`) - Draw text at a given 2D position (normalized co-ordinates) of Viewport.
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_text_3d`) - Draw text at a given 3D position
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_line_2d`) - Draw a line between two points in 2D viewport space
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_line_3d`) - Draw a line between two points in 3D space
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_circle_3d`) - Draw a circle around a 3D point in the plane perpendicular to the given normal
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_sphere`) - Draw a sphere object at a 3D point
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_cone`) - Draw a cone object along an axis
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_cylinder`) - Draw a cylinder object along an axis
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_n_sided_cylinder`) - Draw an n sided cylinder
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_n_sided_pyramid`) - Draw an n sided pyramid
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_triclinic_cell`) - Draw a triclinic cell
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_wigner_seitz_cell`) - Draw a compact Wigner-Seitz cell
- [](`~molecularnodes.annotations.base.BaseAnnotation.draw_bmesh`) - Draw a generic Blender BMesh

These methods can be used within the `draw` method of a custom annotation. Please see the API reference for [](`mn.annotations.base`) for details about these methods.
