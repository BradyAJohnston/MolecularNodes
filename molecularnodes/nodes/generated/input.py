"""
Auto-generated Blender Geometry Node classes.

DO NOT EDIT THIS FILE MANUALLY.
This file is generated by molecularnodes/nodes/generator.py

To regenerate: Run generator.py from within Blender

KNOWN LIMITATIONS:
- Dynamic multi-input/output sockets are not yet supported
  (these are the unnamed sockets that appear in the UI for nodes like
  "Evaluate Closure", "Join Geometry", etc. that allow dragging in
  multiple connections)
- TODO: Add support for dynamic socket creation
"""

from __future__ import annotations
from typing import Any
from bpy.types import NodeSocket
from ..builder import NodeBuilder, TreeBuilder

# Type aliases for node inputs
LINKABLE = "NodeSocket | NodeBuilder | Any"
TYPE_INPUT_VECTOR = "tuple[float, float, float] | NodeSocket | NodeBuilder | None"
TYPE_INPUT_ROTATION = (
    "tuple[float, float, float, float] | NodeSocket | NodeBuilder | None"
)
TYPE_INPUT_BOOLEAN = "bool | NodeSocket | NodeBuilder | None"


class Boolean(NodeBuilder):
    """Boolean node"""

    name = "FunctionNodeInputBool"

    def __init__(self, boolean: bool | None = None):
        super().__init__()

        if boolean is not None:
            self.node.boolean = boolean

    @property
    def boolean(self) -> NodeSocket:
        """Output socket: Boolean"""
        return self.node.outputs["Boolean"]


class Color(NodeBuilder):
    """Color node"""

    name = "FunctionNodeInputColor"

    def __init__(self, value: float | None = None):
        super().__init__()

        if value is not None:
            self.node.value = value

    @property
    def color(self) -> NodeSocket:
        """Output socket: Color"""
        return self.node.outputs["Color"]


class Integer(NodeBuilder):
    """Integer node"""

    name = "FunctionNodeInputInt"

    def __init__(self, integer: int | None = None):
        super().__init__()

        if integer is not None:
            self.node.integer = integer

    @property
    def integer(self) -> NodeSocket:
        """Output socket: Integer"""
        return self.node.outputs["Integer"]


class String(NodeBuilder):
    """String node"""

    name = "FunctionNodeInputString"

    def __init__(self, string: Any | None = None):
        super().__init__()

        if string is not None:
            self.node.string = string

    @property
    def string(self) -> NodeSocket:
        """Output socket: String"""
        return self.node.outputs["String"]


class Vector(NodeBuilder):
    """Vector node"""

    name = "FunctionNodeInputVector"

    def __init__(self, vector: float | None = None):
        super().__init__()

        if vector is not None:
            self.node.vector = vector

    @property
    def vector(self) -> NodeSocket:
        """Output socket: Vector"""
        return self.node.outputs["Vector"]


class ClosureInput(NodeBuilder):
    """Closure Input node"""

    name = "GeometryNodeClosureInput"

    def __init__(self):
        super().__init__()


class ForEachGeometryElementInput(NodeBuilder):
    """For Each Geometry Element Input node"""

    name = "GeometryNodeForeachGeometryElementInput"

    def __init__(
        self,
        geometry: LINKABLE = None,
        selection: TYPE_INPUT_BOOLEAN = None,
        __extend__: LINKABLE | None = None,
    ):
        super().__init__()
        self._establish_links(
            **{"Geometry": geometry, "Selection": selection, "__extend__": __extend__}
        )

    @property
    def index(self) -> NodeSocket:
        """Output socket: Index"""
        return self.node.outputs["Index"]


class ActiveCamera(NodeBuilder):
    """Retrieve the scene's active camera"""

    name = "GeometryNodeInputActiveCamera"

    def __init__(self):
        super().__init__()

    @property
    def active_camera(self) -> NodeSocket:
        """Output socket: Active Camera"""
        return self.node.outputs["Active Camera"]


class Collection(NodeBuilder):
    """Output a single collection"""

    name = "GeometryNodeInputCollection"

    def __init__(self):
        super().__init__()

    @property
    def collection(self) -> NodeSocket:
        """Output socket: Collection"""
        return self.node.outputs["Collection"]


class IsEdgeSmooth(NodeBuilder):
    """Retrieve whether each edge is marked for smooth or split normals"""

    name = "GeometryNodeInputEdgeSmooth"

    def __init__(self):
        super().__init__()

    @property
    def smooth(self) -> NodeSocket:
        """Output socket: Smooth"""
        return self.node.outputs["Smooth"]


class Id(NodeBuilder):
    """Retrieve a stable random identifier value from the "id" attribute on the point domain, or the index if the attribute does not exist"""

    name = "GeometryNodeInputID"

    def __init__(self):
        super().__init__()

    @property
    def id(self) -> NodeSocket:
        """Output socket: ID"""
        return self.node.outputs["ID"]


class Image(NodeBuilder):
    """Input an image data-block"""

    name = "GeometryNodeInputImage"

    def __init__(self):
        super().__init__()

    @property
    def image(self) -> NodeSocket:
        """Output socket: Image"""
        return self.node.outputs["Image"]


class Index(NodeBuilder):
    """Retrieve an integer value indicating the position of each element in the list, starting at zero"""

    name = "GeometryNodeInputIndex"

    def __init__(self):
        super().__init__()

    @property
    def index(self) -> NodeSocket:
        """Output socket: Index"""
        return self.node.outputs["Index"]


class InstanceBounds(NodeBuilder):
    """Calculate position bounds of each instance's geometry set"""

    name = "GeometryNodeInputInstanceBounds"

    def __init__(self, use_radius: TYPE_INPUT_BOOLEAN = None):
        super().__init__()
        self._establish_links(**{"Use Radius": use_radius})

    @property
    def min(self) -> NodeSocket:
        """Output socket: Min"""
        return self.node.outputs["Min"]

    @property
    def max(self) -> NodeSocket:
        """Output socket: Max"""
        return self.node.outputs["Max"]


class InstanceRotation(NodeBuilder):
    """Retrieve the rotation of each instance in the geometry"""

    name = "GeometryNodeInputInstanceRotation"

    def __init__(self):
        super().__init__()

    @property
    def rotation(self) -> NodeSocket:
        """Output socket: Rotation"""
        return self.node.outputs["Rotation"]


class InstanceScale(NodeBuilder):
    """Retrieve the scale of each instance in the geometry"""

    name = "GeometryNodeInputInstanceScale"

    def __init__(self):
        super().__init__()

    @property
    def scale(self) -> NodeSocket:
        """Output socket: Scale"""
        return self.node.outputs["Scale"]


class Material(NodeBuilder):
    """Output a single material"""

    name = "GeometryNodeInputMaterial"

    def __init__(self):
        super().__init__()

    @property
    def material(self) -> NodeSocket:
        """Output socket: Material"""
        return self.node.outputs["Material"]


class MaterialIndex(NodeBuilder):
    """Retrieve the index of the material used for each element in the geometry's list of materials"""

    name = "GeometryNodeInputMaterialIndex"

    def __init__(self):
        super().__init__()

    @property
    def material_index(self) -> NodeSocket:
        """Output socket: Material Index"""
        return self.node.outputs["Material Index"]


class NamedLayerSelection(NodeBuilder):
    """Output a selection of a Grease Pencil layer"""

    name = "GeometryNodeInputNamedLayerSelection"

    def __init__(self, name: str | LINKABLE | None = None):
        super().__init__()
        self._establish_links(**{"Name": name})

    @property
    def selection(self) -> NodeSocket:
        """Output socket: Selection"""
        return self.node.outputs["Selection"]


class Normal(NodeBuilder):
    """Retrieve a unit length vector indicating the direction pointing away from the geometry at each element"""

    name = "GeometryNodeInputNormal"

    def __init__(self, legacy_corner_normals: bool | None = None):
        super().__init__()

        if legacy_corner_normals is not None:
            self.node.legacy_corner_normals = legacy_corner_normals

    @property
    def normal(self) -> NodeSocket:
        """Output socket: Normal"""
        return self.node.outputs["Normal"]

    @property
    def true_normal(self) -> NodeSocket:
        """Output socket: True Normal"""
        return self.node.outputs["True Normal"]


class Object(NodeBuilder):
    """Output a single object"""

    name = "GeometryNodeInputObject"

    def __init__(self):
        super().__init__()

    @property
    def object(self) -> NodeSocket:
        """Output socket: Object"""
        return self.node.outputs["Object"]


class Position(NodeBuilder):
    """Retrieve a vector indicating the location of each element"""

    name = "GeometryNodeInputPosition"

    def __init__(self):
        super().__init__()

    @property
    def position(self) -> NodeSocket:
        """Output socket: Position"""
        return self.node.outputs["Position"]


class Radius(NodeBuilder):
    """Retrieve the radius at each point on curve or point cloud geometry"""

    name = "GeometryNodeInputRadius"

    def __init__(self):
        super().__init__()

    @property
    def radius(self) -> NodeSocket:
        """Output socket: Radius"""
        return self.node.outputs["Radius"]


class SceneTime(NodeBuilder):
    """Retrieve the current time in the scene's animation in units of seconds or frames"""

    name = "GeometryNodeInputSceneTime"

    def __init__(self):
        super().__init__()

    @property
    def seconds(self) -> NodeSocket:
        """Output socket: Seconds"""
        return self.node.outputs["Seconds"]

    @property
    def frame(self) -> NodeSocket:
        """Output socket: Frame"""
        return self.node.outputs["Frame"]


class IsFaceSmooth(NodeBuilder):
    """Retrieve whether each face is marked for smooth or sharp normals"""

    name = "GeometryNodeInputShadeSmooth"

    def __init__(self):
        super().__init__()

    @property
    def smooth(self) -> NodeSocket:
        """Output socket: Smooth"""
        return self.node.outputs["Smooth"]


class ShortestEdgePaths(NodeBuilder):
    """Find the shortest paths along mesh edges to selected end vertices, with customizable cost per edge"""

    name = "GeometryNodeInputShortestEdgePaths"

    def __init__(
        self,
        end_vertex: TYPE_INPUT_BOOLEAN = None,
        edge_cost: float | LINKABLE | None = None,
    ):
        super().__init__()
        self._establish_links(**{"End Vertex": end_vertex, "Edge Cost": edge_cost})

    @property
    def next_vertex_index(self) -> NodeSocket:
        """Output socket: Next Vertex Index"""
        return self.node.outputs["Next Vertex Index"]

    @property
    def total_cost(self) -> NodeSocket:
        """Output socket: Total Cost"""
        return self.node.outputs["Total Cost"]


class IsSplineCyclic(NodeBuilder):
    """Retrieve whether each spline endpoint connects to the beginning"""

    name = "GeometryNodeInputSplineCyclic"

    def __init__(self):
        super().__init__()

    @property
    def cyclic(self) -> NodeSocket:
        """Output socket: Cyclic"""
        return self.node.outputs["Cyclic"]


class SplineResolution(NodeBuilder):
    """Retrieve the number of evaluated points that will be generated for every control point on curves"""

    name = "GeometryNodeInputSplineResolution"

    def __init__(self):
        super().__init__()

    @property
    def resolution(self) -> NodeSocket:
        """Output socket: Resolution"""
        return self.node.outputs["Resolution"]


class CurveTangent(NodeBuilder):
    """Retrieve the direction of curves at each control point"""

    name = "GeometryNodeInputTangent"

    def __init__(self):
        super().__init__()

    @property
    def tangent(self) -> NodeSocket:
        """Output socket: Tangent"""
        return self.node.outputs["Tangent"]


class RepeatInput(NodeBuilder):
    """Repeat Input node"""

    name = "GeometryNodeRepeatInput"

    def __init__(
        self,
        iterations: int | LINKABLE | None = None,
        __extend__: LINKABLE | None = None,
    ):
        super().__init__()
        self._establish_links(**{"Iterations": iterations, "__extend__": __extend__})

    @property
    def iteration(self) -> NodeSocket:
        """Output socket: Iteration"""
        return self.node.outputs["Iteration"]


class SimulationInput(NodeBuilder):
    """Input data for the simulation zone"""

    name = "GeometryNodeSimulationInput"

    def __init__(self):
        super().__init__()

    @property
    def delta_time(self) -> NodeSocket:
        """Output socket: Delta Time"""
        return self.node.outputs["Delta Time"]


class Value(NodeBuilder):
    """Input numerical values to other nodes in the tree"""

    name = "ShaderNodeValue"

    def __init__(self):
        super().__init__()

    @property
    def value(self) -> NodeSocket:
        """Output socket: Value"""
        return self.node.outputs["Value"]
