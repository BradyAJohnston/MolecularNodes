"""
Auto-generated Blender Geometry Node classes.

DO NOT EDIT THIS FILE MANUALLY.
This file is generated by molecularnodes/nodes/generator.py

To regenerate: Run generator.py from within Blender

KNOWN LIMITATIONS:
- Dynamic multi-input/output sockets are not yet supported
  (these are the unnamed sockets that appear in the UI for nodes like
  "Evaluate Closure", "Join Geometry", etc. that allow dragging in
  multiple connections)
- TODO: Add support for dynamic socket creation
"""

from __future__ import annotations
import bpy
from typing import Any
from typing_extensions import Literal
from ..builder import NodeBuilder, NodeSocket
from . import types
from .types import LINKABLE, TYPE_INPUT_BOOLEAN, TYPE_INPUT_VECTOR


class DomainSize(NodeBuilder):
    """Retrieve the number of elements in a geometry for each attribute domain"""

    name = "GeometryNodeAttributeDomainSize"
    node: bpy.types.GeometryNodeAttributeDomainSize

    def __init__(
        self,
        geometry: LINKABLE = None,
        component: Literal[
            "MESH", "POINTCLOUD", "CURVE", "INSTANCES", "GREASEPENCIL"
        ] = "MESH",
        **kwargs,
    ):
        super().__init__()
        key_args = {"Geometry": geometry}
        key_args.update(kwargs)
        self.component = component
        self._establish_links(**key_args)

    @property
    def i_geometry(self) -> NodeSocket:
        """Input socket: Geometry"""
        return self._input("Geometry")

    @property
    def o_point_count(self) -> bpy.types.NodeSocketInt:
        """Output socket: Point Count"""
        return self._output("Point Count")

    @property
    def o_edge_count(self) -> bpy.types.NodeSocketInt:
        """Output socket: Edge Count"""
        return self._output("Edge Count")

    @property
    def o_face_count(self) -> bpy.types.NodeSocketInt:
        """Output socket: Face Count"""
        return self._output("Face Count")

    @property
    def o_face_corner_count(self) -> bpy.types.NodeSocketInt:
        """Output socket: Face Corner Count"""
        return self._output("Face Corner Count")

    @property
    def component(
        self,
    ) -> Literal["MESH", "POINTCLOUD", "CURVE", "INSTANCES", "GREASEPENCIL"]:
        return self.node.component

    @component.setter
    def component(
        self, value: Literal["MESH", "POINTCLOUD", "CURVE", "INSTANCES", "GREASEPENCIL"]
    ):
        self.node.component = value


class AttributeStatistic(NodeBuilder):
    """Calculate statistics about a data set from a field evaluated on a geometry"""

    name = "GeometryNodeAttributeStatistic"
    node: bpy.types.GeometryNodeAttributeStatistic

    def __init__(
        self,
        geometry: LINKABLE = None,
        selection: TYPE_INPUT_BOOLEAN = True,
        attribute: float | LINKABLE | None = 0.0,
        data_type: Literal[
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4",
        ] = "FLOAT",
        domain: Literal[
            "POINT", "EDGE", "FACE", "CORNER", "CURVE", "INSTANCE", "LAYER"
        ] = "POINT",
        **kwargs,
    ):
        super().__init__()
        key_args = {
            "Geometry": geometry,
            "Selection": selection,
            "Attribute": attribute,
        }
        key_args.update(kwargs)
        self.data_type = data_type
        self.domain = domain
        self._establish_links(**key_args)

    @property
    def i_geometry(self) -> NodeSocket:
        """Input socket: Geometry"""
        return self._input("Geometry")

    @property
    def i_selection(self) -> bpy.types.NodeSocketBool:
        """Input socket: Selection"""
        return self._input("Selection")

    @property
    def i_attribute(self) -> bpy.types.NodeSocketFloat:
        """Input socket: Attribute"""
        return self._input("Attribute")

    @property
    def o_mean(self) -> bpy.types.NodeSocketFloat:
        """Output socket: Mean"""
        return self._output("Mean")

    @property
    def o_median(self) -> bpy.types.NodeSocketFloat:
        """Output socket: Median"""
        return self._output("Median")

    @property
    def o_sum(self) -> bpy.types.NodeSocketFloat:
        """Output socket: Sum"""
        return self._output("Sum")

    @property
    def o_min(self) -> bpy.types.NodeSocketFloat:
        """Output socket: Min"""
        return self._output("Min")

    @property
    def o_max(self) -> bpy.types.NodeSocketFloat:
        """Output socket: Max"""
        return self._output("Max")

    @property
    def o_range(self) -> bpy.types.NodeSocketFloat:
        """Output socket: Range"""
        return self._output("Range")

    @property
    def o_standard_deviation(self) -> bpy.types.NodeSocketFloat:
        """Output socket: Standard Deviation"""
        return self._output("Standard Deviation")

    @property
    def o_variance(self) -> bpy.types.NodeSocketFloat:
        """Output socket: Variance"""
        return self._output("Variance")

    @property
    def data_type(
        self,
    ) -> Literal[
        "FLOAT",
        "INT",
        "FLOAT_VECTOR",
        "FLOAT_COLOR",
        "BYTE_COLOR",
        "STRING",
        "BOOLEAN",
        "FLOAT2",
        "INT8",
        "INT16_2D",
        "INT32_2D",
        "QUATERNION",
        "FLOAT4X4",
    ]:
        return self.node.data_type

    @data_type.setter
    def data_type(
        self,
        value: Literal[
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4",
        ],
    ):
        self.node.data_type = value

    @property
    def domain(
        self,
    ) -> Literal["POINT", "EDGE", "FACE", "CORNER", "CURVE", "INSTANCE", "LAYER"]:
        return self.node.domain

    @domain.setter
    def domain(
        self,
        value: Literal["POINT", "EDGE", "FACE", "CORNER", "CURVE", "INSTANCE", "LAYER"],
    ):
        self.node.domain = value


class BlurAttribute(NodeBuilder):
    """Mix attribute values of neighboring elements"""

    name = "GeometryNodeBlurAttribute"
    node: bpy.types.GeometryNodeBlurAttribute

    def __init__(
        self,
        value: float | LINKABLE | None = 0.0,
        iterations: int | LINKABLE | None = 1,
        weight: LINKABLE | None = 1.0,
        data_type: Literal[
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4",
        ] = "FLOAT",
        **kwargs,
    ):
        super().__init__()
        key_args = {"Value": value, "Iterations": iterations, "Weight": weight}
        key_args.update(kwargs)
        self.data_type = data_type
        self._establish_links(**key_args)

    @property
    def i_value(self) -> bpy.types.NodeSocketFloat:
        """Input socket: Value"""
        return self._input("Value")

    @property
    def i_iterations(self) -> bpy.types.NodeSocketInt:
        """Input socket: Iterations"""
        return self._input("Iterations")

    @property
    def i_weight(self) -> NodeSocket:
        """Input socket: Weight"""
        return self._input("Weight")

    @property
    def o_value(self) -> bpy.types.NodeSocketFloat:
        """Output socket: Value"""
        return self._output("Value")

    @property
    def data_type(
        self,
    ) -> Literal[
        "FLOAT",
        "INT",
        "FLOAT_VECTOR",
        "FLOAT_COLOR",
        "BYTE_COLOR",
        "STRING",
        "BOOLEAN",
        "FLOAT2",
        "INT8",
        "INT16_2D",
        "INT32_2D",
        "QUATERNION",
        "FLOAT4X4",
    ]:
        return self.node.data_type

    @data_type.setter
    def data_type(
        self,
        value: Literal[
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4",
        ],
    ):
        self.node.data_type = value


class CaptureAttribute(NodeBuilder):
    """Store the result of a field on a geometry and output the data as a node socket. Allows remembering or interpolating data as the geometry changes, such as positions before deformation"""

    name = "GeometryNodeCaptureAttribute"
    node: bpy.types.GeometryNodeCaptureAttribute

    def __init__(
        self,
        geometry: LINKABLE = None,
        extend: LINKABLE | None = None,
        active_index: int = 0,
        domain: Literal[
            "POINT", "EDGE", "FACE", "CORNER", "CURVE", "INSTANCE", "LAYER"
        ] = "POINT",
        **kwargs,
    ):
        super().__init__()
        key_args = {"Geometry": geometry, "__extend__": extend}
        key_args.update(kwargs)
        self.active_index = active_index
        self.domain = domain
        self._establish_links(**key_args)

    @property
    def i_geometry(self) -> NodeSocket:
        """Input socket: Geometry"""
        return self._input("Geometry")

    @property
    def i_input_socket(self) -> NodeSocket:
        """Input socket:"""
        return self._input("__extend__")

    @property
    def o_geometry(self) -> NodeSocket:
        """Output socket: Geometry"""
        return self._output("Geometry")

    @property
    def o_input_socket(self) -> NodeSocket:
        """Output socket:"""
        return self._output("__extend__")

    @property
    def active_index(self) -> int:
        return self.node.active_index

    @active_index.setter
    def active_index(self, value: int):
        self.node.active_index = value

    @property
    def domain(
        self,
    ) -> Literal["POINT", "EDGE", "FACE", "CORNER", "CURVE", "INSTANCE", "LAYER"]:
        return self.node.domain

    @domain.setter
    def domain(
        self,
        value: Literal["POINT", "EDGE", "FACE", "CORNER", "CURVE", "INSTANCE", "LAYER"],
    ):
        self.node.domain = value


class NamedAttribute(NodeBuilder):
    """Retrieve the data of a specified attribute"""

    name = "GeometryNodeInputNamedAttribute"
    node: bpy.types.GeometryNodeInputNamedAttribute

    def __init__(
        self,
        name: str | LINKABLE | None = "",
        data_type: Literal[
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4",
        ] = "FLOAT",
        **kwargs,
    ):
        super().__init__()
        key_args = {"Name": name}
        key_args.update(kwargs)
        self.data_type = data_type
        self._establish_links(**key_args)

    @property
    def i_name(self) -> bpy.types.NodeSocketString:
        """Input socket: Name"""
        return self._input("Name")

    @property
    def o_attribute(self) -> bpy.types.NodeSocketFloat:
        """Output socket: Attribute"""
        return self._output("Attribute")

    @property
    def o_exists(self) -> bpy.types.NodeSocketBool:
        """Output socket: Exists"""
        return self._output("Exists")

    @property
    def data_type(
        self,
    ) -> Literal[
        "FLOAT",
        "INT",
        "FLOAT_VECTOR",
        "FLOAT_COLOR",
        "BYTE_COLOR",
        "STRING",
        "BOOLEAN",
        "FLOAT2",
        "INT8",
        "INT16_2D",
        "INT32_2D",
        "QUATERNION",
        "FLOAT4X4",
    ]:
        return self.node.data_type

    @data_type.setter
    def data_type(
        self,
        value: Literal[
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4",
        ],
    ):
        self.node.data_type = value


class RemoveNamedAttribute(NodeBuilder):
    """Delete an attribute with a specified name from a geometry. Typically used to optimize performance"""

    name = "GeometryNodeRemoveAttribute"
    node: bpy.types.GeometryNodeRemoveAttribute

    def __init__(
        self,
        geometry: LINKABLE = None,
        name: str | LINKABLE | None = "",
        pattern_mode: Literal["EXACT", "WILDCARD"] = "EXACT",
        **kwargs,
    ):
        super().__init__()
        key_args = {"Geometry": geometry, "Name": name}
        key_args.update(kwargs)
        self.pattern_mode = pattern_mode
        self._establish_links(**key_args)

    @property
    def i_geometry(self) -> NodeSocket:
        """Input socket: Geometry"""
        return self._input("Geometry")

    @property
    def i_name(self) -> bpy.types.NodeSocketString:
        """Input socket: Name"""
        return self._input("Name")

    @property
    def o_geometry(self) -> NodeSocket:
        """Output socket: Geometry"""
        return self._output("Geometry")

    @property
    def pattern_mode(self) -> Literal["EXACT", "WILDCARD"]:
        return self.node.pattern_mode

    @pattern_mode.setter
    def pattern_mode(self, value: Literal["EXACT", "WILDCARD"]):
        self.node.pattern_mode = value


class StoreNamedAttribute(NodeBuilder):
    """Store the result of a field on a geometry as an attribute with the specified name"""

    name = "GeometryNodeStoreNamedAttribute"
    node: bpy.types.GeometryNodeStoreNamedAttribute

    def __init__(
        self,
        geometry: LINKABLE = None,
        selection: TYPE_INPUT_BOOLEAN = True,
        name: str | LINKABLE | None = "",
        value: float | LINKABLE | None = 0.0,
        data_type: Literal[
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4",
        ] = "FLOAT",
        domain: Literal[
            "POINT", "EDGE", "FACE", "CORNER", "CURVE", "INSTANCE", "LAYER"
        ] = "POINT",
        **kwargs,
    ):
        super().__init__()
        key_args = {
            "Geometry": geometry,
            "Selection": selection,
            "Name": name,
            "Value": value,
        }
        key_args.update(kwargs)
        self.data_type = data_type
        self.domain = domain
        self._establish_links(**key_args)

    @property
    def i_geometry(self) -> NodeSocket:
        """Input socket: Geometry"""
        return self._input("Geometry")

    @property
    def i_selection(self) -> bpy.types.NodeSocketBool:
        """Input socket: Selection"""
        return self._input("Selection")

    @property
    def i_name(self) -> bpy.types.NodeSocketString:
        """Input socket: Name"""
        return self._input("Name")

    @property
    def i_value(self) -> bpy.types.NodeSocketFloat:
        """Input socket: Value"""
        return self._input("Value")

    @property
    def o_geometry(self) -> NodeSocket:
        """Output socket: Geometry"""
        return self._output("Geometry")

    @property
    def data_type(
        self,
    ) -> Literal[
        "FLOAT",
        "INT",
        "FLOAT_VECTOR",
        "FLOAT_COLOR",
        "BYTE_COLOR",
        "STRING",
        "BOOLEAN",
        "FLOAT2",
        "INT8",
        "INT16_2D",
        "INT32_2D",
        "QUATERNION",
        "FLOAT4X4",
    ]:
        return self.node.data_type

    @data_type.setter
    def data_type(
        self,
        value: Literal[
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4",
        ],
    ):
        self.node.data_type = value

    @property
    def domain(
        self,
    ) -> Literal["POINT", "EDGE", "FACE", "CORNER", "CURVE", "INSTANCE", "LAYER"]:
        return self.node.domain

    @domain.setter
    def domain(
        self,
        value: Literal["POINT", "EDGE", "FACE", "CORNER", "CURVE", "INSTANCE", "LAYER"],
    ):
        self.node.domain = value
