"""
Auto-generated Blender Geometry Node classes.

DO NOT EDIT THIS FILE MANUALLY.
This file is generated by molecularnodes/nodes/generator.py

To regenerate: Run generator.py from within Blender

KNOWN LIMITATIONS:
- Dynamic multi-input/output sockets are not yet supported
  (these are the unnamed sockets that appear in the UI for nodes like
  "Evaluate Closure", "Join Geometry", etc. that allow dragging in
  multiple connections)
- TODO: Add support for dynamic socket creation
"""

from __future__ import annotations
from typing import Any
from bpy.types import NodeSocket
from ..builder import NodeBuilder, TreeBuilder

# Type aliases for node inputs
LINKABLE = "NodeSocket | NodeBuilder | Any"
TYPE_INPUT_VECTOR = "tuple[float, float, float] | NodeSocket | NodeBuilder | None"
TYPE_INPUT_ROTATION = (
    "tuple[float, float, float, float] | NodeSocket | NodeBuilder | None"
)
TYPE_INPUT_BOOLEAN = "bool | NodeSocket | NodeBuilder | None"


class BooleanMath(NodeBuilder):
    """Boolean Math node"""

    name = "FunctionNodeBooleanMath"

    def __init__(
        self,
        boolean: TYPE_INPUT_BOOLEAN = None,
        boolean_001: TYPE_INPUT_BOOLEAN = None,
        operation: str | None = None,
    ):
        super().__init__()
        self._establish_links(**{"Boolean": boolean, "Boolean_001": boolean_001})
        if operation is not None:
            self.node.operation = operation

    @classmethod
    def and_(
        cls, boolean: TYPE_INPUT_BOOLEAN = None, boolean_001: TYPE_INPUT_BOOLEAN = None
    ) -> "BooleanMath":
        """Create Boolean Math with operation 'And'."""
        return cls(operation="AND", boolean=boolean, boolean_001=boolean_001)

    @classmethod
    def or_(
        cls, boolean: TYPE_INPUT_BOOLEAN = None, boolean_001: TYPE_INPUT_BOOLEAN = None
    ) -> "BooleanMath":
        """Create Boolean Math with operation 'Or'."""
        return cls(operation="OR", boolean=boolean, boolean_001=boolean_001)

    @classmethod
    def not_(
        cls, boolean: TYPE_INPUT_BOOLEAN = None, boolean_001: TYPE_INPUT_BOOLEAN = None
    ) -> "BooleanMath":
        """Create Boolean Math with operation 'Not'."""
        return cls(operation="NOT", boolean=boolean, boolean_001=boolean_001)

    @classmethod
    def nand_(
        cls, boolean: TYPE_INPUT_BOOLEAN = None, boolean_001: TYPE_INPUT_BOOLEAN = None
    ) -> "BooleanMath":
        """Create Boolean Math with operation 'Not And'."""
        return cls(operation="NAND", boolean=boolean, boolean_001=boolean_001)

    @classmethod
    def nor_(
        cls, boolean: TYPE_INPUT_BOOLEAN = None, boolean_001: TYPE_INPUT_BOOLEAN = None
    ) -> "BooleanMath":
        """Create Boolean Math with operation 'Nor'."""
        return cls(operation="NOR", boolean=boolean, boolean_001=boolean_001)

    @classmethod
    def xnor_(
        cls, boolean: TYPE_INPUT_BOOLEAN = None, boolean_001: TYPE_INPUT_BOOLEAN = None
    ) -> "BooleanMath":
        """Create Boolean Math with operation 'Equal'."""
        return cls(operation="XNOR", boolean=boolean, boolean_001=boolean_001)

    @classmethod
    def xor_(
        cls, boolean: TYPE_INPUT_BOOLEAN = None, boolean_001: TYPE_INPUT_BOOLEAN = None
    ) -> "BooleanMath":
        """Create Boolean Math with operation 'Not Equal'."""
        return cls(operation="XOR", boolean=boolean, boolean_001=boolean_001)

    @classmethod
    def imply_(
        cls, boolean: TYPE_INPUT_BOOLEAN = None, boolean_001: TYPE_INPUT_BOOLEAN = None
    ) -> "BooleanMath":
        """Create Boolean Math with operation 'Imply'."""
        return cls(operation="IMPLY", boolean=boolean, boolean_001=boolean_001)

    @classmethod
    def nimply_(
        cls, boolean: TYPE_INPUT_BOOLEAN = None, boolean_001: TYPE_INPUT_BOOLEAN = None
    ) -> "BooleanMath":
        """Create Boolean Math with operation 'Subtract'."""
        return cls(operation="NIMPLY", boolean=boolean, boolean_001=boolean_001)

    @property
    def boolean(self) -> NodeSocket:
        """Output socket: Boolean"""
        return self.node.outputs["Boolean"]


class CombineColor(NodeBuilder):
    """Combine Color node"""

    name = "FunctionNodeCombineColor"

    def __init__(
        self,
        red: LINKABLE | None = None,
        green: LINKABLE | None = None,
        blue: LINKABLE | None = None,
        alpha: LINKABLE | None = None,
        mode: str | None = None,
    ):
        super().__init__()
        self._establish_links(
            **{"Red": red, "Green": green, "Blue": blue, "Alpha": alpha}
        )
        if mode is not None:
            self.node.mode = mode

    @property
    def color(self) -> NodeSocket:
        """Output socket: Color"""
        return self.node.outputs["Color"]


class Compare(NodeBuilder):
    """Compare node"""

    name = "FunctionNodeCompare"

    def __init__(
        self,
        a: float | LINKABLE | None = None,
        b: float | LINKABLE | None = None,
        operation: str | None = None,
        data_type: str | None = None,
        mode: str | None = None,
    ):
        super().__init__()
        self._establish_links(**{"A": a, "B": b})
        if operation is not None:
            self.node.operation = operation
        if data_type is not None:
            self.node.data_type = data_type
        if mode is not None:
            self.node.mode = mode

    @classmethod
    def less_than_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Less Than'."""
        return cls(operation="LESS_THAN", a=a, b=b)

    @classmethod
    def less_equal_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Less Than or Equal'."""
        return cls(operation="LESS_EQUAL", a=a, b=b)

    @classmethod
    def greater_than_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Greater Than'."""
        return cls(operation="GREATER_THAN", a=a, b=b)

    @classmethod
    def greater_equal_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Greater Than or Equal'."""
        return cls(operation="GREATER_EQUAL", a=a, b=b)

    @classmethod
    def equal_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Equal'."""
        return cls(operation="EQUAL", a=a, b=b)

    @classmethod
    def not_equal_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Not Equal'."""
        return cls(operation="NOT_EQUAL", a=a, b=b)

    @classmethod
    def brighter_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Brighter'."""
        return cls(operation="BRIGHTER", a=a, b=b)

    @classmethod
    def darker_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Darker'."""
        return cls(operation="DARKER", a=a, b=b)

    @property
    def result(self) -> NodeSocket:
        """Output socket: Result"""
        return self.node.outputs["Result"]


class FloatToInteger(NodeBuilder):
    """Float to Integer node"""

    name = "FunctionNodeFloatToInt"

    def __init__(
        self, float: float | LINKABLE | None = None, rounding_mode: str | None = None
    ):
        super().__init__()
        self._establish_links(**{"Float": float})
        if rounding_mode is not None:
            self.node.rounding_mode = rounding_mode

    @property
    def integer(self) -> NodeSocket:
        """Output socket: Integer"""
        return self.node.outputs["Integer"]


class HashValue(NodeBuilder):
    """Hash Value node"""

    name = "FunctionNodeHashValue"

    def __init__(
        self,
        value: int | LINKABLE | None = None,
        seed: int | LINKABLE | None = None,
        data_type: str | None = None,
    ):
        super().__init__()
        self._establish_links(**{"Value": value, "Seed": seed})
        if data_type is not None:
            self.node.data_type = data_type

    @property
    def hash(self) -> NodeSocket:
        """Output socket: Hash"""
        return self.node.outputs["Hash"]


class RandomValue(NodeBuilder):
    """Random Value node"""

    name = "FunctionNodeRandomValue"

    def __init__(
        self,
        min_001: float | LINKABLE | None = None,
        max_001: float | LINKABLE | None = None,
        id: int | LINKABLE | None = None,
        seed: int | LINKABLE | None = None,
        data_type: str | None = None,
    ):
        super().__init__()
        self._establish_links(
            **{"Min_001": min_001, "Max_001": max_001, "ID": id, "Seed": seed}
        )
        if data_type is not None:
            self.node.data_type = data_type

    @property
    def value(self) -> NodeSocket:
        """Output socket: Value"""
        return self.node.outputs["Value"]


class SeparateColor(NodeBuilder):
    """Separate Color node"""

    name = "FunctionNodeSeparateColor"

    def __init__(
        self,
        color: tuple[float, float, float, float] | LINKABLE | None = None,
        mode: str | None = None,
    ):
        super().__init__()
        self._establish_links(**{"Color": color})
        if mode is not None:
            self.node.mode = mode

    @property
    def red(self) -> NodeSocket:
        """Output socket: Red"""
        return self.node.outputs["Red"]

    @property
    def green(self) -> NodeSocket:
        """Output socket: Green"""
        return self.node.outputs["Green"]

    @property
    def blue(self) -> NodeSocket:
        """Output socket: Blue"""
        return self.node.outputs["Blue"]

    @property
    def alpha(self) -> NodeSocket:
        """Output socket: Alpha"""
        return self.node.outputs["Alpha"]


class Clamp(NodeBuilder):
    """Clamp a value between a minimum and a maximum"""

    name = "ShaderNodeClamp"

    def __init__(
        self,
        value: float | LINKABLE | None = None,
        min: float | LINKABLE | None = None,
        max: float | LINKABLE | None = None,
        clamp_type: str | None = None,
    ):
        super().__init__()
        self._establish_links(**{"Value": value, "Min": min, "Max": max})
        if clamp_type is not None:
            self.node.clamp_type = clamp_type

    @property
    def result(self) -> NodeSocket:
        """Output socket: Result"""
        return self.node.outputs["Result"]


class CombineXyz(NodeBuilder):
    """Create a vector from X, Y, and Z components"""

    name = "ShaderNodeCombineXYZ"

    def __init__(
        self,
        x: float | LINKABLE | None = None,
        y: float | LINKABLE | None = None,
        z: float | LINKABLE | None = None,
    ):
        super().__init__()
        self._establish_links(**{"X": x, "Y": y, "Z": z})

    @property
    def vector(self) -> NodeSocket:
        """Output socket: Vector"""
        return self.node.outputs["Vector"]


class MapRange(NodeBuilder):
    """Remap a value from a range to a target range"""

    name = "ShaderNodeMapRange"

    def __init__(
        self,
        value: float | LINKABLE | None = None,
        from_min: float | LINKABLE | None = None,
        from_max: float | LINKABLE | None = None,
        to_min: float | LINKABLE | None = None,
        to_max: float | LINKABLE | None = None,
        clamp: bool | None = None,
        interpolation_type: str | None = None,
        data_type: str | None = None,
    ):
        super().__init__()
        self._establish_links(
            **{
                "Value": value,
                "From Min": from_min,
                "From Max": from_max,
                "To Min": to_min,
                "To Max": to_max,
            }
        )
        if clamp is not None:
            self.node.clamp = clamp
        if interpolation_type is not None:
            self.node.interpolation_type = interpolation_type
        if data_type is not None:
            self.node.data_type = data_type

    @property
    def result(self) -> NodeSocket:
        """Output socket: Result"""
        return self.node.outputs["Result"]


class Math(NodeBuilder):
    """Perform math operations"""

    name = "ShaderNodeMath"

    def __init__(
        self,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
        operation: str | None = None,
        use_clamp: bool | None = None,
    ):
        super().__init__()
        self._establish_links(**{"Value": value, "Value_001": value_001})
        if operation is not None:
            self.node.operation = operation
        if use_clamp is not None:
            self.node.use_clamp = use_clamp

    @classmethod
    def add_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Add'."""
        return cls(operation="ADD", value=value, value_001=value_001)

    @classmethod
    def subtract_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Subtract'."""
        return cls(operation="SUBTRACT", value=value, value_001=value_001)

    @classmethod
    def multiply_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Multiply'."""
        return cls(operation="MULTIPLY", value=value, value_001=value_001)

    @classmethod
    def divide_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Divide'."""
        return cls(operation="DIVIDE", value=value, value_001=value_001)

    @classmethod
    def multiply_add_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Multiply Add'."""
        return cls(operation="MULTIPLY_ADD", value=value, value_001=value_001)

    @classmethod
    def power_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Power'."""
        return cls(operation="POWER", value=value, value_001=value_001)

    @classmethod
    def logarithm_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Logarithm'."""
        return cls(operation="LOGARITHM", value=value, value_001=value_001)

    @classmethod
    def sqrt_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Square Root'."""
        return cls(operation="SQRT", value=value, value_001=value_001)

    @classmethod
    def inverse_sqrt_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Inverse Square Root'."""
        return cls(operation="INVERSE_SQRT", value=value, value_001=value_001)

    @classmethod
    def absolute_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Absolute'."""
        return cls(operation="ABSOLUTE", value=value, value_001=value_001)

    @classmethod
    def exponent_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Exponent'."""
        return cls(operation="EXPONENT", value=value, value_001=value_001)

    @classmethod
    def minimum_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Minimum'."""
        return cls(operation="MINIMUM", value=value, value_001=value_001)

    @classmethod
    def maximum_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Maximum'."""
        return cls(operation="MAXIMUM", value=value, value_001=value_001)

    @classmethod
    def less_than_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Less Than'."""
        return cls(operation="LESS_THAN", value=value, value_001=value_001)

    @classmethod
    def greater_than_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Greater Than'."""
        return cls(operation="GREATER_THAN", value=value, value_001=value_001)

    @classmethod
    def sign_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Sign'."""
        return cls(operation="SIGN", value=value, value_001=value_001)

    @classmethod
    def compare_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Compare'."""
        return cls(operation="COMPARE", value=value, value_001=value_001)

    @classmethod
    def smooth_min_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Smooth Minimum'."""
        return cls(operation="SMOOTH_MIN", value=value, value_001=value_001)

    @classmethod
    def smooth_max_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Smooth Maximum'."""
        return cls(operation="SMOOTH_MAX", value=value, value_001=value_001)

    @classmethod
    def round_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Round'."""
        return cls(operation="ROUND", value=value, value_001=value_001)

    @classmethod
    def floor_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Floor'."""
        return cls(operation="FLOOR", value=value, value_001=value_001)

    @classmethod
    def ceil_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Ceil'."""
        return cls(operation="CEIL", value=value, value_001=value_001)

    @classmethod
    def trunc_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Truncate'."""
        return cls(operation="TRUNC", value=value, value_001=value_001)

    @classmethod
    def fract_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Fraction'."""
        return cls(operation="FRACT", value=value, value_001=value_001)

    @classmethod
    def modulo_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Truncated Modulo'."""
        return cls(operation="MODULO", value=value, value_001=value_001)

    @classmethod
    def floored_modulo_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Floored Modulo'."""
        return cls(operation="FLOORED_MODULO", value=value, value_001=value_001)

    @classmethod
    def wrap_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Wrap'."""
        return cls(operation="WRAP", value=value, value_001=value_001)

    @classmethod
    def snap_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Snap'."""
        return cls(operation="SNAP", value=value, value_001=value_001)

    @classmethod
    def pingpong_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Ping-Pong'."""
        return cls(operation="PINGPONG", value=value, value_001=value_001)

    @classmethod
    def sine_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Sine'."""
        return cls(operation="SINE", value=value, value_001=value_001)

    @classmethod
    def cosine_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Cosine'."""
        return cls(operation="COSINE", value=value, value_001=value_001)

    @classmethod
    def tangent_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Tangent'."""
        return cls(operation="TANGENT", value=value, value_001=value_001)

    @classmethod
    def arcsine_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Arcsine'."""
        return cls(operation="ARCSINE", value=value, value_001=value_001)

    @classmethod
    def arccosine_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Arccosine'."""
        return cls(operation="ARCCOSINE", value=value, value_001=value_001)

    @classmethod
    def arctangent_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Arctangent'."""
        return cls(operation="ARCTANGENT", value=value, value_001=value_001)

    @classmethod
    def arctan2_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Arctan2'."""
        return cls(operation="ARCTAN2", value=value, value_001=value_001)

    @classmethod
    def sinh_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Hyperbolic Sine'."""
        return cls(operation="SINH", value=value, value_001=value_001)

    @classmethod
    def cosh_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Hyperbolic Cosine'."""
        return cls(operation="COSH", value=value, value_001=value_001)

    @classmethod
    def tanh_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'Hyperbolic Tangent'."""
        return cls(operation="TANH", value=value, value_001=value_001)

    @classmethod
    def radians_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'To Radians'."""
        return cls(operation="RADIANS", value=value, value_001=value_001)

    @classmethod
    def degrees_(
        cls,
        value: float | LINKABLE | None = None,
        value_001: float | LINKABLE | None = None,
    ) -> "Math":
        """Create Math with operation 'To Degrees'."""
        return cls(operation="DEGREES", value=value, value_001=value_001)

    @property
    def value(self) -> NodeSocket:
        """Output socket: Value"""
        return self.node.outputs["Value"]


class Mix(NodeBuilder):
    """Mix values by a factor"""

    name = "ShaderNodeMix"

    def __init__(
        self,
        factor_float: LINKABLE | None = None,
        a_float: float | LINKABLE | None = None,
        b_float: float | LINKABLE | None = None,
        data_type: str | None = None,
        factor_mode: str | None = None,
        blend_type: str | None = None,
        clamp_factor: bool | None = None,
        clamp_result: bool | None = None,
    ):
        super().__init__()
        self._establish_links(
            **{"Factor_Float": factor_float, "A_Float": a_float, "B_Float": b_float}
        )
        if data_type is not None:
            self.node.data_type = data_type
        if factor_mode is not None:
            self.node.factor_mode = factor_mode
        if blend_type is not None:
            self.node.blend_type = blend_type
        if clamp_factor is not None:
            self.node.clamp_factor = clamp_factor
        if clamp_result is not None:
            self.node.clamp_result = clamp_result

    @property
    def result(self) -> NodeSocket:
        """Output socket: Result"""
        return self.node.outputs["Result"]


class SeparateXyz(NodeBuilder):
    """Split a vector into its X, Y, and Z components"""

    name = "ShaderNodeSeparateXYZ"

    def __init__(self, vector: TYPE_INPUT_VECTOR = None):
        super().__init__()
        self._establish_links(**{"Vector": vector})

    @property
    def x(self) -> NodeSocket:
        """Output socket: X"""
        return self.node.outputs["X"]

    @property
    def y(self) -> NodeSocket:
        """Output socket: Y"""
        return self.node.outputs["Y"]

    @property
    def z(self) -> NodeSocket:
        """Output socket: Z"""
        return self.node.outputs["Z"]


class VectorMath(NodeBuilder):
    """Perform vector math operation"""

    name = "ShaderNodeVectorMath"

    def __init__(
        self,
        vector: TYPE_INPUT_VECTOR = None,
        vector_001: TYPE_INPUT_VECTOR = None,
        operation: str | None = None,
    ):
        super().__init__()
        self._establish_links(**{"Vector": vector, "Vector_001": vector_001})
        if operation is not None:
            self.node.operation = operation

    @classmethod
    def add_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Add'."""
        return cls(operation="ADD", vector=vector, vector_001=vector_001)

    @classmethod
    def subtract_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Subtract'."""
        return cls(operation="SUBTRACT", vector=vector, vector_001=vector_001)

    @classmethod
    def multiply_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Multiply'."""
        return cls(operation="MULTIPLY", vector=vector, vector_001=vector_001)

    @classmethod
    def divide_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Divide'."""
        return cls(operation="DIVIDE", vector=vector, vector_001=vector_001)

    @classmethod
    def multiply_add_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Multiply Add'."""
        return cls(operation="MULTIPLY_ADD", vector=vector, vector_001=vector_001)

    @classmethod
    def cross_product_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Cross Product'."""
        return cls(operation="CROSS_PRODUCT", vector=vector, vector_001=vector_001)

    @classmethod
    def project_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Project'."""
        return cls(operation="PROJECT", vector=vector, vector_001=vector_001)

    @classmethod
    def reflect_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Reflect'."""
        return cls(operation="REFLECT", vector=vector, vector_001=vector_001)

    @classmethod
    def refract_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Refract'."""
        return cls(operation="REFRACT", vector=vector, vector_001=vector_001)

    @classmethod
    def faceforward_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Faceforward'."""
        return cls(operation="FACEFORWARD", vector=vector, vector_001=vector_001)

    @classmethod
    def dot_product_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Dot Product'."""
        return cls(operation="DOT_PRODUCT", vector=vector, vector_001=vector_001)

    @classmethod
    def distance_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Distance'."""
        return cls(operation="DISTANCE", vector=vector, vector_001=vector_001)

    @classmethod
    def length_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Length'."""
        return cls(operation="LENGTH", vector=vector, vector_001=vector_001)

    @classmethod
    def scale_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Scale'."""
        return cls(operation="SCALE", vector=vector, vector_001=vector_001)

    @classmethod
    def normalize_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Normalize'."""
        return cls(operation="NORMALIZE", vector=vector, vector_001=vector_001)

    @classmethod
    def absolute_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Absolute'."""
        return cls(operation="ABSOLUTE", vector=vector, vector_001=vector_001)

    @classmethod
    def power_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Power'."""
        return cls(operation="POWER", vector=vector, vector_001=vector_001)

    @classmethod
    def sign_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Sign'."""
        return cls(operation="SIGN", vector=vector, vector_001=vector_001)

    @classmethod
    def minimum_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Minimum'."""
        return cls(operation="MINIMUM", vector=vector, vector_001=vector_001)

    @classmethod
    def maximum_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Maximum'."""
        return cls(operation="MAXIMUM", vector=vector, vector_001=vector_001)

    @classmethod
    def floor_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Floor'."""
        return cls(operation="FLOOR", vector=vector, vector_001=vector_001)

    @classmethod
    def ceil_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Ceil'."""
        return cls(operation="CEIL", vector=vector, vector_001=vector_001)

    @classmethod
    def fraction_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Fraction'."""
        return cls(operation="FRACTION", vector=vector, vector_001=vector_001)

    @classmethod
    def modulo_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Modulo'."""
        return cls(operation="MODULO", vector=vector, vector_001=vector_001)

    @classmethod
    def wrap_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Wrap'."""
        return cls(operation="WRAP", vector=vector, vector_001=vector_001)

    @classmethod
    def snap_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Snap'."""
        return cls(operation="SNAP", vector=vector, vector_001=vector_001)

    @classmethod
    def sine_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Sine'."""
        return cls(operation="SINE", vector=vector, vector_001=vector_001)

    @classmethod
    def cosine_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Cosine'."""
        return cls(operation="COSINE", vector=vector, vector_001=vector_001)

    @classmethod
    def tangent_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Tangent'."""
        return cls(operation="TANGENT", vector=vector, vector_001=vector_001)

    @property
    def vector(self) -> NodeSocket:
        """Output socket: Vector"""
        return self.node.outputs["Vector"]
