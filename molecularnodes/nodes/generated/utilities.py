"""
Auto-generated Blender Geometry Node classes.

DO NOT EDIT THIS FILE MANUALLY.
This file is generated by molecularnodes/nodes/generator.py

To regenerate: Run generator.py from within Blender

KNOWN LIMITATIONS:
- Dynamic multi-input/output sockets are not yet supported
  (these are the unnamed sockets that appear in the UI for nodes like
  "Evaluate Closure", "Join Geometry", etc. that allow dragging in
  multiple connections)
- TODO: Add support for dynamic socket creation
"""

from __future__ import annotations
from bpy.types import NodeSocket
from ..builder import NodeBuilder

# Type aliases for node inputs
LINKABLE = "NodeSocket | NodeBuilder | Any"
TYPE_INPUT_VECTOR = "tuple[float, float, float] | NodeSocket | NodeBuilder | None"
TYPE_INPUT_ROTATION = (
    "tuple[float, float, float, float] | NodeSocket | NodeBuilder | None"
)
TYPE_INPUT_BOOLEAN = "bool | NodeSocket | NodeBuilder | None"


class CombineColor(NodeBuilder):
    """Combine Color node"""

    name = "FunctionNodeCombineColor"

    def __init__(
        self,
        red: LINKABLE | None = None,
        green: LINKABLE | None = None,
        blue: LINKABLE | None = None,
        alpha: LINKABLE | None = None,
        mode: str | None = None,
    ):
        super().__init__()
        self._establish_links(
            **{"Red": red, "Green": green, "Blue": blue, "Alpha": alpha}
        )
        if mode is not None:
            self.node.mode = mode

    @property
    def color(self) -> NodeSocket:
        """Output socket: Color"""
        return self.node.outputs["Color"]


class Compare(NodeBuilder):
    """Compare node"""

    name = "FunctionNodeCompare"

    def __init__(
        self,
        a: float | LINKABLE | None = None,
        b: float | LINKABLE | None = None,
        operation: str | None = None,
        data_type: str | None = None,
        mode: str | None = None,
    ):
        super().__init__()
        self._establish_links(**{"A": a, "B": b})
        if operation is not None:
            self.node.operation = operation
        if data_type is not None:
            self.node.data_type = data_type
        if mode is not None:
            self.node.mode = mode

    @classmethod
    def less_than_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Less Than'."""
        return cls(operation="LESS_THAN", a=a, b=b)

    @classmethod
    def less_equal_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Less Than or Equal'."""
        return cls(operation="LESS_EQUAL", a=a, b=b)

    @classmethod
    def greater_than_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Greater Than'."""
        return cls(operation="GREATER_THAN", a=a, b=b)

    @classmethod
    def greater_equal_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Greater Than or Equal'."""
        return cls(operation="GREATER_EQUAL", a=a, b=b)

    @classmethod
    def equal_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Equal'."""
        return cls(operation="EQUAL", a=a, b=b)

    @classmethod
    def not_equal_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Not Equal'."""
        return cls(operation="NOT_EQUAL", a=a, b=b)

    @classmethod
    def brighter_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Brighter'."""
        return cls(operation="BRIGHTER", a=a, b=b)

    @classmethod
    def darker_(
        cls, a: float | LINKABLE | None = None, b: float | LINKABLE | None = None
    ) -> "Compare":
        """Create Compare with operation 'Darker'."""
        return cls(operation="DARKER", a=a, b=b)

    @property
    def result(self) -> NodeSocket:
        """Output socket: Result"""
        return self.node.outputs["Result"]


class FloatToInteger(NodeBuilder):
    """Float to Integer node"""

    name = "FunctionNodeFloatToInt"

    def __init__(
        self, float: float | LINKABLE | None = None, rounding_mode: str | None = None
    ):
        super().__init__()
        self._establish_links(**{"Float": float})
        if rounding_mode is not None:
            self.node.rounding_mode = rounding_mode

    @property
    def integer(self) -> NodeSocket:
        """Output socket: Integer"""
        return self.node.outputs["Integer"]


class HashValue(NodeBuilder):
    """Hash Value node"""

    name = "FunctionNodeHashValue"

    def __init__(
        self,
        value: int | LINKABLE | None = None,
        seed: int | LINKABLE | None = None,
        data_type: str | None = None,
    ):
        super().__init__()
        self._establish_links(**{"Value": value, "Seed": seed})
        if data_type is not None:
            self.node.data_type = data_type

    @property
    def hash(self) -> NodeSocket:
        """Output socket: Hash"""
        return self.node.outputs["Hash"]


class SeparateColor(NodeBuilder):
    """Separate Color node"""

    name = "FunctionNodeSeparateColor"

    def __init__(
        self,
        color: tuple[float, float, float, float] | LINKABLE | None = None,
        mode: str | None = None,
    ):
        super().__init__()
        self._establish_links(**{"Color": color})
        if mode is not None:
            self.node.mode = mode

    @property
    def red(self) -> NodeSocket:
        """Output socket: Red"""
        return self.node.outputs["Red"]

    @property
    def green(self) -> NodeSocket:
        """Output socket: Green"""
        return self.node.outputs["Green"]

    @property
    def blue(self) -> NodeSocket:
        """Output socket: Blue"""
        return self.node.outputs["Blue"]

    @property
    def alpha(self) -> NodeSocket:
        """Output socket: Alpha"""
        return self.node.outputs["Alpha"]


class Clamp(NodeBuilder):
    """Clamp a value between a minimum and a maximum"""

    name = "ShaderNodeClamp"

    def __init__(
        self,
        value: float | LINKABLE | None = None,
        min: float | LINKABLE | None = None,
        max: float | LINKABLE | None = None,
        clamp_type: str | None = None,
    ):
        super().__init__()
        self._establish_links(**{"Value": value, "Min": min, "Max": max})
        if clamp_type is not None:
            self.node.clamp_type = clamp_type

    @property
    def result(self) -> NodeSocket:
        """Output socket: Result"""
        return self.node.outputs["Result"]


class CombineXyz(NodeBuilder):
    """Create a vector from X, Y, and Z components"""

    name = "ShaderNodeCombineXYZ"

    def __init__(
        self,
        x: float | LINKABLE | None = None,
        y: float | LINKABLE | None = None,
        z: float | LINKABLE | None = None,
    ):
        super().__init__()
        self._establish_links(**{"X": x, "Y": y, "Z": z})

    @property
    def vector(self) -> NodeSocket:
        """Output socket: Vector"""
        return self.node.outputs["Vector"]


class MapRange(NodeBuilder):
    """Remap a value from a range to a target range"""

    name = "ShaderNodeMapRange"

    def __init__(
        self,
        value: float | LINKABLE | None = None,
        from_min: float | LINKABLE | None = None,
        from_max: float | LINKABLE | None = None,
        to_min: float | LINKABLE | None = None,
        to_max: float | LINKABLE | None = None,
        clamp: bool | None = None,
        interpolation_type: str | None = None,
        data_type: str | None = None,
    ):
        super().__init__()
        self._establish_links(
            **{
                "Value": value,
                "From Min": from_min,
                "From Max": from_max,
                "To Min": to_min,
                "To Max": to_max,
            }
        )
        if clamp is not None:
            self.node.clamp = clamp
        if interpolation_type is not None:
            self.node.interpolation_type = interpolation_type
        if data_type is not None:
            self.node.data_type = data_type

    @property
    def result(self) -> NodeSocket:
        """Output socket: Result"""
        return self.node.outputs["Result"]


class VectorMath(NodeBuilder):
    """Perform vector math operation"""

    name = "ShaderNodeVectorMath"

    def __init__(
        self,
        vector: TYPE_INPUT_VECTOR = None,
        vector_001: TYPE_INPUT_VECTOR = None,
        operation: str | None = None,
    ):
        super().__init__()
        self._establish_links(**{"Vector": vector, "Vector_001": vector_001})
        if operation is not None:
            self.node.operation = operation

    @classmethod
    def add_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Add'."""
        return cls(operation="ADD", vector=vector, vector_001=vector_001)

    @classmethod
    def subtract_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Subtract'."""
        return cls(operation="SUBTRACT", vector=vector, vector_001=vector_001)

    @classmethod
    def multiply_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Multiply'."""
        return cls(operation="MULTIPLY", vector=vector, vector_001=vector_001)

    @classmethod
    def divide_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Divide'."""
        return cls(operation="DIVIDE", vector=vector, vector_001=vector_001)

    @classmethod
    def multiply_add_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Multiply Add'."""
        return cls(operation="MULTIPLY_ADD", vector=vector, vector_001=vector_001)

    @classmethod
    def cross_product_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Cross Product'."""
        return cls(operation="CROSS_PRODUCT", vector=vector, vector_001=vector_001)

    @classmethod
    def project_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Project'."""
        return cls(operation="PROJECT", vector=vector, vector_001=vector_001)

    @classmethod
    def reflect_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Reflect'."""
        return cls(operation="REFLECT", vector=vector, vector_001=vector_001)

    @classmethod
    def refract_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Refract'."""
        return cls(operation="REFRACT", vector=vector, vector_001=vector_001)

    @classmethod
    def faceforward_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Faceforward'."""
        return cls(operation="FACEFORWARD", vector=vector, vector_001=vector_001)

    @classmethod
    def dot_product_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Dot Product'."""
        return cls(operation="DOT_PRODUCT", vector=vector, vector_001=vector_001)

    @classmethod
    def distance_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Distance'."""
        return cls(operation="DISTANCE", vector=vector, vector_001=vector_001)

    @classmethod
    def length_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Length'."""
        return cls(operation="LENGTH", vector=vector, vector_001=vector_001)

    @classmethod
    def scale_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Scale'."""
        return cls(operation="SCALE", vector=vector, vector_001=vector_001)

    @classmethod
    def normalize_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Normalize'."""
        return cls(operation="NORMALIZE", vector=vector, vector_001=vector_001)

    @classmethod
    def absolute_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Absolute'."""
        return cls(operation="ABSOLUTE", vector=vector, vector_001=vector_001)

    @classmethod
    def power_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Power'."""
        return cls(operation="POWER", vector=vector, vector_001=vector_001)

    @classmethod
    def sign_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Sign'."""
        return cls(operation="SIGN", vector=vector, vector_001=vector_001)

    @classmethod
    def minimum_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Minimum'."""
        return cls(operation="MINIMUM", vector=vector, vector_001=vector_001)

    @classmethod
    def maximum_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Maximum'."""
        return cls(operation="MAXIMUM", vector=vector, vector_001=vector_001)

    @classmethod
    def floor_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Floor'."""
        return cls(operation="FLOOR", vector=vector, vector_001=vector_001)

    @classmethod
    def ceil_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Ceil'."""
        return cls(operation="CEIL", vector=vector, vector_001=vector_001)

    @classmethod
    def fraction_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Fraction'."""
        return cls(operation="FRACTION", vector=vector, vector_001=vector_001)

    @classmethod
    def modulo_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Modulo'."""
        return cls(operation="MODULO", vector=vector, vector_001=vector_001)

    @classmethod
    def wrap_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Wrap'."""
        return cls(operation="WRAP", vector=vector, vector_001=vector_001)

    @classmethod
    def snap_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Snap'."""
        return cls(operation="SNAP", vector=vector, vector_001=vector_001)

    @classmethod
    def sine_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Sine'."""
        return cls(operation="SINE", vector=vector, vector_001=vector_001)

    @classmethod
    def cosine_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Cosine'."""
        return cls(operation="COSINE", vector=vector, vector_001=vector_001)

    @classmethod
    def tangent_(
        cls, vector: TYPE_INPUT_VECTOR = None, vector_001: TYPE_INPUT_VECTOR = None
    ) -> "VectorMath":
        """Create Vector Math with operation 'Tangent'."""
        return cls(operation="TANGENT", vector=vector, vector_001=vector_001)

    @property
    def vector(self) -> NodeSocket:
        """Output socket: Vector"""
        return self.node.outputs["Vector"]
